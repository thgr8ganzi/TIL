
## 데이터 타입

--------------------------

### 문자형

* char(n): 고정길이 문자열, n은 최대 길이, 레거시에 많이 쓰임
* varchar(n): 가변길이 문자열, n은 최대 길이, 최대길이를 넘어가면 잘림
* text: 가변길이 문자열, 최대길이 없음(1GB 까지 저장 가능)

### 숫자형

* smallint: 2byte, -32768 ~ 32767
* integer: 4byte, -2147483648 ~ 2147483647
* bigint: 8byte, -9223372036854775808 ~ 9223372036854775807

### 자동증가 정수

* smallserial: 2byte, 1 ~ 32767
* serial: 4byte, 1 ~ 2147483647
* bigserial: 8byte, 1 ~ 9223372036854775807
* `GENERATED ALWAYS AS IDENTITY` : 자동증가 정수
* `GENERATED BY DEFAULT AS IDENTITY` : 자동증가 정수

### 10 진수

| 데이터 타입           | 크기  | 저장방식 | 범위                       |
|------------------|-----| -------- |--------------------------|
| decimal          | 가변적 | 고정소수점 | 소수점 앞 131072 소수점 뒤 16383 |
| numeric          | 가변적 | 고정소수점 | 소수점 앞 131072 소수점 뒤 16383 |
| real             | 4byte | 부동소수점 | 소수점 뒤 6자리 숫자             |
| double precision | 8byte | 부동소수점 | 소수점 뒤 15자리 숫자            |

* 고정소수점 : 고정소수점은 첫 번째 칸을 부호비트, 그 다음 15칸은 정수부, 16칸은 소수부라고 부른다. 명칭 그대로 부호비트는 실수의 부호를 나타내는 비트 자리로 실수가 음수라면 1을, 양수라면 0을 넣는다. 그리고 정수부에는 실수의 정수 부분을, 소수부에는 실수의 소수부분을 넣는다. 정수부와 소수부의 경계 부분을 소수점의 위치로 생각하고 수를 그대로 넣으면 된다. 숫자들을 넣고 남은 칸들은 모두 0으로 채워진다.
* 부동 소수점 : 부동소수점 역시 첫 번째 칸은 부호비트이다. 다만 그 다음 8칸은 지수부, 나머지 23칸은 가수부이다. 부호 부분엔 실수가 음수일 경우 1, 양수일 경우 0을 자리시킨다. 지수부는 위 설명에서의 n에 bias를 더한 값을 2진수로 변환한 수를 넣는 부분이다. bias는 32비트에서는 127, 64비트에서는 1023이다.
```
-- 부동소수점 오류
CREATE TABLE number_data_types (
    numeric_column numeric(20,5),
    real_column real,
    double_column double precision
);

INSERT INTO number_data_types
VALUES
    (.7, .7, .7),
    (2.13579, 2.13579, 2.13579),
    (2.1357987654, 2.1357987654, 2.1357987654);

SELECT * FROM number_data_types;

SELECT
    numeric_column * 10000000 AS fixed,
    real_column * 10000000 AS floating
FROM number_data_types
WHERE numeric_column = .7;
```
* 가능하면 정수로
* 정확한 소수점 데이터는 numeric, decimal
* 충분히 큰 숫자 타입을 사용해야 한다.

### 날짜와 시간

| 데이터 타입 | 크기 | 설명 | 범위                   |
|--------|----|----|----------------------|
|timestamp|8byte|날짜와 시간| 4713 BC ~ 294276 AD  |
|date|4byte|날짜| 4713 BC ~ 5874897 AD |
|time|8byte|시간| 00:00:00 to 24:00:00 |
|interval|16byte|시간 간격| -178000000 years to 178000000 years |

* timestamp : 추적할수 있는 다양한 상황에서 유용한 날짜와 시간, 이벤트가 발생한 시간대가 포함되도록 키워드를 추가하는것이 좋음 timestamp with time zone 은 SQL 표준
* date : 날짜만 필요한 경우
* time : 시간만 필요한 경우
* interval : 시간 간격을 저장할 때 사용
```
CREATE TABLE date_time_types (
    timestamp_column timestamp with time zone,
    interval_column interval
);

INSERT INTO date_time_types
VALUES
    ('2022-12-31 01:00 EST','2 days'), -- 미국 동부시
    ('2022-12-31 01:00 -8','1 month'), -- UTC -8
    ('2022-12-31 01:00 Australia/Melbourne','1 century'), -- 영역과 위치의 이름으로 시간대 지정
    (now(),'1 week'); -- 현재 트랜잭션 시간

SELECT * FROM date_time_types;
```
* 시간 정보를 삽입할땐 국제 표준화 기구인 ISO 형식에 맞춰 입력한다(YYYY-MM-DD HH:MM:SS)

### interval 데이터 타입으로 날짜 계산

```
SELECT
    timestamp_column,
    interval_column,
    timestamp_column - interval_column AS new_date
FROM date_time_types;
```
* 표현식을 사용하여 timestamp 와 interval 을 계산할수 있다.
* 계산된 값은 timestamp with time zone 데이터 타입이다.
* timestamp 는 타임존을 명시하지 않는 날짜와 시간
* timestamp with time zone 은 타임존을 명시하는 날짜와 시간
```
CREATE TABLE test_time (
    timestamp_without_timezone timestamp,
    timestamp_with_timezone timestamptz
)

insert into test_time values (now(), now());

select *
from test_time;

show time zone;

set time zone 'UTC';
set time zone 'Asia/Seoul';
```

### JSON, JSONB

* json : JSON 텍스트를 그대로 저장
* jsonb : 텍스트를 바이너리 형식으로 변환해 저장
* jsonb 는 인덱싱을 지원하므로 처리속도가 빠르다
* JSON 은 2016년 SQL 표준으로 들어갔다.

### 그외

* boolean : true, false 값을 저장
* geometric : 점, 선, 폴리곤, 원, 원호, 선분, 박스 등의 기하학적 데이터를 저장
* text search : 텍스트 검색을 위한 데이터 타입
* network address : IP 주소, MAC 주소 등을 저장
* uuid : 범용 고유 식별자를 저장
* range : 범위를 저장
* 바이너리 데이터 타입
* XML, JSON 타입

### CAST

* 문자 타입에는 숫자가 포함될수 있기에 정수를 텍스트로 변환하는것이 가능
* 문자나 텍스트는 숫자로 변환할수 없다.
```
SELECT timestamp_column, CAST(timestamp_column AS varchar(10))
FROM date_time_types;

SELECT numeric_column,
       CAST(numeric_column AS integer),
       CAST(numeric_column AS text)
FROM number_data_types;
```
* :: 연산자를 사용하여 타입을 변환할수 있다.
```
SELECT timestamp_column::varchar(10)
FROM date_time_types;
```