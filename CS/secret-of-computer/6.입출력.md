## 입출력

* 그래픽인터페이스(GUI)의 발전은 사용자와 컴퓨터간의 상호작용을 발전시켰다
* 상호작용이란 컴퓨터의 입출력과 관련이 있다(증강현실, 가상현실)
* CPU 안에 레스터가 있는것처럼 장치안에도 장치디바이스(device register)가 있다
* 장치 레지스터의 기능은 데이터를 저장하고, 제어정보와 상태 정보를 저장한다.(키보드를 누르면 정보가 레지스터에 저장, 레지스터를 읽고 쓰고 제어하고 장치 상태를 본다)
* 원래 CPU 의 작동을 생각하면 장치마다 고유한 주소가 부여되고 각각 입출력 명령어(input output instruction)를 사용해 데이터를 주고 받는다
* CPU 는 기보적으로 메모리주소공간(memory address space)에서 데이터를 읽어 온다.
* 메모리의 주소공간 일부분을 장치에 할당하여 메모리 처럼 읽고 쓴ㄴ것을 메모리 사상 입출력(memory mapped I/O)이라고 한다
* 컴퓨터 저수준에는 두가지 입출력 방법이 있는데 첫번째는 특정 입출력 기계명령어를 사용하는것이고, 또 하나는 메모리의 읽기와 쓰기 명령어를 함께 사용하지만 주소 공간의 일부분을 장치에 할당하는것
* CPU 는 언제 장치에서 입출력이 들어올지 알수 없는데 이는 장치상태레지스터(device status register)를 통해 확인한다
* 폴링(polling)을 통하여 장치상태레지스터는 주기적으로 확인하고 장치가 준비되었는지 확인하고 동기적인 작업방식을 비동기로 바꿈으로서 최적화 할수 있다.
* 프로그램은 끊임없이 실행되는 것이 아니라 언제든 장치에 의해 중단 될수 있고 인터럽트 처리와 반환 작동 방식은 운영체제와 협조하여 프로그래머에게 중단 없이 실행되고 있는것 처럼 느낀다.
* 프로그램 실행 상태와 상태 복원 은 CPU 의 약간의 시간낭비가 있는데이 정보를 저장하면 프로그램을 비동기 인터럽트 방식으로 구현할수 있다.
* 인터럽트 안에는 호출하기전 반환 주소, 범용 래자수터값, 매개변수 등 함수 호출이 갖고있던 정보외에 여러 정보를 가지고 있어 CPU 는 입출력 장치의 인터럽터를 실행한후 원래 상태로 돌아갈수 있다.
* 프로그램 실행 상태르 저장하는 전용 스택을 만들수 있고 이 스택은 반드시 커널에 있어야 하며 일반적인 프로그램은 이스택을 볼수 없다.

### 디스크 입출력 과 CPU 

* 최신 컴퓨터 시스템은 디스크가 입출력을 처리할때 CPU 개입이 필요하지 않다.
* 디스크는 헤드(head), 실린더(cylinder), 트랙(track) 으로 구성되어 있다
* 헤드가 위치한 트랙에 데이터가 없을경우가 있는데 이때 헤드를 움직여 트랙을 찾아야 하는데 이것을 탐색(seek) 이라고 한다.
* 장치제어기(device controller)는 디스크의 회전속도와 헤드의 위치를 제어하고 데이터를 읽고 쓰는 전자적인 것들이 칭한다.
* 장치 드라이버(device driver)는 운영체제에 속한 코드이고 장치 제어기는 장치 드라이버의 명령을 받아 외부 장치를 제어하는 하드웨어에 해당한다.
* 장치제어기에서 명령을 받은후 실행한 데이터는 따로 CPU 에 직접 복사하지 않고 직접메모리접근(direct memory access)를 통해 메모리에 저장한다.
* CPU 는 반드시 어떻게 데이터를 복사할지 알려주는 명령어를 DMA 에 전달하고 DMA 는 작업 목표를 명확히 하고 버스중재(bus arbitration)을 요청한후 장치를 작동시킨다.
* DMA 는 읽은 데이터를 메모리에 저장하는데 운영체제가 DMA 에 필요한 가상 주소와 물리메모리 주소 사이의 매핑 정보를 제공하여 메모리에 저장한다.
* DMA 가 메모리에서 읽은 데이터는 반드시 최신 데이터가 아닌데 이는 캐시메모리에 저장된 데이터가 메모리에 저장된 데이터보다 최신이기 때문이다, 그래서 캐시데이터를 즉시 메모리에 갱신 하여 일관성 문제가 발생하지 않게 한다.
* DMA 전송이 완료되면 인터럽트 작동 방식을 사용하여 CPU 에게 전송이 완료되었음을 알린다.
* 동기 비동기 관점에서 볼때 사실상 비동기이기 때문에 디스크가 입출력 요청을 처리하는동안 CPU 는 다른 작업을 할수 있다.
* 소프트웨어 관점으로 볼때 디스크입출력은 하나의 단독 스레드로 보고 비동기 방식으로 실행된다.
* 이것을 무의존성 또는 분리(decoupling)이라고 하며 이는 프로그램의 성능을 향상시키는데 도움이 된다.

### 파일 입출력

* 메모리 관점에서 입출력은 단순히 복사일뿐이다
* 데이터가 외부 장치에서 메모리로 복사하면 입력 반대면 출력이다.
* 파일을 읽은때 데이터를 저장하는 버퍼를 정의 한후 read 계열 함수를 호출한다. 
* 입출력 작업이 시작되면 입출력 블로킹 대기열에 넣어두고 다시 실행될 준비는 완료 되었지만 바로 CPU 에 할당되지 못한 스레드는 준비완료 대기열에 들어간다
* 디스크가 DMA 를 통해 버퍼에 메모리를 복사하면 CPU 에 인터럽터 신호를 보내 중단되었던 함수로 점프하여 디스크 입출력 처리를 완료한다.
* 일반적으로 입출력 데이터는 먼저 운영체제 내부로 복사되며 이후 운영체제가 프로세스의 주소 공간을 복사한다.
* 운영체제를 우회하여 직접 데이터를 프로세스 주소 공간에 복사 할수 있는데 이를 무복사(Zero-copy)라고 한다.

### 동시성 비결: 입출력 다중화

* 입출력은 결국 파일을 추상화 한것이고 파일은 N 바이트의 수열이다.
* 파일은 입출력을 위한 추상화 인터페이스로서 파일 디스크립터(file descriptor)를 사용한다.
* 파일 디스크립터는 파일을 추상화한것으로 파일을 열고 닫고 읽고 쓰는것을 제어한다.
* 파일 디스크립터는 단순한 숫자로 파일을 열때 커널은 파일 디스크립터를 반환하고 파일 작업을 실행할때 해당 파일 디스크립터를 커널에 전달한다.
* 입출력 다중화(I/O multiplexing)은 관심 대상인 파일 서술자를 커널에 알려줘서 여러 파일을 동시에 처리하는것을 말한다.
* 리눅스 에서 입출력 다중화 기술은 select, poll, epoll 이 있다.
* select 는 파일서술자 묶음에 제한이 있어 1024 개의 파일을 처리할수 있고 대응하는 프로세스, 스레드는 감시 대상 파일의 대기열에 배치되어 블로킹된다.
* 사용 가능한 I/O 이벤트가 발생하면 해당 프로세스, 스레드가 깨어나고 파일 디스크립터의 상태를 알려면 처음부터 다시 읽어야 해서 효율이 떨어짐
* poll 은 select 와 비슷하지만 1024 개를 넘지 못한다.
* epoll 은 파일 디스크립터의 상태를 알려주는 이벤트 기반의 입출력 다중화 기술이다.
* 준비 완료된 파일 디스크립터 구조를 생성하고 감시되고 있는 파일 디스크립터의 상태에 이벤트가 발생하면 프로세스를 깨우고 준비 완료된 파일 디스크립터가 준비 목록에 추가된다.

### 메모리 읽기와 쓰기로 파일 처리

* 가상 메모리는 모든 프로세스가 각자 독점적으로 메모리를 소유하고 있다고 생각하는게 목적이다.
* 어떤 주소 공간을 읽을때 대응하는 파일이 아직 메모리에 적재되지 않으면 페이지 누락 인터럽트가 발생한다.
* 이후 CPU 가 운영체제의 인터럽트 처리함수를 실행하고 실제 디스크 입출력 요청이 시작되며 파일을 메모리로 읽고 가상메모리와 실제 메모리 사이 연결이 수립된다.
* mmap 는 가상 메모리와 실제 메모리 사이를 매핑해주는 시스템 콜이다.
* read/write 에 비해서 mmap 은 데이터를 직접 복사하는 부담이 없다
* mmap 는 페이지 누락 부담이 있고 특정 데이터 구조를 사용해야 해서 성능면에서 read/write 보다 낫다고 할수 없다.