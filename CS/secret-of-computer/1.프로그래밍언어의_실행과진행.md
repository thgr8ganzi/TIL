## 프로그래밍 언어의 실행과 진행

### 프로그래밍 언어의 발명

* 인류는 스위치로 불 논리를 표현하여 cpu 를 제어하는 방식을 발명했다.
* 0 과 1 로 이루어진 이진수를 사용하여 컴퓨터를 제어하는 방식이 코드, 소스 라고 한다
* 기계어와 해당 특정 작업을 간단하게 대응시켜 인간이 읽고 이해할수 있는것이 어셈블리어
* 인간의 단도직입적인 명령어를 문(Statement)이라고 한다.
* 문의 세부사항의 차이를 매개변수(Parameter)로 구분하고 계속 반복됨
* 기호의 정확한 순를 지정하는 규칙을 구문(Syntax)이라고 한다.
* 인간의 추상적인 표현을 컴퓨터가 이해할수 있게 만든게 AST(추상구문트리)이다.

### 컴파일러 작동

* 컴파일러는 고수준 언어를 저수준 언어로 변환하는 프로그램이다.
* 프로그래밍 언어의 구문 규칙에 따라 프로그래머가 인간이 인식할수 있는 단어로 코드를 작성하면 코드는 일반적인 텍스트 파일의 형태의 파일로 저장되는데 이를 소스 파일(Source File)이라고 한다.
* CPU 는 추상적인 표현을 직접 이해 할수 없는데 컴파일러는 항목들을 쪼개서 CPU 가 이해할수 있는 명령어로 변환한다.
* 키워드(Keyword)는 프로그래밍 언어에서 특별한 의미를 가지는 단어를 말한다.
* 토큰(Token)은 프로그래밍 언어에서 의미를 가지는 최소 단위를 말한다.
* 컴파일러는 소스 파일을 읽어들여 토큰으로 분리하고 이를 분석하여 문법적 오류가 없는지 검사한다.
* 소스코드에서 토큰을 추출하는 과정을 어휘 분석(Lexical Analysis)이라고 한다.
* 컴파일러는 어휘 분석을 통해 추출된 토큰을 분석하여 문법적 오류가 없는지 검사하는데 이를 의미분석(Semantic Analysis)이라고 한다.
* 의미 분석이 끝나면 컴파일러는 구문트리를 탐색한 결과를 좀더 다듬어진 형태인 중간 코드(Intermediate Code)로 변환한다.
* 이과정이 완료 되면 중간코드를 어셈블리어 코드로 변환
* 어셈블리어를 기계명령어로 번역 기계어로 된 대상 파일(Object File)을 생성한다.
* 여러가지 대상 파일이 있을떄 이를 하나로 합쳐 실행파일(Executable File)을 생성한다.
* 이 실행 파일을 생성하기 위해 병합 하는 과정을 링크(Link)라고 하고 링커(Linker)가 수행한다.

### 링커의 비밀

* 링커는 컴파일러와 마찬가지로 일반적인 프로그램에 불과
* 링커는 다른 모듈의 종속된 외부심벌(External Symbol)을 해결하는 역할을 한다.
* 외부심벌에 대한 실제 구현은 어느 모듈이든지 하나만 있어야 하는데 이를 연결하여 해결하는 작업을 심벌해석(Symbol Resolution)이라고 한다.
* 재배치(Relocation)는 링커가 모듈을 연결할때 주소를 재배치하는 작업을 말한다.
* 심벌은 전역변수와 함수의 이름을 포함하는 모든것을 의미한다.
* 링커는 소스파일에 다른 모듈에서 참조할수 있는 심벌이 있다는것,다른 모듈에서 정의한 심벌을 참조한다는 정보를 알고있어야 한다.
* 링커는 이러한 정보를 컴파일러가 알려주는데 명령어를 실행 시킬떄 필요한 데이터도 대상 파일에 저장한다.
* 대상파일은 명령어 부분과 데이터 부분 으로 나뉘는데 명령어 부분은 기계어로 번역된 명령어가 저장되고 데이터 부분은 프로그램이 실행될때 필요한 데이터가 저장된다.
* 컴파일러는 외부 심벌을 참조하는 코드를 생성할때 이 심벌이 어디에 정의되어 있는지 알수 없기 때문에 링커에게 이 정보를 알려줘야 한다.
* 컴파일러는 심벌테이블(Symbol Table)을 생성하여 링커에게 이 정보를 전달한다.

### 정적 라이브러리 vs 동적 라이브러리

* 정적 라이브러리는 실행파일에 라이브러리의 코드가 포함되어 있는 형태이다.
* 동적 라이브러리는 실행파일에 라이브러리의 코드가 포함되어 있지 않고 실행파일이 라이브러리를 참조하는 형태이다.
* 미리 컴파일 완료된 정적 라이브러리는 다시 컴파일할 필요 없이 링크 과정에서 그대로 실행 파일에 복제된다.
* 정적링크(Static Link)는 실행파일에 라이브러리의 코드가 포함되어 있는 형태이다.
* 실행파일은 대상파일의 집합인데 특수한 심벌인 _start 를 가지고 있다.
* 동적 라이브러리는 공유 라이브러리 또는 동적 링크 라이브러리라고도 한다.
* 동적 라이브러리를 사용하면 라이브러리의 이름, 심벌테이블, 재배치 정보등 필수정보만 실행파일에 포함하여 실행파일의 크기를 줄일수 있다.
* 동적 링크 관련 정보는 동적 링크가 일어날때 포함되며 실제 프로그램 실행 시점 직전 까지 라이브러리의 코드가 실행파일에 포함되지 않는다.
* 동적 링크는 메모리에 적재될때, 프로그램이 실행될때 두가지방식으로 일어난다.

### 재배치

* 심벌 실행시 주소를 결정하는 과정을 재배치(Relocation)이라고 한다.
* 컴파일러가 relocatable object file 을 생성할때 재배치 정보를 포함한다.
* .relo.text 섹션은 실행파일의 코드 부분에 대한 재배치 정보를 담고 있다.
* .relo.data 섹션은 실행파일의 데이터 부분에 대한 재배치 정보를 담고 있다.
* 링커는 심벌 해석을 완료해야 링크 과정에 오류가 없다고 확신, 동일한 유형끼리 병합

### 가상메모리

* 프로그램이 실행되면 해당 프로그램의 프로세스가 메모리에 적재된다.
* 가상메모리는 물리적으로 존재하지 않는 가짜 메모리이며 각각의 프로그램이 실행중일때 자기자신이 모든 메모리를 모두 독점적으로 상요하고 있는것처럼 착각하게 만든다.
* 가상메모리는 프로그램이 실행될때 필요한 메모리만큼만 할당받아 사용하고 프로그램이 종료되면 할당받은 메모리를 반환한다.
* 실행파일을 실행하려면 결국 물리메모리에 저장되어야 하는데 이때 가상메모리를 물리메모리에 매핑하는 과정을 가상메모리 매핑(Virtual Memory Mapping)이라고 한다.
* 메모리 페이지(Page)는 가상메모리와 물리메모리 사이의 최소 단위이며 모든 매핑을 유지하는것은 아니고 페이지 단위로 관리된다.
* 페이지 테이블(Page Table)은 가상메모리와 물리메모리 사이의 매핑 정보를 담고 있는 테이블이다.
* 모든 프로세스의 가상 메모리는 표준화 되어있고 크기가 동일하다.
* 각 프로세스마다 크기가 다를순 있지만 영역이 배치되는 순서는 동일
* 실제 물리 메모리의 크기는 가상 메모리의 크기와 무관하며 물리 메모리에는 힙영역, 스택영역등 존재하지 않는다.
* 모든 프로세스는 자신만의 페이지 테이블을 가지고 있으며 같은 메모리 주소라도 페이지 테이블을 확인하여 서로 다른 물리 메모리 주소를 획득한다.
