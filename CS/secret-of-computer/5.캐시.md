## 캐시

* 현대 컴퓨터는 폰노이만 구조로 CPU 와 메모리의 성능에 영향을 받는다.
* CPU 의성능을 메모리는 따라가지 못하기 때문에 캐시를 사용할수 있다.
* 캐시는 가격이 비싸고 용량이 제한적이지만 접근 속도가 빠르다.
* 캐시안에는 최근에 메모리에서 얻은 데이터가 저장되며 CPU 는 메모리에서 명령어와 데이터를 꺼내야 할때 먼저 캐시에서 찾는다.
* 캐시가 적중하면 메모리에 접근할 필요가 없어져서 시간을 절약할수 있다.
* x86 CPU 는 L1, L2, L3 캐시를 가지고 있다.
* L1, L2, L3, CPU 코어는 레지스터 칩 내에 패키징 되어있다.
* CPU 는 메모리에 접근할때 L1, L2, L3 순서로 캐시를 찾는다.
* 캐시의 데이터가 갱신될때 메모리의 데이터는 아직 예전적이 남아있는 불일치(inconsistent)상태가 발생한다.
* 연속기입(write-through) 방식으로 캐시 갱신시 메모리도 갱신할수 있고 동기식 설계 방법이다.
* 후기입(write-back)방식은 캐시에 제거된 데이터가 수정되면 메모리를 갱신하며 비동기식 설계 방법이다.
* 다중 코어에서는 캐시가 갱신더ㅣ면 다른 코어의 똑같은 캐시도 갱신해야 하고 고전적인 MESI 규칙(수정, 공유, 배타, 무효)을 따른다.
* 최신 운영체제에선 여유 메모리를 디스크의 캐시로 사용하여 디스크에서 데이터를 읽어오는 일을 최소화한다.
* 시스템이 충돌하거나 유실될수 있어 대부분의 입출력 라이브러리가 동기화(sync), 캐시비우기(flush)를 지원한다.
* 메모리는 데이터를 영구적으로 저장할수 없지만 메모리 용량이 증가함에 따라 디스크대신 메모리를 사용하기도 한다.
* 대용량 데이터를 저장하기위해선 분산파일시스템(distirbuted file system)을 사용하며 데이터를 여러 서버에 분산하여 저장한다.
* 아파치카프카에선 대용량 메시지는 원격 분산 파일 시스템에 저장되지만 실시간으로 해당 데이터의 소비자에게 전달되므로 메모리를 시스템 캐시로 간주할수 있다.

### 캐시 친화적

* 프로그램의 지역성 원칙(locality of reference)은 프로그램이 규칙적으로 메모리에 접근한다는 것
* 시간적 지역성(temporal locality)은 최근에 접근한 데이터를 다시 접근할 가능성이 높다는 원칙이다. 캐시 친화적이다.
* 공간적 지역성(spatial locality)은 최근에 접근한 데이터와 인접한 데이터를 다시 접근할 가능성이 높다는 원칙이다. 캐시 친화적이다.
* 메모리 풀은 메모리를 미리 할당해두고 필요할때 할당된 메모리를 사용하는 방식으로 커다란 메모리를 미리할당 받아 공간적 지역성이 우수해 캐시 적중률이 높아진다.
* 연결리스트 노드는 인접 메모리를 참조하므로 공간적 지역성이 우수해 캐시 적중률이 높아진다.
* 캐시 친화적인 프로그램은 캐시 적중률이 높아져 성능이 향상된다.
* 최적화시 분석도구를 사용하여 캐시 적중률이 시스템 성능의 병목(bottleneck)이 되는지 확인한다. 병목이 되지 않는다면 최적화를 하지 않는다.
* 다차원 배열은 행 우선 방식이 열 우선 방식보다 캐시 적중률이 높아진다.

### 다중스레드 성능 방해

* 