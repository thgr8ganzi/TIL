## 캐시

* 현대 컴퓨터는 폰노이만 구조로 CPU 와 메모리의 성능에 영향을 받는다.
* CPU 의성능을 메모리는 따라가지 못하기 때문에 캐시를 사용할수 있다.
* 캐시는 가격이 비싸고 용량이 제한적이지만 접근 속도가 빠르다.
* 캐시안에는 최근에 메모리에서 얻은 데이터가 저장되며 CPU 는 메모리에서 명령어와 데이터를 꺼내야 할때 먼저 캐시에서 찾는다.
* 캐시가 적중하면 메모리에 접근할 필요가 없어져서 시간을 절약할수 있다.
* x86 CPU 는 L1, L2, L3 캐시를 가지고 있다.
* L1, L2, L3, CPU 코어는 레지스터 칩 내에 패키징 되어있다.
* CPU 는 메모리에 접근할때 L1, L2, L3 순서로 캐시를 찾는다.
* 캐시의 데이터가 갱신될때 메모리의 데이터는 아직 예전적이 남아있는 불일치(inconsistent)상태가 발생한다.
* 연속기입(write-through) 방식으로 캐시 갱신시 메모리도 갱신할수 있고 동기식 설계 방법이다.
* 후기입(write-back)방식은 캐시에 제거된 데이터가 수정되면 메모리를 갱신하며 비동기식 설계 방법이다.
* 다중 코어에서는 캐시가 갱신더ㅣ면 다른 코어의 똑같은 캐시도 갱신해야 하고 고전적인 MESI 규칙(수정, 공유, 배타, 무효)을 따른다.
* 최신 운영체제에선 여유 메모리를 디스크의 캐시로 사용하여 디스크에서 데이터를 읽어오는 일을 최소화한다.
* 시스템이 충돌하거나 유실될수 있어 대부분의 입출력 라이브러리가 동기화(sync), 캐시비우기(flush)를 지원한다.
* 메모리는 데이터를 영구적으로 저장할수 없지만 메모리 용량이 증가함에 따라 디스크대신 메모리를 사용하기도 한다.
* 대용량 데이터를 저장하기위해선 분산파일시스템(distirbuted file system)을 사용하며 데이터를 여러 서버에 분산하여 저장한다.
* 아파치카프카에선 대용량 메시지는 원격 분산 파일 시스템에 저장되지만 실시간으로 해당 데이터의 소비자에게 전달되므로 메모리를 시스템 캐시로 간주할수 있다.

### 캐시 친화적

* 프로그램의 지역성 원칙(locality of reference)은 프로그램이 규칙적으로 메모리에 접근한다는 것
* 시간적 지역성(temporal locality)은 최근에 접근한 데이터를 다시 접근할 가능성이 높다는 원칙이다. 캐시 친화적이다.
* 공간적 지역성(spatial locality)은 최근에 접근한 데이터와 인접한 데이터를 다시 접근할 가능성이 높다는 원칙이다. 캐시 친화적이다.
* 메모리 풀은 메모리를 미리 할당해두고 필요할때 할당된 메모리를 사용하는 방식으로 커다란 메모리를 미리할당 받아 공간적 지역성이 우수해 캐시 적중률이 높아진다.
* 연결리스트 노드는 인접 메모리를 참조하므로 공간적 지역성이 우수해 캐시 적중률이 높아진다.
* 캐시 친화적인 프로그램은 캐시 적중률이 높아져 성능이 향상된다.
* 최적화시 분석도구를 사용하여 캐시 적중률이 시스템 성능의 병목(bottleneck)이 되는지 확인한다. 병목이 되지 않는다면 최적화를 하지 않는다.
* 다차원 배열은 행 우선 방식이 열 우선 방식보다 캐시 적중률이 높아진다.

### 다중스레드 성능 방해

* 캐시라인(cache line)은 묶음으로 데이터를 캐시에 저장하는것이며 일반적으로 64바이트이다.
* 다중 스레드 프로그램이 성능이 좋지 않은 이유는 캐시 튕김(cache line bouncing), 캐시 핑퐁(cache ping-pong)이 발생하기 때문이다.
* 거짓 공유(false sharing)은 두 스레드가 같은 캐시를 사용하지 않지만 같은 캐시 라인을 사용하면서 성능이 저하된다.
* 두 번수의 크기가 캐시라인보다 크면 두변수는 동일한 캐시라인을 공유하지 않는다.
* CPU 는 반드시 엄격하게 프로그래머가 코드를 작성한 순서대로 기계명령어를 실행하지 않는다.
* 명령어는 컴파일중 재정렬, 실행중 명령어가 비순차적으로 이렇게 두가지로 실행된다.
* 명령어는 엄격한 순서대로 진행되지 않는데 이것을 비순차적 명령어처리(out-of-order execution)이라 한다.
* CPU 와 메모리 사이 속도 차이가 나기때문에 CPU 가 기계 명령어를 엄격한 순서대로 실행하면 명령어가 의존하는 피연산자를 기다리는 동안 파이프라인 내부에 빈 공간(slot)이 생겨 성능이 저하된다.
* 캐시를 갱신하고 일관성 유지를 위해 저장버퍼(store buffer)를 사용한다.
* CPU 가 실행하는 명령어와 비교할때 기록 작업 은 비동기로 이루어지며 실제로 캐시와 메모리를 갱신할때 까지 기다리지 않고 다음 명령어를 실행할수 있다.
* 해당 스레드 내부에서는 비순차적 실행을 볼수 없는데 이것은 CPU 설계가 이를 보장한다.