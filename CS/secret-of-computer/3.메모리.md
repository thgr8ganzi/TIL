
## 메모리

* CPU 는 메모리 도움없이 동작이 불가능 하고 메모리는 0과 1을 저장하는 단순한 사물함에 불과하다
* 메모리는 셀단위로 구성되어 있다
* 메모리에 저장되는 0과 1을 가르켜 비트라고 한다.
* 1비트는 0아니면 1이다.
* 비트 8개를 묶어서 바이트라고 한다.
* 모든 바이트는 메모리내 자신의 메모리주소(memory address)를 가지고 있고 주소 지정(addressing)이라고 한다.
* 8비트로 만들수 있는 조합은 2^8 인 256 개이므로 0~255까지의 숫자를 표현할 수 있다.
* 일반적으로 4바이트씩 묶어 32바툻 2^32개의 int 값을 표현할 수 있다.
* 정수 외 구조체(structure)나 객체(object)등을 표현하기 위해 더 큰 메모리를 사용한다.
* 변수라는 주소에 값을 담을 수 있다.
* 이것은 변수가 얼마나 많은 메모리 공간을 차지하는지 관계없이 메모리 주소만 알고있으면 해당 데이터를 찾을수 있다.
* 변수는 값 뿐만 아니라 메모리 주소도 저장할수 있는데 이것이 포인터(pointer)이다.
* 포인터는 메모리 주소를 더 높은 수준으로 추상화 한것
* 포인터는 메모리 주소 값을 불러와 해석한후 메모리 주소의 진짜 데이터를 넣는데 이르 간접주소지정(indirect addressing)이라고 한다.
* 어셈블리어를 사용하면 반드시 간접주소 지정계층을 알고 있어야 한다.
* 고급 언어를 사용할시 변수가 주소값을 가지고 있기 때문에 간접주소 지정을 사용할 필요가 없다.
* 포인터 개념이 있는 언어는 하드웨어를 직접 조작할수 있다.
* 반면 포인터 연산에 오류가 있을경우 프로그램 실행 상태를 파괴할수 있다.
* 참조(reference)는 포인터를 사용하지 않고도 메모리 주소를 사용할수 있는 방법이다.
* 참조는 포인터와 유사한 구조의 산술 연산을 할수 없지만 포인터를 사용할때와 동일한 효과를 얻을수 있고 데이터를 복사할 필요가 없다
* 포인터는 메모리 주소를 추상화 한것이고 참조는 포인터를 한번더 추상화 한것이다.
* 이런 메모리를 추상화 한것이 가상메모리이다.

### 프로세스 메모리 구조

* 메모리 주소는 실제 물리 메모리주소가 아닌 가상 메모리 주소이다.
* 프로세스는 동일한 크기의 조각(chunk)으로 나누어져 있다.
* 모든 조각은 물리메모리 전체에 무작위로 흩어져 있다
* 운영체제는 페이지 테이블(page table)을 사용하여 가상 메모리와 물리메모리를 매핑(mapping)한다.
* 각 프로세스에는 단 하나의 페이지 테이블이 존재한다.
* 모든 가상 주소를 물리주소에 매핑하는 대신 프로세스의 주소 공간을 동일한 크기의 조각으로 나누는데 이를 페이지(page)라고 한다.
* 같은 프로세스가 동일한 메모리 주소를 매핑할수도 있다.

### 스택

* 함수는 가장 기초적인 코드 재사용 방식이고 세부사항을 감추며 일종의 추상화 이다.
* 함수 호출시 함수는 스택에 쌓이고 스택은 후입선출(LIFO) 구조이다.
* 스택은 이진트리(binary tree)의 탐색(search)과 같은 형태이다.
* 스택에는 스택프레임(stack frame)이라는 함수 호출시 생성되는 데이터 덩어리가 쌓인다. 이를 호출 스택(call stack)이라고 한다.
* 스택 영역이 차지하는 매ㅔ모리는 함수 깊이에 따라 증가하고 함수 호출이 완료될수록 감소한다.
* 함수 가 끝나면 제어권이 넘어가는데 실제로 CPU 가 어떤 함수에 속하는 기계 명령어를 실행하는지를 의미한다.
* 제어권이 넘어갈땐 반환(return)이라는 어디서 왔는지 점프(jump)라는 어디로 가야하는지 정보가 필요하다.
* 스택프레임에는 call 이라는 명령어로 어떤 함수가 호출하면, 해당 함수가 끝나고 돌아갈 주소가 들어있다.
* 이런식으로 마지막 기계 명령어인 ret 까지 계속 실행된다.
* CPU 는 기계 명령어를 실행할때 점프와 반환이 가능하기 때문에 이를 이용하여 함수를 호출한다.
* 대부분의 경우 함수의 매개변수의 전달과 반환값을 가져오는 작업을 레지스터로 한다.
* 전달된 매개변수가 사용가능한 레지스터보다 많다면 스택프레임을 이용한다.
* 로컬 변수도 마찬가지로 레지스터에 저장할수 있지만 레지스터 수보다 많으면 스택프레임에 저장된다.
* 레지스터에 지역 변수를 저장하기전에 반드시 레지스터에 원래 저장되었던 초깃값을 꺼냇다 레지스터 사용후 다시 초깃값을 스택프레임에 저장한다.
* 스택에는 제한이 있으면 초과하면 스택 넘침(stack overflow)이 발생한다.
* 스택 영역이 계속 증가하면 유휴 영역(free segment)이 줄어들고 스택 영역이 다른 메모리 영역을 침범할수 있다.
* 유휴 영역은 프로그램이 동적 라이브러리를 의존하는 경우 적재된다.