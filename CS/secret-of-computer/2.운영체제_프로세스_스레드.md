
### 프로그램 실행 과정

* 모든 것은 CPU 에서 시작한다
* CPU 는 메모리에서 명령어를 가져오고 이를 실행한다
* CPU 는 프로세스나, 스레드 같은것들을 알지 못하고 오직 명령어만 알고 있다
* 카운터 프로그램(Counter Program) 을 통해 CPU 는 메모리에서 명령어를 가져올 기준을 알 수 있다
* 레지스터(Register) 는 CPU 내부에 있는 메모리로, CPU 가 사용하는 데이터를 저장한다
* PC 레지스터의 저장하는 주소는 기본적으로 1씩 자동증가하나 if else 문을 통해 조건에 따라 다르게 증가할 수 있다
* 소스코드에서 main 함수가 실행되면, 컴파일러는 main 함수의 시작 주소를 PC 레지스터에 저장한다

### CPU 에서 운영체제 까지

* CPU 는 한번에 한가지 작업만 수행할수 있으므로, 운영체제는 CPU 를 효율적으로 사용하기 위해 프로세스를 관리한다
* 여러가지 일을 동시에 실행되는것처럼 보이게 하려고 상황정보(Save Context) 를 저장하고 복구한다.
* 이는 구조체(Structure) 를 통해 구현되는데 이것을 모아놓은것 프로세스라고 한다.
* 이러한 여러가지 기능을 모아놓은 것들을 운영체제 라고한다.
* 운영체제는 프로세스를 관리하고, 메모리를 관리하고, 파일시스템을 관리하고, 네트워크를 관리하고, 디바이스를 관리한다
* 이를 뒤(background)에서 실행되는것을 데몬(Daemon) 이라고 한다
* 운영체제는 프로세스가 표준적인 메모리 크기를 독점적으로 사용하는것처럼 보이게 하는데 이를 프로세스 주소 공간(Process Address Space) 라고 한다
* 프로세스 주소 공간은 코드, 데이터, 힙, 스택으로 나뉜다
  * 코드 영역(Code Area) : 코드를 컴파일하여 생성된 기계 명령어 저장
  * 데이터 영역(Data Area) : 전역 변수, 정적 변수, 상수 저장
  * 힙(Heap) : malloc 함수가 요청을 반환한 메모리가 할당, 동적 할당을 위한 메모리 공간
  * 스택(Stack) : 함수 호출 시 생성되는 지역 변수, 매개변수, 리턴 값 저장
* 각각 프로세스를 생성하여 실행하는것을 다중 프로세스 프로그래밍(Multi-Process Programming) 이라고 한다
* 프로세스는 각각 독립적으로 실행되기 때문에, 프로세스간 통신(IPC, Inter-Process Communication) 이 필요하다

### 프로세스에서 스레드로

* 공유 프로세스 주소 공간에서 동일한 프로세스에 속한 명령어를 동시에 실행할수 있다.
* 하나의 프로세스 안에 여러 실행 흐름이 존재하는데 이를 스레드(Thread) 라고 한다
* 스레드는 프로세스 내부의 코드, 데이터, 힙 영역을 공유하는데 이러한 이유로 스레드를 경량 프로세스(Lightweight Process) 라고도 한다
* 다중코어거았오여헌 다중 스레드를 사용할수 있는것은 아니며 단일 코어인 경우에도 다중 스레드를 사용할수 있다
* 이는 스레드가 운영체제 계층에서 구현되며 코어 개수와 무관하기 때문이다.
* 다중 스레드 상황에서 공유리소스에 접근할떄 오류가 발생하는것은 CPU 가 명령을 실행할떄 스레드를 전혀 고려하지 않기 때문
* 따라서 상호배재(Mutual Exclusion), 동기화(Synchronization) 등의 기법을 사용하여 해결한다

### 다중스레드와 메모리 구조

* 함수가 실행될땐 매개변수(Arguments), 지역변수(Local Variables), 리턴값(Return Value) 가 필요하다.
* 함수의 정보는 스택프레임(Stack Frame) 에 저장되며, 스택은 후입선출 구조로 되어있다
* 실행 흐름을 여러개 가지는 프로세스는 각각의 스택영역이 별도로 필요하다.
* 스레드의 수명주기(Life Cycle) 로 볼때 긴작업(long task) 와 짧은 작업(short task) 로 나뉜다
* 스레드는 작업처리에 필요한 시간과 작업의 수 에 따라 어떠한 방식을 사용할지 정해야한다.
* 어떤 특정 작업을 처리하기 위해서는 전용 스레드를 생성하여 요청당 스레드(thread per-request) 를 사용할수 있다
* 짧은 작업은 스레드 풀(Thread Pool) 을 사용하여 스레드를 재사용할수 있다

### 스레드 풀

* 쓰레드풀에 적합한것은 자료구조(data structure) 중 대기역(queue) 이다
* 생산자(Producer) 와 소비자(Consumer) 패턴을 사용하여 스레드풀을 구현할수 있다
* 스레드 풀에 전달되는 작업은 처리할 데이터와 데이터를 처리하는 함수이다
* 스레드풀의 스레드는 작업대기역(job queue) 에 블로킹 상태로 대기했다가 작업이 들어오면 작업을 처리한다
* 생산자가 대기역에 데이터를 기록하면 스레드가 깨어나고 스레드 대기열에서 정의한 구조체를 가져온후 구조체의 handle 이 가리키는 처리함수(Handler) 를 실행한다
* 작업 대기열은 여러  스레드간 공유되는 리소스 이므로 동기화시 상호배재(Mutual Exclusion in synchronization) 를 해결해야 한다.
* 적절한 스레드 풀의 개수는 CPU 집약적 잡업(CPU intensive job) 과 I/O 집약적 작업(I/O intensive job) 에 따라 다르다
* CPU 집약적 작업은 CPU 코어의 수와 동일하게 스레드 풀의 개수를 설정하고 I/O 집약적 작업은 CPU 코어의 수의 2배로 설정하는것이 좋다.
* N 개의 코어를 가진 시스템에 적절한 스레드 개수는 N * (1 + Wait Time / Computing Time) 이다

### 스레드간 공유 되는 프로세스 리소스

* 상태변화 관점에서 보면 스레드는 사실 함수 실행이다.
* CPU 는 진입 함수에서 실행을 시작하여 하나의 실행 흐름을 생성하는데 이 실행흐름을 스레드라고 한다
* 이러한 함수 실행에는 함수의 인자, 지역변수, 리턴값, 레지스터 정보가 들어있고 스택프레임에 저장된다.
* 실행될 명령어 주소를 저장하는 PC 레지스터(PC Register), 스택상단(stack top)위치를 저장하는 SP 레지스터(SP Register) 등도 각각 스레드에 저장되며 스레드 상황 정보(Thread Context) 라고 한다
* 