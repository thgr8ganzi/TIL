
### 프로그램 실행 과정

* 모든 것은 CPU 에서 시작한다
* CPU 는 메모리에서 명령어를 가져오고 이를 실행한다
* CPU 는 프로세스나, 스레드 같은것들을 알지 못하고 오직 명령어만 알고 있다
* 카운터 프로그램(Counter Program) 을 통해 CPU 는 메모리에서 명령어를 가져올 기준을 알 수 있다
* 레지스터(Register) 는 CPU 내부에 있는 메모리로, CPU 가 사용하는 데이터를 저장한다
* PC 레지스터의 저장하는 주소는 기본적으로 1씩 자동증가하나 if else 문을 통해 조건에 따라 다르게 증가할 수 있다
* 소스코드에서 main 함수가 실행되면, 컴파일러는 main 함수의 시작 주소를 PC 레지스터에 저장한다

### CPU 에서 운영체제 까지

* CPU 는 한번에 한가지 작업만 수행할수 있으므로, 운영체제는 CPU 를 효율적으로 사용하기 위해 프로세스를 관리한다
* 여러가지 일을 동시에 실행되는것처럼 보이게 하려고 상황정보(Save Context) 를 저장하고 복구한다.
* 이는 구조체(Structure) 를 통해 구현되는데 이것을 모아놓은것 프로세스라고 한다.
* 이러한 여러가지 기능을 모아놓은 것들을 운영체제 라고한다.
* 운영체제는 프로세스를 관리하고, 메모리를 관리하고, 파일시스템을 관리하고, 네트워크를 관리하고, 디바이스를 관리한다
* 이를 뒤(background)에서 실행되는것을 데몬(Daemon) 이라고 한다
* 운영체제는 프로세스가 표준적인 메모리 크기를 독점적으로 사용하는것처럼 보이게 하는데 이를 프로세스 주소 공간(Process Address Space) 라고 한다
* 프로세스 주소 공간은 코드, 데이터, 힙, 스택으로 나뉜다
  * 코드 영역(Code Area) : 코드를 컴파일하여 생성된 기계 명령어 저장
  * 데이터 영역(Data Area) : 전역 변수, 정적 변수, 상수 저장
  * 힙(Heap) : malloc 함수가 요청을 반환한 메모리가 할당, 동적 할당을 위한 메모리 공간
  * 스택(Stack) : 함수 호출 시 생성되는 지역 변수, 매개변수, 리턴 값 저장
* 각각 프로세스를 생성하여 실행하는것을 다중 프로세스 프로그래밍(Multi-Process Programming) 이라고 한다
* 프로세스는 각각 독립적으로 실행되기 때문에, 프로세스간 통신(IPC, Inter-Process Communication) 이 필요하다

### 프로세스에서 스레드로

* 공유 프로세스 주소 공간에서 동일한 프로세스에 속한 명령어를 동시에 실행할수 있다.
* 하나의 프로세스 안에 여러 실행 흐름이 존재하는데 이를 스레드(Thread) 라고 한다
* 스레드는 프로세스 내부의 코드, 데이터, 힙 영역을 공유하는데 이러한 이유로 스레드를 경량 프로세스(Lightweight Process) 라고도 한다
* 다중코어거았오여헌 다중 스레드를 사용할수 있는것은 아니며 단일 코어인 경우에도 다중 스레드를 사용할수 있다
* 이는 스레드가 운영체제 계층에서 구현되며 코어 개수와 무관하기 때문이다.
* 다중 스레드 상황에서 공유리소스에 접근할떄 오류가 발생하는것은 CPU 가 명령을 실행할떄 스레드를 전혀 고려하지 않기 때문
* 따라서 상호배재(Mutual Exclusion), 동기화(Synchronization) 등의 기법을 사용하여 해결한다

### 다중스레드와 메모리 구조

* 함수가 실행될땐 매개변수(Arguments), 지역변수(Local Variables), 리턴값(Return Value) 가 필요하다.
* 함수의 정보는 스택프레임(Stack Frame) 에 저장되며, 스택은 후입선출 구조로 되어있다
* 실행 흐름을 여러개 가지는 프로세스는 각각의 스택영역이 별도로 필요하다.
* 스레드의 수명주기(Life Cycle) 로 볼때 긴작업(long task) 와 짧은 작업(short task) 로 나뉜다
* 스레드는 작업처리에 필요한 시간과 작업의 수 에 따라 어떠한 방식을 사용할지 정해야한다.
* 어떤 특정 작업을 처리하기 위해서는 전용 스레드를 생성하여 요청당 스레드(thread per-request) 를 사용할수 있다
* 짧은 작업은 스레드 풀(Thread Pool) 을 사용하여 스레드를 재사용할수 있다

### 스레드 풀

* 쓰레드풀에 적합한것은 자료구조(data structure) 중 대기역(queue) 이다
* 생산자(Producer) 와 소비자(Consumer) 패턴을 사용하여 스레드풀을 구현할수 있다
* 스레드 풀에 전달되는 작업은 처리할 데이터와 데이터를 처리하는 함수이다
* 스레드풀의 스레드는 작업대기역(job queue) 에 블로킹 상태로 대기했다가 작업이 들어오면 작업을 처리한다
* 생산자가 대기역에 데이터를 기록하면 스레드가 깨어나고 스레드 대기열에서 정의한 구조체를 가져온후 구조체의 handle 이 가리키는 처리함수(Handler) 를 실행한다
* 작업 대기열은 여러  스레드간 공유되는 리소스 이므로 동기화시 상호배재(Mutual Exclusion in synchronization) 를 해결해야 한다.
* 적절한 스레드 풀의 개수는 CPU 집약적 잡업(CPU intensive job) 과 I/O 집약적 작업(I/O intensive job) 에 따라 다르다
* CPU 집약적 작업은 CPU 코어의 수와 동일하게 스레드 풀의 개수를 설정하고 I/O 집약적 작업은 CPU 코어의 수의 2배로 설정하는것이 좋다.
* N 개의 코어를 가진 시스템에 적절한 스레드 개수는 N * (1 + Wait Time / Computing Time) 이다

### 스레드간 공유 되는 프로세스 리소스

* 상태변화 관점에서 보면 스레드는 사실 함수 실행이다.
* CPU 는 진입 함수에서 실행을 시작하여 하나의 실행 흐름을 생성하는데 이 실행흐름을 스레드라고 한다
* 이러한 함수 실행에는 함수의 인자, 지역변수, 리턴값, 레지스터 정보가 들어있고 스택프레임에 저장된다.
* 실행될 명령어 주소를 저장하는 PC 레지스터(PC Register), 스택상단(stack top)위치를 저장하는 SP 레지스터(SP Register) 등도 각각 스레드에 저장되며 스레드 상황 정보(Thread Context) 라고 한다
* 코드 영역은 읽기 전용(Read-Only) 이므로 스레드간 공유가 가능하고 특정 스레드만 실행되도록 하는것은 불가능하다
* 코드 영역은  프로세스내 모든 스레드가 공유하지만 읽기전용 이기 때문에 프로그램중 어떤스레드도 내용을 변경할수 없어서 스레드 안전 문제(Thread Safety issue)가 발상해지 않는다.
* 데이터 영역은 전역변수가 저장되며 프로그램 실행중 데이터 영역내 전역변수 인스턴스(Instance) 는 프로세스내 모든 스레드가 공유하여 값을 변경하면 다른 스레드는 변경된 값에 접근한다.
* 힙영역은 malloc 함수와 new 키워드로 생성된 메모리가 저장되며 포인터(pointer)를 얻을수 있다면 모든 스레드는 접근 가능하다.
* 스레드가 다른 스레드의 스택프레임에서 포인터를 가져올수 있다면 해당 스레드는 다른 스레드의 스택 영역을 직접 읽고 쓸수 있다.
* 모든 스레드가 스택영역을 공유하면 치명적인 버그(bug)가 발생할수 있으며 디버깅도구(Debugging Tool)이 도움이 되지 않을수도 있다.
* 스레드간 느슨한 격리방식은 프로그래머 입장에서 편리할수도 있지만 치명적 문제를 일으킬수 있다.
* 동적링크 라이브러리 파일은 프로램이 시작될때 종속된 라이브러리의 코드와 데이터를 찾아서 프로세스 주소 공간에 넣는 링크 과정이 완료 된다.
* 프로그램이 동작중 특정 파일을 열면 프로세스 주소 공간에 열린 파일 정보는 힙영역과 스레드 영역 어딘가에 저장되어 스레드간 공유한다.
* 스레드 전용 저장소(Thread Local Storage) 는 스레드별로 고유한 저장소를 가지며 이를 통해 스레드간 공유되는 데이터를 제한할수 있다.

### 스레드간 안전코드

* 스레드간 공유되는 데이터를 안전하게 사용하기 위해 스레드는 반드시 순서를 따라야 하며 각종 잠금(lock) 이나 세마포어(Semaphore) 를 사용하여 동기화를 해야한다.
* 함수 매개변수를 값으로 전달(call by value) 하면 스레드간 공유되는 데이터를 안전하게 사용할수 있다.
* 전역변수도 상수(const) 로 읽기전용으로 안전하게 관리할수 있지만 변경하려면 반드시 원자성(Atomicity) 을 보장해야한다.
* 함수 반환경우 값반환(return by value) 와 포인터반환(return by reference)가 있는데 포인터 반환은 정적 지역 변수(static local variable)이기 때문에 스레드 공유 리소스 이다.
* 이경우 싱글톤 패턴(Singleton Pattern) 을 사용하여 전역변수를 사용하면 안전하게 사용할수 있다.

### 코루틴

* 코루틴(Coroutine) 은 함수의 실행을 일시정지하고 다른 함수를 실행한후 다시 돌아와 이전 상태를 유지하는 기법이다.
* 일반함수는 반환돈휘 프로세스 주소 공간의 스택 영역에 더이상 어떤 함수 실행시 정보도 저장하지 않는다
* 코루틴이 반환될때는 함수의 실행시 정보를 저장할 필요가 있는데 코루틴이 실행이 멈추었던 지점에서 다시 실행할때 이정보가 필요하기 때문이다.
* 코루틴이 일반함수와 다른점은 자신이 이전에 마지막으로 실행된위치를 알수있다는 것이다.
* 운영체제가 스레드를 스케줄링할때 실행상태를 저장했다가 다른 스레드를 스케줄링하고 일시중지된 스레드가 다시 CPU 의 실행상태로 복구되는것과 비슷하다.
* 컴퓨터 시스템은 주기적으로 타이머 인터럽트를 생성하고 인터럽트가 처리될때 운영체제는 현재 스레드의 일시중지 여부를 결정할 기회를 가진다.
* 사용자 상태에서는 타이머 인터럽트를 위한 작동방식이 없어서 코루틴에서 반드시 yield 같은 예약어를 사용하여 어디에서 일시정지하고 CPU 의 리소스를 내어줄것인지 명시적으로 지정해야 한다.
* 코루틴이 몇개인지 운영체제는 알지 못한다. 코루틴은 프로그래머가 직접 관리해야한다.
* 코루틴은 1958년 Melvin Conway 가 제안한것으로, 시뮬라67(Simula67), 스키마(Scheme) 등에서 사용되었고 1993년 주목받았다, 이전에는 스레드가 없어서 코루틴을 사용할수 밖에 없었다.
* 코루틴의 실행시간 스택프레임 정보는 힙영역에 저장된다.
* 이론적으로 메모리공간이 충분하다면 코루틴 개수의 제한은 없고 코루틴간 전환은 사용자 상태에서 일어나기 때문에 운영체제가 개입할 필요가 없다.
* 코루틴간 전환할때 저장 또는 복구 정보도 가볍기 때문에 효율성도 좋다.
* 코루틴으로 프로그래머가 동기방식으로 비동기 프로그래밍을 가능하게 한다.

### 콜백함수

* 함수를 변수처럼 사용할수 있다.
* 이러한 함수를 콜백 함수라고 한다.
* 함수를 스레드에 넘겨서 비동기 처리 할수있는데 호출 스레드가 콜백 함수 실행에 의존하지 않는것을 비동기 콜백 이라고 한다.
* 함수를 호출하고 결과를획득하여 결과를 처리하는것은 함수의 동기 호출 이라고 한다.
* 동기 호출은 함수를 호출한 스레드에서 전체 작업이 처리되는데 비동기 호출은 다른 프로세스, 스레드에서 처리된다.
* 서드파티 라이브러리(Third Party Library) 를 사용할때 콜백함수를 사용하면 라이브러리가 사용자의 코드를 호출할수 있다.
* 동기 콜백은 블로킹 콜백(Blocking Callback) 이 있다.
* 블로킹 콜백은 콜백함수가 호출되면 호출 스레드가 콜백함수의 실행이 끝날때까지 대기하는것을 말한다.
* 비동기 콜백은 콜백 함수를 매개변수 형태로 전달하면 호출 스레드는 콜백함수의 실행이 끝날때까지 대기하지 않는다.
* 이를 지연콜백(deferred callback) 이라고 한다.
* 비동기 콜백은 동기 콜백에 비해 다중 코어 리소스를 더 잘 활용한다.