## 컴퓨터 밑바닥은 어떻게 움직일까

* 트랜지스터(transistor)는 전류를 제어하는 장치로 한쪽에 전류를 흘리면 나머지 단자 두개에 전류가 흐르게 할수도 않을수 있다
* 스위치와 동일하다
* 스위치 두개가 동시에 켜질때만 전류가 흐르는 것은 논리곱게이트(logical conjunction gate) AND 이다
* 두개중 하나라도 켜져있으면 전류가 흐르고 등이 켜지는게 논리합게이트(logical disjunction gate) OR 이다
* 스위치를 닫으면 전류가 흘러서 등이 켜지고 열면 전류가 흐르지 않고 등이 꺼지는것을 논리부정게이트(logical negation gate) NOT 이다
* 이런 논리 게이트는 모든 논리함수를 표현할수 있고 이것을논리적 완전성(logical completeness)이라고 한다
* 이진법의 덧셈은 두개가 1(참)일때 참이 되므로 논리곱 게이트 이다.
* 두 입력값이 같으면 결과가 0이고 이것은 배타적 논리합(exclusive OR) 게이트이다.
* 논리 게이트를 조합하면 덧셈, 뺄셈, 곱셈, 나눗셈 등 모든 수학적 연산을 할수 있다.
* 논리 게이트를 조합하여 가산기(adder)를 만들수 있고 가산기를 조합하여 CPU 를 만들수 있다.
* CPU 의 전문적 계산을 담당하는 모듈은 ALU 라는 산술 논리 장치(arithmetic logic unit) 이며, 간단한 회로와 큰차이는 없지만 복잡하다.
* 부정 논리곱 게이트(non-conjunction gate) NAND 는 1 과 0을 계산하여 논리곱 하여 0 이되고 이것을 다시 논리 부정 연산한것이다.
* WE(Write Enable) 신호가 1 이면 데이터를 쓰고 0 이면 데이터를 쓰지 않는다.
* 이러한 회로들의 모음을 레지스터(register) 라고 하며 정보를 저장하고 주소지정 기능을 제공한다.
* 레지스터는 전원이 연결되면 정보를 저장하지만 끊기면 정보는 사라진다.
* 모든 연산 논리를 반드시 회로같은 하드웨어로 구현할 필요는 없다
* 하드웨어는 변하지 않지만 소프트웨어는 변할수 있기에 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공하면 하드웨어가 완전히 새로운 기능을 구현한다.

### CPU 에게 명령

* 명령어 집합(instruction set)은 CPU 가 이해하는 명령어(opcode)와 피연산자(operand)의 집합이다.
* 서로다른 CPU 는 서로 다른 명령어 집합을 가지고 있다
* 명령어 집합은 소프트웨어와 하드웨어가 만나는 장소이자 통신하는 인터페이스이다.
* 클럭신호(clock signal)는 CPU 에서 지휘자 역활을 하고 각 부분의 회로가 함꼐 작업할수 있도록 조정하고 동기화 한다.
* 클럭의 신호가 전압을 변경할때 마다 전체 회로의 각 레지스터 가 갱신되고 다음 명령어를 실행한다.
* 클럭주파수(clock rate)는 초당 클럭의 횟수이며 클럭의 속도를 나타낸다.

### 유휴 상태

* 프로세스는 기본적으로 아무런 작업도 하고 있지 않으며 특정이벤트가 발생하여 자신을 깨우기를 기다리고 있다.
* 프로그램이 메모리에 실행되면 프로세스 형태로 존재하고 프로세스가 생성되고 운영체제가 관리하여 스케줄링한다.
* 프로세스는 운영체제의 대기열로 관리되고 우선순위에 따라 스케줄러(scheduler) 가 CPU 를 할당하여 대기열에 프로세스를 넣는다.
* 프로세스 스케줄링은 운영체제가 구현해야 하는 핵심 기능중 하나이다
* 준비완료 대기열이 비어있다면 운영체제가 스케줄링해야하는 프로세스가 없고 CPU 가 유휴상태에 있다는것이다.
* 유휴 프로세스는 항상 준비 완료 상태에 있으며 우선순위는 가장 낮다.
* 유휴 상태 명령어는 halt 이며 절전 상태로 유지한다.
* halt 는 특권 명령어로 커널상태에서 CPU 로만 실행된다.
* 운영체제는 일정시간마다 타이머 인터럽트(timer interrupt) 를 생성하고 CPU 는 인터럽트 신호를 감지하고 운영체제 내부의 인터럽트 처리 프로그램을 실행한다.
* 인터럽트 처리함수는 프로세스 실행 준비상태를 판단하고 준비완료 상태 프로세스를 스케줄링한다.

### CPU 의 숫자인식

* 아라비아 숫자 체계는 값과 숫자의 위치가 직접적인 관계가 있는데 이를 위치 기수법(positional notation) 이라고 한다.
* 컴퓨터 시스템의 2진법도 위치 기수법을 사용한다.
* 비트 k 개를 사용하면 정수 2^k 개를 표현할수 있다.이를 부호없는정수(unsigned integer) 라고 한다.
* 음수를 표현할땐 최상위 비트(most significant bit) 를 부호비트(sign bit) 로 사용하고 이를 부호 - 크기 표현(sign-magnitude) 이라고 한다.
* 1의 보수(one's complement) 는 부호비트를 제외한 나머지 비트를 반전시킨다.
* 2의 보수(two's complement) 는 1의 보수에 1을 더한것이고 현대 컴퓨터 시스템에서 사용된다.

### CPU 의 분기처리

* CPU 는 하나의 기계 명령어를 처리하는 과정에서 명령어 명령어 인출(fetch) - 명령어 해독(decode) - 실행(execute) - 다시쓰기(writeBack) 의 과정을 거친다.
* 분기 점프 명령어가 실행을 완료하기 전에 다음 명령어는 이미 파이프 라인에 들어가 있어야 하는데 그렇지 않으면 파이프 라인에 빈 공간이 생겨 프로세서의 리소스를 완전하게 사용할수 없다.
* CPU 는 어디로 분기할 가능성이 있는지 추측하고 추측이 맞으면 파이프라인(pipe line) 을 유지하고 틀리면 파이프라인을 비워야 하므로 성능 손식이 발생한다.
* CPU 코어수와 스레드 수의 어떤 관계도 없고 단일코어에서도 충분히 많은 스레드를 생성할수 있다.
* CPU 는 근본적으로 자신이 실행하는 명령어가 어떤 스레드에 속하는지 이해하지 못하며 이해할 필요가 없고 이것은 운영체제의 몫이다.
* 단일 코어에서도 다중스레드는 의미가 있는데 하나의 작업을 여러개로 분할한후 각각의 하위 작업을 별도의 스레드에 배치하면 운영체제에서 스케줄링하고 실행할수 있으므로 동시에 여러 작업을 실행할수 있다.

### CPU 진화

* CPU 관점에서 프로그램은 메모리에 적재되고 명령어를 읽어실행한다는것에서 모든것은 평등하다.
* 프로그래머는 명령어 집합으로 프로그램을 작성하고 CPU 는 명령어 집합을 실행한다.
* 현대컴퓨터는 기본적으로 폰노이만 구조를 따른다.
* 폰노이만구조(von Neumann architecture)는 실행파일은 기계명령어와 데이터를 모두 포함하고 프로그래머가 작성한 코드는 디스크 공간에 저장되며 실행시 메모리에 적재 된다.