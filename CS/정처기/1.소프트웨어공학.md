
# 소프트웨어 공학

--------------

## 소프트웨어 공학

### 공학이란

* 소프트웨어 위기를 극복하고 품질 높은 소프트웨어를 효율적으로 개발하기 위한 학문
* 소프트웨어 개발에 적용되는 방법, 도구, 이론을 포괄적으로 다룸

### 소프트웨어 공학의 3R

* 역공학
  * 이미 개발된 시스템을 분석하여 요구 분석서 설계서 등의 문서를 추출하는 작업
* 재공학
  * 유지보수의 생산성을 통해 소프트웨어의 위기를 해결하기 위한 방법
  * 분석 - 재구성 - 역공학 - 이관
* 재사용
  * 이미 개발된 소프트웨어의 전체 또는 일부를 다시 사용하는것
  * 재사용범위
    * 함수 와 객체
    * 컴포넌트
    * 애플리케이션
  * 재사용방법
    * 합성중심
      * 전자 칩과 같은 소프트웨어 부품, 모듈을 만들어서 이를 조합하여 소프트웨어를 완성
    * 생성중심
      * 추상화된 형태의 명세를 구체화하여 프로그램을 만듬
  * 개발단계
    * 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
  * 계획
    * 시스템 특성을 이해하여 비용 및 기간 예측
  * 요구사항 분석
    * 고객과 함께 소프트웨어의 기능 제약조건 목표 정의
  * 설계
    * 시스템 구조 설계, 프로그램 설계, 사용자 인터페이스 설계
  * 구현
    * 프로그래밍  언어를 사용하여 실제 프로그램 작성, 코딩, 디버깅, 단위테스트
  * 테스트
    * 구현된 소프트웨어가 요구사항을 만족하는지 검사
  * 유지보수
    * 사용중 발견된 문제 수정, 새로운 기능 추가
    * 수정보수, 향상보수, 적응보수, 예방보수

-----------------------------

## 소프트웨어 개발 방법론

### 개발 방법론 개념

* 소프트웨어 개발을 위한 절차, 방법, 도구, 기법 등을 체계적으로 정리한 것

### 종류

* 구조적 방법론
  * 절차지향적인 소프트웨어 개발 방법론
  * 하향식
  * 데이터흐름도(DFD) : 시스템 내의 데이터 흐름을 그래픽으로 표현
  * 자료사전(DD) : 시스템에서 사용되는 데이터의 세부 사항을 문서화
  * 상태전이도(STD) : 시스템의 상태 변화를 시각적으로 표현
  * 소단위 명세서(MiniSpec) : 개별 모듈의 기능과 로직을 상세하기 기술
* 정보공학 방법론
  * 기업의 주요 부분을 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성있게 통합하여 적용
  * 데이터중심
* 객체지향 개발 방법론
  * 현실세계의 개체를 속성과 메서드로 표현
  * 상향식
  * 캡슐화 : 객체의 세부 구현을 숨기고 인터페이스만을 제공
  * 정보 은닉 : 객체 내부의 세부사항을 외부로부터 숨김
  * 상속 : 재사용과 확장성을 위해 상위 클래스의 속성과 메서드를 하위클래스가 상속
  * 다형성 : 하나의 인터페이스가 다양한 형태로 구현되는 것
    * 오버 로딩 : 같은 이름의 메서드를 여러개 정의
    * 오버 라이딩 : 상위 클래스의 메서드를 하위 클래스에서 재정의
  * 추상화 : 복잡한 현실 세계를 단순화 하여 모델링
* CBD(Component Based Development) 방법론
  * 재사용 가능한 컴포넌트의 개발 또는 상용 컴포넌트를 조합하여 애플리케이션 개발
  * 확장성 : 새로운 컴포넌트 추가 및 기존 컴포넌트 수정 용이
  * 생산성 및 품질 향상 : 이미 검증된 컴포넌트 사용으로 신뢰성 높음
  * 유지보수 비용 최소화 : 개별 컴포넌트 수정이 전체 시스템에 미치는 영향 최소화
* 애자일 방법론
  * 변화에 빠르고 유연하게 대응하는 개발 방식
  * 민첨성 효율성
  * XP(eXtreme Programming) : 의사소통, 피드백, 존중, 용기, 단순성, 반복적이고 점진적인 개발
  * 스크럼(Scrum) : 유연하고 생산적인 프로젝트 관리 방식
  * FDD(Feature Driven Development) : 기능 중심의 개발 방법론
  * Crystal : 프로젝트의 특성에 따라 다양한 방법론 제공

### 소프트웨어 개발 모델

* 폭포수 모델
  * 순차적 접근 : 개발 과정이 계획, 분석, 설계 구현, 테스트, 운영의 순서로 진행
  * 단계별 검증 : 각 단계는 이전 단계가 완료 된후에 시작, 다음단계로 넘어가기전 검증
  * 병행 및 반복 진행의 부재 : 한번 시작된 단계는 이전 단계로 돌아가거나 병행 진행이 허용되지 않는다
  * 경험 및 성공사례 : 소프트웨어 개발의 오래된 모델로 다양한 성공사례가 있다.
  * 요구사항 변경의 어려움 : 초기에 설정된 요구사항을 나중에 변경하기 어렵다
  * 단계별 명확성 : 각 단계는 명확한 결과물을 가지고 있어야 한다
  * 고객 피드백의 부족 : 개발 과정중 고객의 피드백을 적극적으로 받기 어렵다.
  * 유연성 부족 : 시장이나 기술의 변화에 빠르게 대응이 어렵다.
* 프로토 타이핑 모델
  * 고객이 요구하는 주요 기능을 프로토 타입으로 먼저 구현하는 모델
  * 장점
    * 사용자의 요구사항을 충실히 반영할수 있다.
    * 사용자가 비교적 빠른기간내에 결과물을 평가할수 있다
    * 오류를 초기에 발견하고 수정할수 있다.
    * 요구사항 변경이 용이
  * 단점
    * 최종적으로 더많은 시간과 비용이 소요될수 있다.
    * 사용자가 프로토 타입을 실제 제품으로 오해할수 있다.
    * 문서화 과정이 소홀해질수 있다.
    * 폐기되는 프로토 타입에 대한 비용이 발생할수 있다.
* 나선형 모델
  * 계획 -> 위험분석 -> 개발 -> 평가
  * 폭포수 모델과 프로토타이필 모델의 장점을 통합하고 위험 분석을 추가하여 점증적으로 개발을 진행하는 모델
  * 위험 관리
  * 장점
    * 위험분석 과정을 통해 높은 위험성을 가진 프로젝트도 수행 가능하다.
    * 고객의 요구사항을 더 상세하게 적용할수 있다.
  * 단점
    * 개발 과정이 길어지면서 시간과 비용이 증가할수 있다.
    * 반복단계가 길어지면 프로젝트 관리가 어려워질수 있다.
* RAD(Rapid Application Development)
  * 매우빠른 개발 주기를 통해 소프트웨어를 신속하게 제공
  * 고급 소프트웨어 개발 도구와 CASE 도구를 활용
  * 장점
    * 짧은 개발 주기를 통해 빠른 시장 출시가 가능하다
    * 사용자 피드백을 신속하게 반영하여 사용자 중심의 소프트웨어 개발을 지원
    * 변경사항에 대해 유연하게 대처함
  * 단점
    * 매우 큰 규모의 프로젝트에는 적합하지 않음
    * 높은 수준의 개발 도구와 전문 인력이 필요
* V모델
  * 개발 각 단계에서 검증과 테스트를 중점적으로 진행
  * 개발 단계마다 해당하는 테스트 단계가 있어 체계적인 품질 관리 가능
  * 단위테스트 - 통합테스트 - 시스템 테스트 - 인수테스트
  * 장점
    * 개발 각 단계에서 체계적으로 테스트 진행
    * 높은 신뢰성이 요구되는 시스템 개발에 적합
  * 단점
    * 요구사항 변경에 대응하기 어렵다.
    * 초기 요구사항 분성의 오류가 프로젝트 전체에 영향을 미칠수 있음
  * 요구분석 -> 아키텍처 설계 -> 모듈설계 -> 구현 -> 단위테스트 -> 통합테스트 -> 시스템테스트 -> 인수테스트
* 4세대 기법
  * 요구사항 명세서를 기반으로 소프트웨어 코드를 자동으로 생성
  * 4세대 언어와 같은 고급 프로그래밍 언어와 도구를 사용한다.

#### 애자일 방법론

* 개념
  * 신속하고 반복적인 작업을 통해 작동 가능한 소프트웨어를 개발
  * 작은 구성 요소를 빠르게 제공하고 애자일 개발을 가능하게 하는 다양한 방법론의 집합
  * 경량 프로세스
* 등장 배경
  * 기존 소프트웨어 개발 방법론이 가진 문제점들을 해결하기 위해 등장
  * 기존 소프트웨어 개발 방법론의 주요 문제점
    * 계약과 계획 준수에 중점을 둔 문화, 문서작성 과도하게 중시, 프로세스와 두구의 적용 중시, 계획 또는 통제 실패시 성과 나쁠때 부정적 인식
* 방법론 종류
  * XP
    * 특징
      * 문서보다는 코드를 중시하고 5가지 핵심가치와 12개 실천항목이 존재
        * 용기 : 고객의 요구사항 변화에 능동적인 대처
        * 존중 : 개발자의 역량을 존중하고 충분한 권한과 권리를 부여
        * 의사소통 : 개발자, 관리자, 고객 간의 원활한 의사소통
        * 피드백 : 의사소통에 따른 즉각적인 피드백
        * 단순성 : 부가적 기능, 사용되지 않는 구조와 알고리즘 배제
  * 스크럼
    * 특징
      * 소프트웨어에 포함될 기능, 개선점에 대한 우선순위를 부여
      * 개발 주기는 30정도로 조절하고 개발 주기마다 실제 동작할수 있는 결과를 제공
      * 개발 주기마다 적용할 기능이나 개선에 대한 목록을 작성
      * 매일 15분 정도의 회의
    * 주요 개념
      * 제픔 백로그
        * 개발할 제품에 대한 요구사항 목록
      * 스프린트
        * 1 ~ 4주의 짧은 기간의 반복적인 개발주기
      * 스프린트 계획 회의
        * 스프린트 목표와 스프린트 백로그를 계획하는 회의
      * 스프린트 백로그
        * 각각의 스프린트 목표에 도달하기 위해 필요한 작업 목록
      * 일일 스크럼 회의
        * 날마다 진행되는 15분 정도의 미팅
      * 실행 가능한 제품
        * 스프린트 결과로써 나오는 실행 가능한 제품
    * 크리스털
      * 프로젝트 규모와 영향의 크기에 따라서 여러종류 방법론 제공
    * FDD
      * Feature 마다 2주 정도의 반복 개발을 실시
    * ASD
      * 합동 애플리케이션 개발을 사용하는 방법론
    * 린(Lean)
      * 도요타 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거

### IT 서비스 관리

* SLM(Service Level Management)
  * 정의
    * 서비스 수준을 정량적으로 측정하고 실적을 평가하여 미흡한 부분을 개선하는 관리 활동
  * 목적
    * 서비스 품질의 지속적 개선을 통해 고객 만족도를 높임
    * SLA 에 명시된 기준을 기반으로 서비스 품질을 관리하고 개선
* SLA(Service Level Agreement)
  * 정의
    * 소프트웨어 수요자와 공급자간에 서비스 수준을 명시적으로 정의한 문서
  * 구성요소
    * 업무 목표/범위
    * 성과지표
    * 조정 절차
* ITSM(Information Technology Service Management)
  * 정의
    * 최종 사용자를 위한 IT 서비스를 구현, 전달, 관리하는 일련의 정책과 광핸
  * 특징
    * 최종 사용자의 요구와 비즈니스 목표에 부합하는 방식으로 IT 서비스 제공
* ITIL(Information Technology Infrastructure Library)
  * 정의
    * IT 서비스 관리를 위한 프레임워크
  * 특징
    * ITSM 을 실현하기 위한 도구나 방법을 제공
 
----------------------------------------------

## 프로젝트 계획

### 프로젝트 관리

* 개념
  * 특정한 목적을 달성하기 위해 한정된 기간, 예산, 자원 을 활용하여 사용자가 만족할만한 제품이나 서비스를 개발하도록 하는 기술적 관리적 활동
* 목적
  * 납기준수, 예산준수, 품질 준수를 통한 고객만족 달성
* 프로젝트 핵심 관리 대상(3p)
  * 사람
    * 프로젝트 팀원과 관련 이해 관계자들
    * 이들의 역량과 협력이 프로젝트 성공의 핵심
  * 문제
    * 프로젝트의 목표 달성을 위해 해결해야할 과제나 문제
    * 이러한 문제들을 효과적으로 분석하고 설계하는것이 중요
  * 프로세스
    * 프로젝트의 흐름을 조직하고 관리하는 방법론
* PMBOK(Project Management Body of Knowledge)
  * PMI(Project Management Institute)에서 발행하는 프로젝트 관리 지침서

### 개발 비용산정

* 소프트웨어 개발 비용 계획
  * 개발에 필요한 인원, 자원, 기간 등을 고려하여 소프트웨어의 규모를 파악하고 이를 바탕으로 필요한 비용 산정
* 비용 계획 결정 요소
  * 개발자 역량
  * 소프트웨어의 복잡도
  * 소프트웨어의 크기
  * 개발기간
  * 요구되는 신뢰도 수준
  * 기술 수준
* 비용산정 기법 *
  * 하향식 산정 기법
    * 전문가 판단 기법
    * 델파이 기법
  * 상향식 산정 기법
    * 원시 코드 라인수
    * 개발 단계별 노력 기법
  * 수학적 산정 기법
    * COCOMO 기법
    * PUTNAM 기법
    * FP(Function Point) 기법

#### 하향식 산정 기법

* 과거 유사 경험을 바탕으로 회의를 통해 전체 프로젝트의 비용을 산정하는 방식
* 전문가 판단 기법
  * 조직내 경험이 있는 전문가에게 비용 산정을 의뢰하는 방식
* 델파이 기법
  * 여러 전문가의 의견을 종합 하여 판단하는 방식
  * 특정 전문가의 주관적 편견을 보완하기 위해 여러명의 전문가로 구성

#### 상향식 산정 기법

* 프로젝트의 세부 작업 단위별로 비용을 산정후 이를 합산하여 전체 비용을 계산하는 방식
* 원시코드 라인수
  * 각기능의 원시 코드 라인수의 비관치, 낙관치, 중간치를 측정후 예측치를 구하고 이를 이용해 비용을 산정하는 기법
  * 추정 LOC : (낙관치 + (4 * 중간치) + 비관치) / 6
* 개발 단계별 노력
  * LOC 기법을 확장하여 소프트웨어 개발 생명 주기의 각 단계별로 적용되는 모든 단계의 비용을 산정

#### 수학적 산정 기법

* COCOMO 기법
  * 소프트웨어의 규모를 LOC 기반으로 예측하고 소프트웨어 종류에 따라 비용 산정 공식에 적용 비용을 산정 하는 모델
  * 조직형
    * 5만라인 이하
    * 일반 업무용 소프트웨어
  * 반분리형
    * 30만 라인 이하
    * 운영체제, DBMS 등
  * 내장형
    * 30만 라인 이상
    * 미사일 유도 시스템
* Putnam 기법
  * Putnam 이 제안한 생명주기 예측 모형
  * 시간에 따른 노력 분포를 Rayleigh-Norden 곡선으로 표현
  * 주로 대형 프로젝트에 이용
  * SLIM : Rayleigh-Norden 곡선과 Putnam 예측 모델을 기반으로 한 자동화 추정 도구
* FP
  * 소프트웨어 기능 개수를 기준으로 규모를 측정하는 기법
  * ESTIMACS : FP 기반의 자동화 추정 도구
  * 기능점수
    * 데이터 기능
      * 내부논리파일
      * 내부연계파일
    * 트랜잭션 기능
      * 외부입력
      * 외부출력
      * 외부조회
  * 산정요소
    * 자료입력 : 사용자 또는 시스템이 입력하는 데이터의 양식및 복잡도 평가
    * 정보 출력 : 시스템이 제공하는 출력 보고서의 양식 및 복잡도 평가
    * 명령어 : 사용자가 시스템에 요청하는 징의의 종류 및 복잡도를 평가
    * 데이터 파일 : 시스템이 관리하는 데이터 파일의 복잡도 및 관련성을 평가
    * 외부 인터페이스 : 시스템과 필요한 외부 루틴과의 인터페이스를 평가

### 개발 일정 산정

* 소프트웨어 개발을 위해 필요한 작업을 정의하고 이들 작업의 우선 순위를 설정하여 전체 프로젝트 일정 계획을 수립
* 작업순서
  * 작업분해(WBS) : 전체 작업을 작은 단위로 분해한다
  * CPM 네트워크 작성 : Critical Path Method 를 사용하여 작업 순서 및 의존성 정의
  * 최소 소요 기간 : 각 작업에 필요한 최소 시간을 계산한다.
  * 소요 Man-Month 및 기간 산정후 CPM 수정 : 작업에 필요한 인력 및 시간을 계산하여 CPM 을 업데이트 한다.
  * 간트 차트로 표현 : 프로젝트 일정을 시간적으로 표현

#### WBS(Work Breakdown Structure)

* 프로젝트 목표를 달성하기 위한 활동과 업무를 세분화하는 과정
* 작성방법
  * 전체 프로젝트를 큰단위로 분할
  * 각 부분을 더 작은 단위로 분해하여 계층적으로 표현
  * 각 단계별로 담당인원을 배치하고 구성도를 작성
* 역활
  * 업무식별, 계획및 비용산정, 진행 상황 파악, 이해당사자들간 의사소통 촉진

#### Network Chary(PERT/CPM)

* PERT
  * 개발 배경
    * 미국 해군이 Polaris 미사일 개발 프로젝트의 일정 계획 및 진행 과정을 효율적으로 관리하기 위해 개발
  * 목적
    * 전체 프로젝트의 시간 단축에 중점
    * 불확실한 상황에서의 시간 관리에 적합
  * 방법론
    * 개발 기간을 낙관치 기대치, 비관치, 예측치를 계산
    * (낙관치 + (4 * 예측치) + 비관치) / 6
* CPM
  * 개발 배경
    * 미국 Dupont 사에서 산업 설비의 유지보수를 위한 프로젝트의 일정 계획 및 진행 과정을 효율적으로 관리하기 위해 개발
  * 목적
    * 최소비용 추가 투입을 고려하여 전체 프로젝트의 시간단축을 목표로 한다.
  * 특징
    * CPM 은 더 확정적인 상황에서의 시간 관리에 적합
    * 비용과 시간 사이의 최적 균형을 찾는데 중점
  * 기능
    * 작업의 선/후행 관계를 고려하여 전체 작업의 완료 시간을 결정
    * PERT 는 불확실한 시간 추정에
    * CPM 은 비용과 시간의 최적화에 중점
  * 임계 경로
    * 프로젝트를 끝내기 위해 필요한 최소 소요 기간
    * 경로상 가장 오래걸리는 시간을 임계 경로로 정한다
  * 적용
    * 복잡한 대형 프로젝트를 효율적으로 계획하고 통제하기 위해 사용
* 간트 차트
  * 정의
    * 프로젝트 일정 계획의 시각적 표현
    * 일정관리의 최종 산출물로 사용되며 프로젝트의 시간 관리에 필수적인 도구
  * 형태와 기능
    * 이 차트는 바 형태로 표현되며 각 업무 또는 활동의 시작과 종료시점을 그래픽으로 나타낸다
    * 이를 통해 프로젝트의 전체 일정을 한눈에 파악할수 있다.
  * 업무표시
    * 간트차트는 각각의 업무나 활동을 개별적인 바로 표시하며, 이 바는 해당 업무의 시작과 종료 시점을 나타낸다.

--------------------------------

## 요구사항 분석

### 현행시스템 분석

* 현행 시스템 파악의 정의
  * 기존시스템의 기능, 성능, 그리고 문제점을 이해하고 평가하기 위한 과정
  * 이 과정을 통해 새로운 시스템에서 개선해야 할 부분, 유지해야 할 부분, 변경해야 할 부분을 파악
* 현행 시스템 분석 단계
  * 시스템 이해 : 현재 시스템의 목적, 기능 및 사용 방법을 파악, 문서 분석, 인터뷰, 시스템 사용 관찰 등
  * 시스템 평가 : 현재 시스템의 성능과 효율성을 평가, 사용자 피드백 수집, 시스템 로그 분석등
  * 문제점 식별 : 현재시스템에서 발생하는 문제점과 제약 사항 식별
  * 요구사항 식별 : 새로운시스템에서 해결 하거나 개선해야 할 요구사항을 식별
* 플랫폼 정의
  * 다양한 응용 프로그램, 서비스 또는 기능이 구축되거나 실행되는 기반 또는 환경
* 플랫폼의 기능
  * 연결 기능 : 연결을 가능하게 하는 장소를 제공하여 교류 촉진
  * 비용감소 : 플랫폼을 제공하여 각 그룹이 처리 할 발생하는 시간과 비용 절감
  * 브랜드 신뢰 기능 : 플랫폼 브랜드가 사용자에게 신뢰감을 부여하여 일정 수준의 질을 보장
  * 커뮤니티 형성 : 그룹간 상호 작용을 통한 커뮤니티 형성
* 플랫폼의 종류
  * 하드웨어 플랫폼
  * 소프트웨어 플랫폼
  * 서비스 플랫폼
* 플랫폼의 유형
  * 거래플랫폼
  * 생태계 플랫폼
  * 다면 플랫폼 
* CPND(Contents Platform Network Device)
  * 개념
    * 콘텐츠를 플랫폼에 맞게 가공하고 네트워크를 통해 사용자의 단말기로 서비스가 이루어짐을 표현하는 무선 인터넷 서비스의 가치사슬
  * 콘텐츠의 요소
    * Contents : 텍스트, 이미지, 오디오, 비디오 등
    * Platform : 웹사이트 애플리케이션 등
    * Network : 통신 시스템
    * Device : 스마트폰, 컴퓨터, 태블릿
* 현행시스템 분석
  * 운영 체제 분석
    * 사용중인 운영체제의 종류와 버전 그에따른 호환성, 성능, 보안등의 문제를 파악한다.
  * 네트워크 분석
    * 네트워크의 구조와 프로토콜, 대역폭, 지연시간, 보안, 장애복구등에 관한 문제를 파악한다.
  * DBMS 분석
    * 사용중인 DBMS 의 종류와 버전 데이터모델, 성능, 보안 백업및 복구등에 관한 문제를 파악한다.
  * 미들웨어 분석
    * 양쪽을 연결하여 데이터를 주고받을수 있도록 중간에서 매개 역활을 하는 소프트웨어
    * 네트워크를 통해서 연결된 여러대의 컴푸터에 있는 많은 프로세서들에게 어떤 서비스를 사용할수 있도록 연결해주는 소프트웨어
  * 미들웨어 종류
    * 원격 프로시저 호출(Remote Procedure Call)
      * 클라이언트가 원격에서 동작하는 프로시저를 호출하는 시스템
    * 메시지 지향 미들웨어(Message Oriented Middleware)
      * 클라이언트가 생성한 메시지는 저장소에 요청할때 저장하면서 다른 업무를 지속할수 있도록 하는 비동기식 미들웨어
    * ORB(Object Request Broker)
      * 객체지향 프로그래밍에서 객체간의 통신을 지원하는 미들웨어
    * DB 접속 미들웨어
      * 애플리케이션과 데이터베이스 서버를 연결해주는 미들웨어
    * TP 모니터(Transaction Processing Monitor)
      * 분산 시스템의 애플리케이션을 지원하는 미들웨어
      * 트랜잭션이 올바르게 처리되고 있는지 데이터베이스를 감시하고 제어
    * 웹 애플리케이션 서버(WAS)
      * 앱 애플맄이션을 지원하는 미들웨어
    * 엔터프라이즈 서비스 버스(Energy Service Bus)
      * 메시지 기반으로 느슨한 결합 형태의 표준 인터페이스 통신을 지원하는 미들웨어로 기업 안팎에 있는 모든 시스템 환경을 연동하는 미들웨어

### 요구 공학

* 요구공학 개념
  * 소프트웨어의 요구사항을 식별, 분석, 문서화 하고, 이를 관리하는 과정
* 요구공학 필요성
  * 품질개선
  * 리스크 감소
  * 비용절감
  * 효율적 프로젝트 관리
  * 사용자와 개발자 간의 소통 개선
* 요구사항 개발 프로세스
  * 도출 -> 분석 -> 명세 -> 확인
* 도출
  * 사용자와 이해관계자 들로부터 요구사항을 수집한다.
  * 인터뷰, 설문조사, 브레인스토밍, 워크샵, 직접 관찰 등 다양한 방법을 통해 수행된다.
* 분석
  * 수집된 요구사항중 불완전 하거나 모호하며, 중복된거나 충돌하는 부분을 식별하여 수정
  * 업무환경과 상화작용 파악(도메인 분석)
  * 분석 도구
    * DFD(Data Flow Diagram) : 자료흐름도
    * Data Dictionary : 자료사전
    * Mini-Spec : 요구사항 명세서
    * ERD(Entity Relationship Diagram) : 개체관계도
    * State Transition Diagram : 상태전이도
  * 객체지향 분석도구
    * UML(Unified Modeling Language)
    * 모델링
* 명세
  * 분석된 요구사항은 명세서 형태로 정리
  * 시스템이 수행해야 할 기능, 시스템이 충족해야 할 성능, 그리고 제약 조건등이 포함한다.
  * 요구사항 명세 기법
    * 정형 명세 기법
      * 수학, 논리학 기반
      * 수학적 기호, 정형화된 표기법으로 작성
      * 명세 오류및 모호성을 쉽게 파악
      * 작성이 어렵고, 시간이 많이 소요
      * VDM, Z, Petri-net, CSP
    * 비정형 명세 기법
      * 자연어, 그림중심 기반
      * 일반명사, 동사등의 자연어기반으로 서술하거나 다이어그램으로 작성
      * 사용자/개발자간 의사 전달 용이
      * 내용이 모호하고 완전한 검증이 곤란
      * FSM, Decision Table, ER 모델링, State Chart(SADT)
  * 요구사항 분류
    * 기능 요구사항
      * 시스템이 어떤 기능을 수행해야 하는지 또는 시스템이 제공해야 하는 서비스가 무엇인지를 정의
    * 비기능 요구사항
      * 시스템이 어떻게 동작해야 하는지에 대한 요구사항
      * 품질관련, 제약사항, 성능, 보안, 가용성, 유지보수성
* 확인 및 검증
  * 분석가가 요구사항을 이해했는지 확인, 문서가 일관성 있고 완전한지 검증
* 요구사항 분석 기법
  * 인터뷰
  * 브레인스토밍
  * 원인-효과 다이어그램
  * 프로토타이핑
  * 사용사례(User Case)
  * 요구사항 검토
* 요구사항 분석 CASE(Computer Aided Software Engineering)
  * 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하는 도구
  * 개발 전반에 걸쳐 적용
  * CASE 도구의 분류
    * 상위 CASE
      * 생명주기 전반부에 사용되면 소프트웨어 계획과 요구분석, 설계 단계를 지원
    * 하위 CASE
      * SDLC의 하위 단계인 프로그래밍, 테스트, 유지보수 단계를 지원
    * 통합 CASE
      * 소프트웨어 생명주기에 포함되는 전체 과정을 지원한다.
* 요구사항 분석 도구
  * HIPO(Hierarchy Input Process Output)
    * 개념
      * 하향식 소프트웨어 개발을 위한 문서화 도구
      * 시스템의 기능을 여러개의 고유 모듈들로 분할하여 이들간의 계층 구조를 표현한 도표
    * 기능
      * 분석및 설계 도구로 사용
      * 하향식 개발에 적합
      * 체계적인 문서 관리에 효율적
      * 기능과 자료의 의존관계를 명시할수 있다
    * 구성요소
      * 주요프로세스
      * 하위 프로세스
      * 입력 출력
    * HIPO Chart 종류
      * 가시적 도표
        * 시스템의 전체 기능과 흐름을 보여주는 Tree 구조
        * 가시적 도표에는 입력, 처리, 출력 없음
      * 총체적 도표
        * 프로그램을 구성하는 기능을 기술한것
        * 입력, 처리, 출력에 대한 전반적인 정보를 제공
      * 세부적 도표
        * 총체적 도표의 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표
        * 총체적 도표와 같은 모양이지만 내용만 좀 더 복잡하게 들어간 형태
* 모델링
  * 개녕
    * 복잡한 시스템을 이해하고 효과적으로 개발하기 위한 간단한 모델로 표현하는 과정
  * 도움
    * 소프트웨어의 구조와 동작을 이해하는데 도움
  * 구분
    * 기능적 모델링
      * 사용자 관점에서 시스템의 기능을 표현
      * 사용사례 다이어그램, 액티비티 다이어그램
    * 정적 모델링
      * 시스템의 구조를 클래스 단위로 표현
      * 클래스 다이어그램
    * 동적 다이어그램
      * 시스템의 상화 작용 및 동작을 표현
      * 순서 다이어그램, 상태 다이어그램 커뮤니케이션 다이어 그램
  * 종류
    * 구조적 분석 모델
      * 데이터 흐름도
        * 시스템 내에서 자료가 어떻게 이동하고 처리되는지를 도형으로 나타내는 모델링 도구
        * 처리과정 : 동그라미
        * 자료흐름 : 화살표
        * 자료 저장소 : 평행선
        * 단말 : 사각형
      * 자료 사전
        * 자료 흐름도에 기술한 모든 자료들에 대해 자세한 정의와 설명을 제시하는 중요한도구
        * = : 자료 정의
        * (+) : 자료 연결
        * () : 자료 생략
        * [] : 자료의 선택
        * {} : 자료의 반복
        * (**) : 자료의 설명
      * 소단위 명세서
        * 자료 흐름도에서 각 처리가 수행하는 업무를 상세하게 작성하는 문서
        * 프로세스 명세서 라고 한다.
      * 개채 관계도(Entity Relationship Diagram)
        * 시스템에서 처리되는 구조인 개체와 그 속성, 개체간의 관계를 도식화 하여 모델링하는 도구
        * 개체 : 업무의 중심이 되는 실체 : 네모
        * 속성 : 업무에 속하는 구체적 항목 : 동그리미
        * 관계 : 업무와 업무의 관계 : 마름모
      * 상태 전이도(State Transition Diagram)
        * 시스템의 상태와 상태간의 전이를 모델화하는 도구
    * 객체지향 분석 모델
      * 객체지향 분석 방법론
        * 럼바우(Rumbaugh) 방법론
          * 가장 일반적으로 사용되는 방법으로 분석 활동을 객체, 동적, 기능 모델로 나누어 수행
          * 객체모델링 : 객체 다이어그램을 통해 시스템의 객체 속성, 연산, 관계를 표현, 가장 선행되어야함
          * 동적모델링 : 상태 다이어그램을 사용하여 시간에 따른 객체의 행동과 상화 작용을 표현
          * 기능모델링 : DFD 를 이용해 데이터 흐름과 처리과정 표현
        * 부치(Booch) 방법
          * 미시적 거시적 개발 프로세스를 모두 사용
        * Jacobson 방법
          * Use Case 를 중심으로 시스템의 기능을 분석
        * Coad 와 Yourdon 방법
          * E-R 다이어그램을 사용하여 객체의 행위를 모델링
        * Wirfs-Brock 방법
          * 분석과 설계의 구분없이 연속적으로 작업 수행
    * 정보공학 분석 모델
    * 정형화 분석 모델

-------------------------------

## 소프트웨어 설계

### 소프트웨어 설계

* 소프트웨어 설계의 개념
  * 요구사항 명세서를 바탕으로 소프트웨어의 구체적인 설계서를 작성하는 단계
* 설계의 종류
  * 상위 설계
    * 아키텍처설계 - 데이터설계 - 인터페이스 정의 - 사용자 인터페이스 설계
    * 아키텍쳐 설계 : 시스템의 전체적인 구조를 설계
    * 데이터 설계 : 데이터베이스의 구조를 설계
    * 인터페이스 정의 : 시스템 구조와 서브시스템들 사이의 이터페이스를 명확하게 정의
    * 사용자 인터페이스설계 : 사용자의 편의를 고려하여 인터페이스를 설계
  * 하위 설계
    * 모듈설계 - 자료구조 설계 - 알고리즘 설계
    * 모듈설계 : 각 모듈의 내부를 알고리즘 형태로 표현
    * 자료구조 설계 : 데이터의 저장 구조와 변수등에 대한 상세한 정보를 설계
    * 알고리즘 설계 : 업무의 처리 절차와 알고리즘을 설계
* 소프트웨어 설계의 원리
  * 분할과 정복
    * 큰 소프트웨어를 여러개의 작은 서브 시스템으로 나누어 각각을 완성 하는 방법
  * 추상화
    * 실세계의 복잡한 상황을 간결하고 명확하게 핵심 위주로 단순화 한다.
    * 추상화 기법
      * 과정 추상화 : 상위 수준에서 수행 흐름만 설계
      * 데이터 추상화 : 데이터 구조를 간단한 표현으로 대체
      * 제어 추상화 : 명령들을 간단한 표현으로 대체
  * 단계적 분해
    * 기능을 점차적으로 작은 단위로 나누고 구체화 하는 방법
    * 설계를 단계별로 세분화하여 각 단계의 복잡성을 관리한다
  * 모듈화
    * 시스템을 개별적으로 개발 가능한 작은 모듈로 나눈다.
    * 각 모듈을 독립적으로 개발, 테스트 및 유지보수 할수 있게 한다.
  * 정보은닉
    * 객체가 자신의 정보를 숨기고 외부의 접근을 제한한다.
    * 캡슐화와 밀접하게 연관되어 있으며 데이터와 기능을 안전하게 보호한다.
  * 결합도와 응집도
    * 결합도는 낮추고 응집도는 높인다.

### 설계 모델링

* 설계 모델링의 개념
  * 소프트웨어의 구조와 기능을 그래픽적으로 표현
* 설계 모델링 원칙
  * 변경이 용이하도록 구조화
* 설계 모델링의 유형
  * 구조 모델링
    * 시스템의 구성 요소와 그 사이의 구조적 관계를 모델링한다.
    * UML 정적 다이어 그램
  * 행위 모델링
    * 소프트웨어 구성요소의 기능 수행순서와 방식을 모델링한다.
    * UML 동적 다이어그램
* 소프트웨어 설계 절차 및 유형
  * 아키텍쳐 설계 : 시스템의 전체 구조와 서브 시스템간의 관계를 설계한다.
  * 데이터베이스 설계 : 시스템에서 사용되는 데이터 구조를 설계
  * 서브시스템 설계 : 각 서브시스템의 기능과 제약 사항을 명세한다.
  * 컴포넌트 설계 : 기능을 수행하는 컴포넌트들을 설계하고 그들간의 인터페이스를 명세한다.
  * 자료구조와 알고리즘 설계 : 데이터 저장 방식과 기본 연산 방법을 설계 한다.
* 협약에 의한 설계
  * 클래스에 대한 선행조건, 결과조건, 불변조건을 명세한다.
  * 선행조건 : 컴포넌트 오퍼레이션 사용전에 참이 되어야 할 조건
  * 결과조건 : 사용후 만족되어야 할 결과조건
  * 불변조건 : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

----------------------------

## 소프트웨어 아키텍처

### 소프트웨어 아키텍처

* 소프트웨어 아키텍처의 개념
  * 정의 : 소프트웨어의 기본 구조로, 시스템의 컴포넌트와 이들간의 관계를 기술한다.
  * 목적 : 시스템의 골격을 제공하고, 고수준에서의 설계 지침을 제공한다.
* 소프트웨어 아키텍처의 특징
  * 간략성 : 이해하고 추론할수 있는 수준의 간결함을 유지
  * 추상화 : 시스템의 추상적인 표현을 사용
  * 가시성 : 시스템이 포함해야 하는 요소들을 명확히 표현
  * 관점모형 : 다양한 이해 당사자의 관심사에 따른 모형 제시
  * 의사소통 수단 : 이해 당사자간의 월활한 의사소통 수단으로 활용
* 소프트웨어 아키텍처 프레임워크 구성요소
  * 아키텍처 명세서 : 아기텍처를 기록하기 위한 산출물
  * 이해 관계자 : 소프트웨어 시스템개발에 관련된 모든 사람과 조직
  * 관심사 : 이해관계자들의 다양한 요구사항과 관점을 반영한다
  * 관점 : 서로 다른 역활이나 책임에 따른 시스템에 대한 서로 다른 관점을 제시한다.
  * 뷰 : 이해 관계자들의 견해로부터 전체 시스템을 표현한다.
* 소프트웨어 아키텍처 4+1 뷰
  * 목적 : 고객의 요구사항을 정리한 시나리오를 다양한 관점에서 분석하고 표현한다.
  * 적용 : 복잡한 소프트웨어 아키텍처를 여러 이해 관계자가 이해할수 있도록 한다.
  * 구성
    * 논리적 관점 : 분석사/설계자 클래스나 컴포넌트의 종류와 관계
    * 구현 관점 : 프로그래머 서브시스템의 모듈 구조와 관계
    * 프로세스 관점 : 시스템 통합자 시스템의 성능, 확장성, 효율
    * 배치 관점 : 시스템 엔지니어 시스템의 구성
    * 유스케이스 관점 : 사용자 기능
* 4+1 구성요소
  * 논리뷰
    * 시스템의 기능적 요구사항을 표현
    * 최종 사용자에게 제공되는 기능을 나타냄
  * 구현뷰
    * 소프트웨어 모듈의 구성과 개발 관점을 반영
    * 컴포넌트 다어이그램으로 구현을 표현
  * 프로세스 뷰
    * 프로그램 실행시의 시스템을 표현
    * 동시성, 분산 처리, 시스템 통합등의 동적인 측면을 중점적으로 다룬다
  * 배치 뷰
    * 시스템의 물리적 배치와 네트워크 연결을 표현
  * 유스케이스뷰
    * 아키텍처 설계 및 검즈을 주도한다.
    * 유스케이스 다이어그램을 사용하여 다른 뷰를 검증한다.
* 소프트웨어 아키텍처 품질 속성
  * 정확성 : 사용자가 요구한 기능을 정확히 수행해야 한다.
  * 신뢰성 : 오차나 오류없이 기능이 안정적으로 동작해야 한다.
  * 효율성 : 자원을 적절학게 활요하여 기능을 수행해야 한다.
  * 무결성 : 자료는 인가된 사용자만이 변경 할수 있어야 한다.
  * 사용용이성 : 사용자가 쉽게ㅐ 배우고 사용할수 있어야 한다.
  * 유지 보수성 : 오류 수정및 변경이 용이해야 한다.
  * 시험용이성 : 테스트를 수행하기 용이해야 한다.
  * 유연성 : 새로운 요구사항을 쉽게 적용할수 있어야 한다.
  * 이식성 : 다양한 플랫폼 및 하드웨어 에서 운영이 가능해야 한다.
  * 재사용성 : 다른 목적으로도 사용하기 용이해야 한다.
  * 상호 운용성 : 다른 소프트웨어와 상호 작용이 용이해야 한다.
  * 확장성 : 시스템이 증가하는 부하에 대응할수 있어야 한다.
  * 보안 : 소프트웨어가 데이터 보안 및 개인정보 보호 기준을 충족해야 한다.

### 소프트웨어 아키텍처 패턴

* 소프트웨어 아키텍처 패턴 개념
  * 정의 : 재사용 가능한 소프트웨어 아키텍처의 해결책으로 공통적인 설계 문제에 대한 일반적인 접근 방법 제시
  * 목적 : 소프트웨어 개발 과정에서 발생할수 있는 다양한 문제를 해결한다.
  * 적용분야 
    * 컴퓨터 하드웨어 성능 최적화
    * 비즈니스 위험 최소화
    * 고가용성 및 확장성 확보
* 소프트웨어 아키텍처 패턴의 중요성
  * 재사용성 : 이미 검증된 설계 방식을 재사용함으로써 시간과 비용을 절감
  * 표준화 : 아키텍처 패턴을 사용하면 표준화된 방식으로 소프트웨어를 설계할수 있다.
  * 개발 효율성 : 일반적인 문제에 대한 해결책을 제공하여 개발 과정을 가속화 한다.
  * 문서화 : 아키텍처 패턴은 문서화 되어 있으며, 이를 통해 소프트웨어의 구조를 쉽게 이해할수 있다.
* 소프트웨어 아키텍처 패턴 종류
  * 계층화 패턴
    * 정의 : 소프트웨어를 여러 계층으로 구분하여 각 계층이 하위 계층의 기능을 사용하도록 하는 구조
    * 적용 : OSI 7계층, TCP/IP 4계층 등 네트워크 프로토콜 스택에서 널리 사용
    * 장점 : 계층간의 독립성으로 인해 유지보수와 업그레이드 용이
  * 클라이언트-서버패턴
    * 정의 : 서버가 여러 클라이언트에 서비스를 제공하는 구조
    * 적용 : 대부분의 웹 애플리케이션과 데이터베이스 시스템에서 사용
    * 장점 : 중앙 집중식 데이터 관리와 자원의 효율적 활용이 가능
  * 마스터-슬레이브패턴
    * 정의 : 마스터 컴포넌트가 작업을 여러 슬레이브에 분산시키고, 슬레이브의 처리 결과를 종합하는 구조
    * 적용 : 병렬 컴퓨팅 고성능 컴퓨팅 환경에서 사용
    * 장점 : 복잡한 작업을 여러 컴포넌트가 분담하여 처리 속도 향상이 가능
  * 파이프-필터패턴
    * 정의 : 데이터 스트림 처리 시스템에서 필터 컴포넌트가 각 단계의 처리를 수행하고 파이프를 통해 결과를 전달하는 구조
    * 적용 : Unix 쉘스크립트 및 데이터 스트림 처리 시스템에서 사용
    * 장점 : 각 필터의 독립적인 처리로 시스템의 확장성과 재사용성이 높다
  * 브로커 패턴
    * 적용 : 분산 시스템에서 컴포넌트간의 통신을 중재하는 브로커 컴포넌트를 사용
    * 기능 : 브로커는 서비스 요청을 수신하고 적절한 서비스 제공자에게 전달한다.
    * 장점 : 시스템의 유연성과 확장성을 증진한다.
  * 피어투피어 패턴
    * 정의 : 모든 컴포넌트가 서버와 클라이언트의 역활을 동시에 수행
    * 적용 : 파일 공유 시스템등에서 사용
    * 장점 : 중앙 집중식 서버에 의존하지 않는 분산 네트워크 구조를 가능하게 한다.
  * 이벤트 버스 패턴
    * 적용 : 이벤트 버스를 통해 메시지를 발행하고 리스너가 이를 구독하는 구조
    * 사용예 : 알림시스템, 메시징 시스템등에서 사용
    * 장점 : 이벤트 기반의 비동기 통신을 가능하게 한다.
  * 모델-뷰-컨트롤러 패턴
    * 구성 : 모델, 뷰, 컨트롤러 로 구성
    * 적용 : 웹 애플리케이션, GUI 기반 애플리케이션 등에서 널리 사용
    * 장점 : 각 컴포넌트의 독립성으로 인해 재사용성과 확장성이 높다
  * 블랙보드 패턴
    * 적용 : 복잡하고 명확한 해결 전략이 정의되지 않은 문제에 사용
    * 기능 : 여러 컴포넌트가 공유하는 중앙 정보 저장소(블랙보드)를 통해 협업한다.
  * 인터프리터 패턴
    * 적용 : 특정 프로그래밍 언어의 해석과 실행을 위한 컴포넌트 설계에 사용
    * 목적 : 언어의 문법을 정의하고 이를 해석하여 실행한다.
  
-----------------------------

## UML

### UML(Unified Modeling Language)

* UML 개념
  * 소프트웨어 시스템을 시각화 및 문서화 하고 소프트웨어 시스템의 구조와 동작을 명세하는 표준화된 모델링 언어
* UML 특징
  * 가시화 언어 : 다양한 다이어그램을 통해 시스템의 구조와 동작을 시각적으로 표현하며, 복잡한 시스템을 이해하기 쉽게한다. 
  * 명세화 언어 : 표준화된 언어로 시스템의 요구사항과 기능을 명세하는데 사용된다.
  * 구축 언어 : 설계와 구현에 도움이 되는 도구로, 특히 객체 지향 소프트웨어 개발에서 중요한 역활을 한다.
  * 문서화 언어 : 시스템의 기능, 구조, 동작 등을 표준화된 형태로 문서화 하여 개발 과정에서의 커뮤니케이션을 개선하고 유지보수를 돕는다.
* UML 구성요소
  * 사물
    * 구조사물 : 시스템의 개념적 물리적 요소(클래스, 유스케이스, 컴포넌트)
    * 행동사물 : 시간과 공간에 따른 요소들의 행위(상호작용, 상태머신)
    * 그룹사물 : 요소들을 그룹으로 묶은것(패키지)
    * 주해사물 : 부가적 설명이나 제약조건(주석, 노트)
  * 관계
    * 일반화 관계(상속)
      * 한 클래스가 다른 클래스를 포함하는 상위 개념일때의 개념
      * 객체 지향 개념에서는 일반화 관계를 상속 관계라고 한다.
    * 연관관계
      * 2개이상 사물이 서로 관련된 관계
      * 한 클래스가 다른 클래스에 제공하는 기능을 사용할때 표시
    * 의존관계
      * 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할때 표시
      * 연관관계와 차이점은 두 클래스의 관계가 한 메서드를 실행하는동안과 같이 매우 짧은 시간만 유지
      * 한클래스의 명세가 바뀌면 다른 클래스에 영향을 줌
      * 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용
    * 실체화 관계
      * 인터페이스를 구현받아 추상 메서드를 오버라이딩 하는것을 의미
      * 한객체가 다른 객체에게 오퍼레이션을 수행하도록 지정
    * 집합관계 - 집약관계(Aggregation)
      * 한객체가 다른 객체를 소유하는 'has a' 관계
      * 전체 객체의 라이프타임과 ㅜㅂ분 객체의 라이프 타임은 독립적
      * 전체 객체가 사라진다 해도 부분 객체는 사라지지 않음
    * 집합관계 - 합성관계(Composition)
      * 부분 객체가 전체 객체에 속하는 관계로 긴밀한 필수적 관계 
      * 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 의존적
      * 전체 객체가 없어지면 부분 객체도 없어짐
  * 다이어그램
    * 구조다이어그램
      * 클래스다이어그램
        * 시스템 클래스와 이들간의 관계들 표현
        * 시스템 내의 데이터 구조와 클래스간의 상속, 연관, 의존성등을 나타낸다.
      * 객체 다이어그램
        * 시스템 내의 객체와 이들간의 관계를 표현
        * 특정 시점에서 시스템의 인스턴스를 시각화 한다.
      * 컴포넌트 다이어그램
        * 시스템의 물리적 구조, 즉 컴포넌트와 그 상화작용을 표현
        * 소프트웨어 컴포넌트, 인터페이스, 의존성 등을 나타낸다.
      * 배치 다이어그램
        * 시스템의 물리적 배치와 구성요소들 간의 관계를 표현
        * 하드웨어, 네트워크, 소프트웨어 구성요소의 배치를 시각화한다.
      * 복함체 구조 다이어그램
        * 시스템 내의 복합 구조를 표현
      * 패키지 다이어그램
        * 시스템의 패키지와 이들간의 관계를 패키지 한다.
    * 행위 다이어그램
      * 유스케이스 다이어그램
        * 시스템의 기능과 사용자간의 상화작용을 표현
      * 순차 다이어그램
        * 객체간의 상호작용을 시간 순서에 따라 표현
      * 커뮤니케이션 다이어그램
        * 객체간의 상호작용을 객체들간의 관계와 통신에 중점을 둔다
      * 상태 다이어그램
        * 객체의 생명주기 동안의 상태 변화를 표현, 객체 외부 또는 내부 이벤트에 대한 반응을 나타낸다.
      * 활동 다이어그램
        * 시스템의 프로세스 또는 워크플로 표현
      * 상호작용 다이어그램
        * 시스템의 상호 작용을 하나의 고수준 워크플로우로 표현
      * 타이밍 다이어그램
        * 객체의 행동과 시간에 따른 상호작용을 표현

### 주요 다이어그램

* 클래스 다이어그램
  * 자기만의 속성과 일정한 행동으로 구성
  * 여러개의 클래스들은 서로 연관이나 상속, 의존관계등으로 서로간의 상호작용을 표현
  * 접근제한자
    * (-) : private : 클래스 내부에서만 접근 가능
    * (#) : protected : 상속받은 클래스에서 접근 가능
    * (+) : public : 모든 클래스에서 접근 가능
* 유스케이스 다이어그램
  * 시스템과 사용자의 상호작용을 다이어그램으로 표현
  * 사용자의 관점에서 시스템의 서비스 혹은 기능 및 그와 관련한 외부 요소를 보여준다.
  * 프로젝트에 대한 요구사항을 정의하고 세부 기능을 분석한다.
  * 구성요소
    * 시스템 : 만들고자 하는 프로그램 명칭
    * 액터 : 시스템의 외부에 있고 시스템과 상호작용을 사람, 시스템으로 표현
    * 유스케이스 : 사용자 입장에서 바라본 시스템의 기능
    * 관계 : 액터와 유스케이스 사이의 의미있는 관계
      * 연관관계 : 유스케이스와 액터간 상호작용이 있음을 표현
        * 유스케이스와 액터를 실선으로 표현
      * 포함관계 : 유스케이스를 수행할때 반드시 실행되어야 할 경우
        * Include 로 표현
      * 확장관계 : 유스케이스를 수행할때 특정조건에 따라 확장 기능을 유스케이스를 수행하는 경우
        * Extend 로 표현
      * 일반화관계 : 유스케이스간의 상속관계
* 시퀀스 다이어그램
  * 객체간의 상호작용 메시지 시퀀스를 시간의 흐름에 따라 나타내는 다이어그램
  * 구성요소
    * 객체와 생명선
      * 객체는 직사각형으로 표현
      * 라이프라인은 객체에서 이러지는 점선으로 표현
      * 점선은 위에서 아래로 갈수로 시간경과를 의미
    * 활성박스
      * 생명선상에서 기다란 직사각형으로 표현
      * 현재 객체가 어떤 활동을 하고 있음을 의미
    * 메시지
      * 인스턴스간 주고받은 데이터
      * 동기메시지, 비동기 메시지, 자체메시지, 반환메시지
* 상태 다이어그램
  * 한객체의 상태 변화를 나타내는 다이어그램

-------------------------------------------

## 화면 설계

### UI(User Interface) 개념

* UI 개념
  * 컴퓨터, 웹사이트, 시스템등의 정보기기와 사용자간의 상호작용을 가능하게 하는 매개체
  * UI 의 구성요소에는 디스플레이 화면, 아이콘, 검색창, 키보드, 문자, 색상, 폰트들이 포한된다.
  * UI 의 핵심은 사용자가 쉽고 편리하게 이용할수 있는 직관적이고 보편적인  디자인이다.
  * 좋은 UI 디자인은 사용자가 최소한의 노력으로 최대한의 효율을 얻을수 있도록 한다.
* UX 개념
  * 사용자가 UI 를통해 경험하는 모든것을 포함
  * 사용자의 만족감, 불편함, 그리고 이용과정에서의 감정과 행동을 모두 포함한다.
  * UX 디자인의 목표는 사용자 불만족을 최소화 하고 편리한 사용경험을 제공하는것
  * UX 는 단순히 제품의 기능적인 측면을 넘어서 사용자의 감정, 인식, 반응등 포괄적인 경험을 고려한다.
* UI 유형
  * CLI(Command Line Interface)
    * 텍스트 명령어를 통해 컴퓨터와 상호작용하는 인터페이스
  * GUI(Graphical User Interface)
    * 그래픽, 텍스트 를 사용하여 사용자와 컴퓨터간의 상호작용을 가능하게 하는 인터페이스
  * NUI(Natural User Interface)
    * 사용자의 자연스러운 동작을 인식하여 상호작용하는 인터페이스
  * OUI(Organic User Interface)
    * 현실의 모든것이 입력 및 출력 장치로 사용될수 있는 인터페이스
  * VUI(Voice User Interface)
    * 음성을 통해 사용자와 컴퓨터간의 상호작용을 가능하게 하는 인터페이스
  * ARUI(Augmented Reality User Interface)
    * 증강현실을 통해 사용자와 컴퓨터간의 상호작용을 가능하게 하는 인터페이스
* 요구사항 구분
  * 기능적 요구사항
    * 시스템이 제공해야 하는 기능에대한 요구사항
    * 입력, 출력, 데이터, 연산에 관한 요구사항
  * 비기능적 요구사항
    * 사용성, 효울성, 신뢰성, 유지보수성, 재사용성등 품질에 관한 요구사항
    * 플랫폼, 사용기술 등 시스템 환경에 관한 요구사항
    * 비용, 일정등 프로젝트 계획에 관한 요구사항
* 설계절차
  * UI 개발 목표 및 범위 수립 -> UI 전략 수립 -> 사용자 요구사항 분석 -> UI 상세 설계 -> 구현 -> 테스트
  * 개발 목표 및 범위 수립
    * 프로젝트의 UI 부문에 대한 목표와 범위를 설정
  * 전략 수립
    * 사용자 및 시장 조사를 통해 UI UX 전략을 개
  * 사용자 요구사항 분석
    * 사용자 조사 결과를 바탕으 필요한 요구사항을 파악하고 분석, 프로토 타입
  * UI 상세 설계
    * UI 기능, 화면구조, 상호 작용 흐름 및 예외처리에 대한 상세 설계를 수행
  * 구현
    * HTML, CSS, JavaScript 등을 사용하여 UI 를 구현
  * 테스트
    * UI 의 사용성을 검증
* UI 설계 원칙
  * 직관성 : 누구나 쉽게 이해하고 사용할수 있어야 한다.
  * 유효성 : 사용자의 목적을 정확하게 달성해야 한다.
  * 학습성 : 누구나 쉽게 배우고 익힐수 있어야 한다.
  * 유연성 : 사용자의 요구사항을 최대한 수용하며, 오류를 최소화 한다.
* UI 설계 도구
  * 와이어프레임
    * 웹사이트나 앱의 기본 구조와 레이아웃을 나타내는 초기 설계 도구
  * 스토리 보드
    * 서비스나 제품의 시나리오 흐름을 시각적으로 나타내는 도구
  * 프로토타입
    * 실제 서비스와 유사하게 동작하는 모델
  * 목업
    * 와이어프레임보다 구체적이며 실제 화면과 유사한 정적 디자인
  * 유스케이스
    * 사용자 관점에서 시스템이 어떻게 동작하는지 나타내는 도구

### 감성 공학

* 감성공학 개념
  * 인간의 감성을 물리적 설계 요소로 번역하고 구현하는 기술
  * 요소화 -> 형상화 -> 구현 -> 생산
* 제품과 관련된 인간의 감성
  * 감각적 감성 : 제품 외관, 색상, 디자인 등 외적 특성에 대한 감성
  * 기능적 감성 : 제품의 기능, 성능, 편의성 등 기능적 특성에 대한 감성
  * 문화적 감성 : 개인이 속한 사회나 문화에 대한 감성
* 감성 공학의 접근 방법
  * 1류 접근 방법 : 의미 미분법을 사용하여 제품에 대한 이미지를 분석하고 이를 디자인 요소와 연결
  * 2류 접근 방법 : 문화적 감성을 반영하되, 평가자들의 생활 식 등을 고려한 방법
  * 3루 접근 방법 : 특정 제품을 사용하여 감성을 정량화 하고 이를 제품 설계에 응용 하는 방법

----------------------------------

## UI 구현



