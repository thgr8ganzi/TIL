
# 소프트웨어 공학

--------------

## 소프트웨어 공학

### 공학이란

* 소프트웨어 위기를 극복하고 품질 높은 소프트웨어를 효율적으로 개발하기 위한 학문
* 소프트웨어 개발에 적용되는 방법, 도구, 이론을 포괄적으로 다룸

### 소프트웨어 공학의 3R

* 역공학
  * 이미 개발된 시스템을 분석하여 요구 분석서 설계서 등의 문서를 추출하는 작업
* 재공학
  * 유지보수의 생산성을 통해 소프트웨어의 위기를 해결하기 위한 방법
  * 분석 - 재구성 - 역공학 - 이관
* 재사용
  * 이미 개발된 소프트웨어의 전체 또는 일부를 다시 사용하는것
  * 재사용범위
    * 함수 와 객체
    * 컴포넌트
    * 애플리케이션
  * 재사용방법
    * 합성중심
      * 전자 칩과 같은 소프트웨어 부품, 모듈을 만들어서 이를 조합하여 소프트웨어를 완성
    * 생성중심
      * 추상화된 형태의 명세를 구체화하여 프로그램을 만듬
  * 개발단계
    * 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
  * 계획
    * 시스템 특성을 이해하여 비용 및 기간 예측
  * 요구사항 분석
    * 고객과 함께 소프트웨어의 기능 제약조건 목표 정의
  * 설계
    * 시스템 구조 설계, 프로그램 설계, 사용자 인터페이스 설계
  * 구현
    * 프로그래밍  언어를 사용하여 실제 프로그램 작성, 코딩, 디버깅, 단위테스트
  * 테스트
    * 구현된 소프트웨어가 요구사항을 만족하는지 검사
  * 유지보수
    * 사용중 발견된 문제 수정, 새로운 기능 추가
    * 수정보수, 향상보수, 적응보수, 예방보수

-----------------------------

## 소프트웨어 개발 방법론

### 개발 방법론 개념

* 소프트웨어 개발을 위한 절차, 방법, 도구, 기법 등을 체계적으로 정리한 것

### 종류

* 구조적 방법론
  * 절차지향적인 소프트웨어 개발 방법론
  * 하향식
  * 데이터흐름도(DFD) : 시스템 내의 데이터 흐름을 그래픽으로 표현
  * 자료사전(DD) : 시스템에서 사용되는 데이터의 세부 사항을 문서화
  * 상태전이도(STD) : 시스템의 상태 변화를 시각적으로 표현
  * 소단위 명세서(MiniSpec) : 개별 모듈의 기능과 로직을 상세하기 기술
* 정보공학 방법론
  * 기업의 주요 부분을 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성있게 통합하여 적용
  * 데이터중심
* 객체지향 개발 방법론
  * 현실세계의 개체를 속성과 메서드로 표현
  * 상향식
  * 캡슐화 : 객체의 세부 구현을 숨기고 인터페이스만을 제공
  * 정보 은닉 : 객체 내부의 세부사항을 외부로부터 숨김
  * 상속 : 재사용과 확장성을 위해 상위 클래스의 속성과 메서드를 하위클래스가 상속
  * 다형성 : 하나의 인터페이스가 다양한 형태로 구현되는 것
    * 오버 로딩 : 같은 이름의 메서드를 여러개 정의
    * 오버 라이딩 : 상위 클래스의 메서드를 하위 클래스에서 재정의
  * 추상화 : 복잡한 현실 세계를 단순화 하여 모델링
* CBD(Component Based Development) 방법론
  * 재사용 가능한 컴포넌트의 개발 또는 상용 컴포넌트를 조합하여 애플리케이션 개발
  * 확장성 : 새로운 컴포넌트 추가 및 기존 컴포넌트 수정 용이
  * 생산성 및 품질 향상 : 이미 검증된 컴포넌트 사용으로 신뢰성 높음
  * 유지보수 비용 최소화 : 개별 컴포넌트 수정이 전체 시스템에 미치는 영향 최소화
* 애자일 방법론
  * 변화에 빠르고 유연하게 대응하는 개발 방식
  * 민첨성 효율성
  * XP(eXtreme Programming) : 의사소통, 피드백, 존중, 용기, 단순성, 반복적이고 점진적인 개발
  * 스크럼(Scrum) : 유연하고 생산적인 프로젝트 관리 방식
  * FDD(Feature Driven Development) : 기능 중심의 개발 방법론
  * Crystal : 프로젝트의 특성에 따라 다양한 방법론 제공

### 소프트웨어 개발 모델

* 폭포수 모델
  * 순차적 접근 : 개발 과정이 계획, 분석, 설계 구현, 테스트, 운영의 순서로 진행
  * 단계별 검증 : 각 단계는 이전 단계가 완료 된후에 시작, 다음단계로 넘어가기전 검증
  * 병행 및 반복 진행의 부재 : 한번 시작된 단계는 이전 단계로 돌아가거나 병행 진행이 허용되지 않는다
  * 경험 및 성공사례 : 소프트웨어 개발의 오래된 모델로 다양한 성공사례가 있다.
  * 요구사항 변경의 어려움 : 초기에 설정된 요구사항을 나중에 변경하기 어렵다
  * 단계별 명확성 : 각 단계는 명확한 결과물을 가지고 있어야 한다
  * 고객 피드백의 부족 : 개발 과정중 고객의 피드백을 적극적으로 받기 어렵다.
  * 유연성 부족 : 시장이나 기술의 변화에 빠르게 대응이 어렵다.
* 프로토 타이핑 모델
  * 고객이 요구하는 주요 기능을 프로토 타입으로 먼저 구현하는 모델
  * 장점
    * 사용자의 요구사항을 충실히 반영할수 있다.
    * 사용자가 비교적 빠른기간내에 결과물을 평가할수 있다
    * 오류를 초기에 발견하고 수정할수 있다.
    * 요구사항 변경이 용이
  * 단점
    * 최종적으로 더많은 시간과 비용이 소요될수 있다.
    * 사용자가 프로토 타입을 실제 제품으로 오해할수 있다.
    * 문서화 과정이 소홀해질수 있다.
    * 폐기되는 프로토 타입에 대한 비용이 발생할수 있다.
* 나선형 모델
  * 계획 -> 위험분석 -> 개발 -> 평가
  * 폭포수 모델과 프로토타이필 모델의 장점을 통합하고 위험 분석을 추가하여 점증적으로 개발을 진행하는 모델
  * 위험 관리
  * 장점
    * 위험분석 과정을 통해 높은 위험성을 가진 프로젝트도 수행 가능하다.
    * 고객의 요구사항을 더 상세하게 적용할수 있다.
  * 단점
    * 개발 과정이 길어지면서 시간과 비용이 증가할수 있다.
    * 반복단계가 길어지면 프로젝트 관리가 어려워질수 있다.
* RAD(Rapid Application Development)
  * 매우빠른 개발 주기를 통해 소프트웨어를 신속하게 제공
  * 고급 소프트웨어 개발 도구와 CASE 도구를 활용
  * 장점
    * 짧은 개발 주기를 통해 빠른 시장 출시가 가능하다
    * 사용자 피드백을 신속하게 반영하여 사용자 중심의 소프트웨어 개발을 지원
    * 변경사항에 대해 유연하게 대처함
  * 단점
    * 매우 큰 규모의 프로젝트에는 적합하지 않음
    * 높은 수준의 개발 도구와 전문 인력이 필요
* V모델
  * 개발 각 단계에서 검증과 테스트를 중점적으로 진행
  * 개발 단계마다 해당하는 테스트 단계가 있어 체계적인 품질 관리 가능
  * 단위테스트 - 통합테스트 - 시스템 테스트 - 인수테스트
  * 장점
    * 개발 각 단계에서 체계적으로 테스트 진행
    * 높은 신뢰성이 요구되는 시스템 개발에 적합
  * 단점
    * 요구사항 변경에 대응하기 어렵다.
    * 초기 요구사항 분성의 오류가 프로젝트 전체에 영향을 미칠수 있음
  * 요구분석 -> 아키텍처 설계 -> 모듈설계 -> 구현 -> 단위테스트 -> 통합테스트 -> 시스템테스트 -> 인수테스트
* 4세대 기법
  * 요구사항 명세서를 기반으로 소프트웨어 코드를 자동으로 생성
  * 4세대 언어와 같은 고급 프로그래밍 언어와 도구를 사용한다.

#### 애자일 방법론

* 개념
  * 신속하고 반복적인 작업을 통해 작동 가능한 소프트웨어를 개발
  * 작은 구성 요소를 빠르게 제공하고 애자일 개발을 가능하게 하는 다양한 방법론의 집합
  * 경량 프로세스
* 등장 배경
  * 기존 소프트웨어 개발 방법론이 가진 문제점들을 해결하기 위해 등장
  * 기존 소프트웨어 개발 방법론의 주요 문제점
    * 계약과 계획 준수에 중점을 둔 문화, 문서작성 과도하게 중시, 프로세스와 두구의 적용 중시, 계획 또는 통제 실패시 성과 나쁠때 부정적 인식
* 방법론 종류
  * XP
    * 특징
      * 문서보다는 코드를 중시하고 5가지 핵심가치와 12개 실천항목이 존재
        * 용기 : 고객의 요구사항 변화에 능동적인 대처
        * 존중 : 개발자의 역량을 존중하고 충분한 권한과 권리를 부여
        * 의사소통 : 개발자, 관리자, 고객 간의 원활한 의사소통
        * 피드백 : 의사소통에 따른 즉각적인 피드백
        * 단순성 : 부가적 기능, 사용되지 않는 구조와 알고리즘 배제
  * 스크럼
    * 특징
      * 소프트웨어에 포함될 기능, 개선점에 대한 우선순위를 부여
      * 개발 주기는 30정도로 조절하고 개발 주기마다 실제 동작할수 있는 결과를 제공
      * 개발 주기마다 적용할 기능이나 개선에 대한 목록을 작성
      * 매일 15분 정도의 회의
    * 주요 개념
      * 제픔 백로그
        * 개발할 제품에 대한 요구사항 목록
      * 스프린트
        * 1 ~ 4주의 짧은 기간의 반복적인 개발주기
      * 스프린트 계획 회의
        * 스프린트 목표와 스프린트 백로그를 계획하는 회의
      * 스프린트 백로그
        * 각각의 스프린트 목표에 도달하기 위해 필요한 작업 목록
      * 일일 스크럼 회의
        * 날마다 진행되는 15분 정도의 미팅
      * 실행 가능한 제품
        * 스프린트 결과로써 나오는 실행 가능한 제품
    * 크리스털
      * 프로젝트 규모와 영향의 크기에 따라서 여러종류 방법론 제공
    * FDD
      * Feature 마다 2주 정도의 반복 개발을 실시
    * ASD
      * 합동 애플리케이션 개발을 사용하는 방법론
    * 린(Lean)
      * 도요타 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거

### IT 서비스 관리

* SLM(Service Level Management)
  * 정의
    * 서비스 수준을 정량적으로 측정하고 실적을 평가하여 미흡한 부분을 개선하는 관리 활동
  * 목적
    * 서비스 품질의 지속적 개선을 통해 고객 만족도를 높임
    * SLA 에 명시된 기준을 기반으로 서비스 품질을 관리하고 개선
* SLA(Service Level Agreement)
  * 정의
    * 소프트웨어 수요자와 공급자간에 서비스 수준을 명시적으로 정의한 문서
  * 구성요소
    * 업무 목표/범위
    * 성과지표
    * 조정 절차
* ITSM(Information Technology Service Management)
  * 정의
    * 최종 사용자를 위한 IT 서비스를 구현, 전달, 관리하는 일련의 정책과 광핸
  * 특징
    * 최종 사용자의 요구와 비즈니스 목표에 부합하는 방식으로 IT 서비스 제공
* ITIL(Information Technology Infrastructure Library)
  * 정의
    * IT 서비스 관리를 위한 프레임워크
  * 특징
    * ITSM 을 실현하기 위한 도구나 방법을 제공
 
----------------------------------------------

## 프로젝트 계획

### 프로젝트 관리

* 개념
  * 특정한 목적을 달성하기 위해 한정된 기간, 예산, 자원 을 활용하여 사용자가 만족할만한 제품이나 서비스를 개발하도록 하는 기술적 관리적 활동
* 목적
  * 납기준수, 예산준수, 품질 준수를 통한 고객만족 달성
* 프로젝트 핵심 관리 대상(3p)
  * 사람
    * 프로젝트 팀원과 관련 이해 관계자들
    * 이들의 역량과 협력이 프로젝트 성공의 핵심
  * 문제
    * 프로젝트의 목표 달성을 위해 해결해야할 과제나 문제
    * 이러한 문제들을 효과적으로 분석하고 설계하는것이 중요
  * 프로세스
    * 프로젝트의 흐름을 조직하고 관리하는 방법론
* PMBOK(Project Management Body of Knowledge)
  * PMI(Project Management Institute)에서 발행하는 프로젝트 관리 지침서

### 개발 비용산정

* 소프트웨어 개발 비용 계획
  * 개발에 필요한 인원, 자원, 기간 등을 고려하여 소프트웨어의 규모를 파악하고 이를 바탕으로 필요한 비용 산정
* 비용 계획 결정 요소
  * 개발자 역량
  * 소프트웨어의 복잡도
  * 소프트웨어의 크기
  * 개발기간
  * 요구되는 신뢰도 수준
  * 기술 수준
* 비용산정 기법 *
  * 하향식 산정 기법
    * 전문가 판단 기법
    * 델파이 기법
  * 상향식 산정 기법
    * 원시 코드 라인수
    * 개발 단계별 노력 기법
  * 수학적 산정 기법
    * COCOMO 기법
    * PUTNAM 기법
    * FP(Function Point) 기법

#### 하향식 산정 기법

* 과거 유사 경험을 바탕으로 회의를 통해 전체 프로젝트의 비용을 산정하는 방식
* 전문가 판단 기법
  * 조직내 경험이 있는 전문가에게 비용 산정을 의뢰하는 방식
* 델파이 기법
  * 여러 전문가의 의견을 종합 하여 판단하는 방식
  * 특정 전문가의 주관적 편견을 보완하기 위해 여러명의 전문가로 구성

#### 상향식 산정 기법

* 프로젝트의 세부 작업 단위별로 비용을 산정후 이를 합산하여 전체 비용을 계산하는 방식
* 원시코드 라인수
  * 각기능의 원시 코드 라인수의 비관치, 낙관치, 중간치를 측정후 예측치를 구하고 이를 이용해 비용을 산정하는 기법
  * 추정 LOC : (낙관치 + (4 * 중간치) + 비관치) / 6
* 개발 단계별 노력
  * LOC 기법을 확장하여 소프트웨어 개발 생명 주기의 각 단계별로 적용되는 모든 단계의 비용을 산정

#### 수학적 산정 기법

* COCOMO 기법
  * 소프트웨어의 규모를 LOC 기반으로 예측하고 소프트웨어 종류에 따라 비용 산정 공식에 적용 비용을 산정 하는 모델
  * 조직형
    * 5만라인 이하
    * 일반 업무용 소프트웨어
  * 반분리형
    * 30만 라인 이하
    * 운영체제, DBMS 등
  * 내장형
    * 30만 라인 이상
    * 미사일 유도 시스템
* Putnam 기법
  * Putnam 이 제안한 생명주기 예측 모형
  * 시간에 따른 노력 분포를 Rayleigh-Norden 곡선으로 표현
  * 주로 대형 프로젝트에 이용
  * SLIM : Rayleigh-Norden 곡선과 Putnam 예측 모델을 기반으로 한 자동화 추정 도구
* FP
  * 소프트웨어 기능 개수를 기준으로 규모를 측정하는 기법
  * ESTIMACS : FP 기반의 자동화 추정 도구
  * 기능점수
    * 데이터 기능
      * 내부논리파일
      * 내부연계파일
    * 트랜잭션 기능
      * 외부입력
      * 외부출력
      * 외부조회
  * 산정요소
    * 자료입력 : 사용자 또는 시스템이 입력하는 데이터의 양식및 복잡도 평가
    * 정보 출력 : 시스템이 제공하는 출력 보고서의 양식 및 복잡도 평가
    * 명령어 : 사용자가 시스템에 요청하는 징의의 종류 및 복잡도를 평가
    * 데이터 파일 : 시스템이 관리하는 데이터 파일의 복잡도 및 관련성을 평가
    * 외부 인터페이스 : 시스템과 필요한 외부 루틴과의 인터페이스를 평가

### 개발 일정 산정

* 소프트웨어 개발을 위해 필요한 작업을 정의하고 이들 작업의 우선 순위를 설정하여 전체 프로젝트 일정 계획을 수립
* 작업순서
  * 작업분해(WBS) : 전체 작업을 작은 단위로 분해한다
  * CPM 네트워크 작성 : Critical Path Method 를 사용하여 작업 순서 및 의존성 정의
  * 최소 소요 기간 : 각 작업에 필요한 최소 시간을 계산한다.
  * 소요 Man-Month 및 기간 산정후 CPM 수정 : 작업에 필요한 인력 및 시간을 계산하여 CPM 을 업데이트 한다.
  * 간트 차트로 표현 : 프로젝트 일정을 시간적으로 표현

#### WBS(Work Breakdown Structure)

* 프로젝트 목표를 달성하기 위한 활동과 업무를 세분화하는 과정
* 작성방법
  * 전체 프로젝트를 큰단위로 분할
  * 각 부분을 더 작은 단위로 분해하여 계층적으로 표현
  * 각 단계별로 담당인원을 배치하고 구성도를 작성
* 역활
  * 업무식별, 계획및 비용산정, 진행 상황 파악, 이해당사자들간 의사소통 촉진

#### Network Chary(PERT/CPM)

* PERT
  * 개발 배경
    * 미국 해군이 Polaris 미사일 개발 프로젝트의 일정 계획 및 진행 과정을 효율적으로 관리하기 위해 개발
  * 목적
    * 전체 프로젝트의 시간 단축에 중점
    * 불확실한 상황에서의 시간 관리에 적합
  * 방법론
    * 개발 기간을 낙관치 기대치, 비관치, 예측치를 계산
    * (낙관치 + (4 * 예측치) + 비관치) / 6
* CPM
  * 개발 배경
    * 미국 Dupont 사에서 산업 설비의 유지보수를 위한 프로젝트의 일정 계획 및 진행 과정을 효율적으로 관리하기 위해 개발
  * 목적
    * 최소비용 추가 투입을 고려하여 전체 프로젝트의 시간단축을 목표로 한다.
  * 특징
    * CPM 은 더 확정적인 상황에서의 시간 관리에 적합
    * 비용과 시간 사이의 최적 균형을 찾는데 중점
  * 기능
    * 작업의 선/후행 관계를 고려하여 전체 작업의 완료 시간을 결정
    * PERT 는 불확실한 시간 추정에
    * CPM 은 비용과 시간의 최적화에 중점
  * 임계 경로
    * 프로젝트를 끝내기 위해 필요한 최소 소요 기간
    * 경로상 가장 오래걸리는 시간을 임계 경로로 정한다
  * 적용
    * 복잡한 대형 프로젝트를 효율적으로 계획하고 통제하기 위해 사용
* 간트 차트
  * 정의
    * 프로젝트 일정 계획의 시각적 표현
    * 일정관리의 최종 산출물로 사용되며 프로젝트의 시간 관리에 필수적인 도구
  * 형태와 기능
    * 이 차트는 바 형태로 표현되며 각 업무 또는 활동의 시작과 종료시점을 그래픽으로 나타낸다
    * 이를 통해 프로젝트의 전체 일정을 한눈에 파악할수 있다.
  * 업무표시
    * 간트차트는 각각의 업무나 활동을 개별적인 바로 표시하며, 이 바는 해당 업무의 시작과 종료 시점을 나타낸다.

--------------------------------

## 요구사항 분석

### 현행시스템 분석

* 현행 시스템 파악의 정의
  * 기존시스템의 기능, 성능, 그리고 문제점을 이해하고 평가하기 위한 과정
  * 이 과정을 통해 새로운 시스템에서 개선해야 할 부분, 유지해야 할 부분, 변경해야 할 부분을 파악
* 현행 시스템 분석 단계
  * 시스템 이해 : 현재 시스템의 목적, 기능 및 사용 방법을 파악, 문서 분석, 인터뷰, 시스템 사용 관찰 등
  * 시스템 평가 : 현재 시스템의 성능과 효율성을 평가, 사용자 피드백 수집, 시스템 로그 분석등
  * 문제점 식별 : 현재시스템에서 발생하는 문제점과 제약 사항 식별
  * 요구사항 식별 : 새로운시스템에서 해결 하거나 개선해야 할 요구사항을 식별
* 플랫폼 정의
  * 다양한 응용 프로그램, 서비스 또는 기능이 구축되거나 실행되는 기반 또는 환경
* 플랫폼의 기능
  * 연결 기능 : 연결을 가능하게 하는 장소를 제공하여 교류 촉진
  * 비용감소 : 플랫폼을 제공하여 각 그룹이 처리 할 발생하는 시간과 비용 절감
  * 브랜드 신뢰 기능 : 플랫폼 브랜드가 사용자에게 신뢰감을 부여하여 일정 수준의 질을 보장
  * 커뮤니티 형성 : 그룹간 상호 작용을 통한 커뮤니티 형성
* 플랫폼의 종류
  * 하드웨어 플랫폼
  * 소프트웨어 플랫폼
  * 서비스 플랫폼
* 플랫폼의 유형
  * 거래플랫폼
  * 생태계 플랫폼
  * 다면 플랫폼 
* CPND(Contents Platform Network Device)
  * 개념
    * 콘텐츠를 플랫폼에 맞게 가공하고 네트워크를 통해 사용자의 단말기로 서비스가 이루어짐을 표현하는 무선 인터넷 서비스의 가치사슬
  * 콘텐츠의 요소
    * Contents : 텍스트, 이미지, 오디오, 비디오 등
    * Platform : 웹사이트 애플리케이션 등
    * Network : 통신 시스템
    * Device : 스마트폰, 컴퓨터, 태블릿
* 현행시스템 분석
  * 운영 체제 분석
    * 사용중인 운영체제의 종류와 버전 그에따른 호환성, 성능, 보안등의 문제를 파악한다.
  * 네트워크 분석
    * 네트워크의 구조와 프로토콜, 대역폭, 지연시간, 보안, 장애복구등에 관한 문제를 파악한다.
  * DBMS 분석
    * 사용중인 DBMS 의 종류와 버전 데이터모델, 성능, 보안 백업및 복구등에 관한 문제를 파악한다.
  * 미들웨어 분석
    * 양쪽을 연결하여 데이터를 주고받을수 있도록 중간에서 매개 역활을 하는 소프트웨어
    * 네트워크를 통해서 연결된 여러대의 컴푸터에 있는 많은 프로세서들에게 어떤 서비스를 사용할수 있도록 연결해주는 소프트웨어
  * 미들웨어 종류
    * 원격 프로시저 호출(Remote Procedure Call)
      * 클라이언트가 원격에서 동작하는 프로시저를 호출하는 시스템
    * 메시지 지향 미들웨어(Message Oriented Middleware)
      * 클라이언트가 생성한 메시지는 저장소에 요청할때 저장하면서 다른 업무를 지속할수 있도록 하는 비동기식 미들웨어
    * ORB(Object Request Broker)
      * 객체지향 프로그래밍에서 객체간의 통신을 지원하는 미들웨어
    * DB 접속 미들웨어
      * 애플리케이션과 데이터베이스 서버를 연결해주는 미들웨어
    * TP 모니터(Transaction Processing Monitor)
      * 분산 시스템의 애플리케이션을 지원하는 미들웨어
      * 트랜잭션이 올바르게 처리되고 있는지 데이터베이스를 감시하고 제어
    * 웹 애플리케이션 서버(WAS)
      * 앱 애플맄이션을 지원하는 미들웨어
    * 엔터프라이즈 서비스 버스(Energy Service Bus)
      * 메시지 기반으로 느슨한 결합 형태의 표준 인터페이스 통신을 지원하는 미들웨어로 기업 안팎에 있는 모든 시스템 환경을 연동하는 미들웨어

### 요구 공학

* 요구공학 개념
  * 소프트웨어의 요구사항을 식별, 분석, 문서화 하고, 이를 관리하는 과정
* 요구공학 필요성
  * 품질개선
  * 리스크 감소
  * 비용절감
  * 효율적 프로젝트 관리
  * 사용자와 개발자 간의 소통 개선
* 요구사항 개발 프로세스
  * 도출 -> 분석 -> 명세 -> 확인
* 도출
  * 사용자와 이해관계자 들로부터 요구사항을 수집한다.
  * 인터뷰, 설문조사, 브레인스토밍, 워크샵, 직접 관찰 등 다양한 방법을 통해 수행된다.
* 분석
  * 수집된 요구사항중 불완전 하거나 모호하며, 중복된거나 충돌하는 부분을 식별하여 수정
  * 업무환경과 상화작용 파악(도메인 분석)
  * 분석 도구
    * DFD(Data Flow Diagram) : 자료흐름도
    * Data Dictionary : 자료사전
    * Mini-Spec : 요구사항 명세서
    * ERD(Entity Relationship Diagram) : 개체관계도
    * State Transition Diagram : 상태전이도
  * 객체지향 분석도구
    * UML(Unified Modeling Language)
    * 모델링
* 명세
  * 분석된 요구사항은 명세서 형태로 정리
  * 시스템이 수행해야 할 기능, 시스템이 충족해야 할 성능, 그리고 제약 조건등이 포함한다.
  * 요구사항 명세 기법
    * 정형 명세 기법
      * 수학, 논리학 기반
      * 수학적 기호, 정형화된 표기법으로 작성
      * 명세 오류및 모호성을 쉽게 파악
      * 작성이 어렵고, 시간이 많이 소요
      * VDM, Z, Petri-net, CSP
    * 비정형 명세 기법
      * 자연어, 그림중심 기반
      * 일반명사, 동사등의 자연어기반으로 서술하거나 다이어그램으로 작성
      * 사용자/개발자간 의사 전달 용이
      * 내용이 모호하고 완전한 검증이 곤란
      * FSM, Decision Table, ER 모델링, State Chart(SADT)
  * 요구사항 분류
    * 기능 요구사항
      * 시스템이 어떤 기능을 수행해야 하는지 또는 시스템이 제공해야 하는 서비스가 무엇인지를 정의
    * 비기능 요구사항
      * 시스템이 어떻게 동작해야 하는지에 대한 요구사항
      * 품질관련, 제약사항, 성능, 보안, 가용성, 유지보수성
* 확인 및 검증
  * 분석가가 요구사항을 이해했는지 확인, 문서가 일관성 있고 완전한지 검증
* 요구사항 분석 기법
  * 인터뷰
  * 브레인스토밍
  * 원인-효과 다이어그램
  * 프로토타이핑
  * 사용사례(User Case)
  * 요구사항 검토
* 요구사항 분석 CASE(Computer Aided Software Engineering)
  * 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하는 도구
  * 개발 전반에 걸쳐 적용
  * CASE 도구의 분류
    * 상위 CASE
      * 생명주기 전반부에 사용되면 소프트웨어 계획과 요구분석, 설계 단계를 지원
    * 하위 CASE
      * SDLC의 하위 단계인 프로그래밍, 테스트, 유지보수 단계를 지원
    * 통합 CASE
      * 소프트웨어 생명주기에 포함되는 전체 과정을 지원한다.
* 요구사항 분석 도구
  * HIPO(Hierarchy Input Process Output)
    * 개념
      * 하향식 소프트웨어 개발을 위한 문서화 도구
      * 시스템의 기능을 여러개의 고유 모듈들로 분할하여 이들간의 계층 구조를 표현한 도표
    * 기능
      * 분석및 설계 도구로 사용
      * 하향식 개발에 적합
      * 체계적인 문서 관리에 효율적
      * 기능과 자료의 의존관계를 명시할수 있다
    * 구성요소
      * 주요프로세스
      * 하위 프로세스
      * 입력 출력
    * HIPO Chart 종류
      * 가시적 도표
        * 시스템의 전체 기능과 흐름을 보여주는 Tree 구조
        * 가시적 도표에는 입력, 처리, 출력 없음
      * 총체적 도표
        * 프로그램을 구성하는 기능을 기술한것
        * 입력, 처리, 출력에 대한 전반적인 정보를 제공
      * 세부적 도표
        * 총체적 도표의 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표
        * 총체적 도표와 같은 모양이지만 내용만 좀 더 복잡하게 들어간 형태
* 모델링
  * 개녕
    * 복잡한 시스템을 이해하고 효과적으로 개발하기 위한 간단한 모델로 표현하는 과정
  * 도움
    * 소프트웨어의 구조와 동작을 이해하는데 도움
  * 구분
    * 기능적 모델링
      * 사용자 관점에서 시스템의 기능을 표현
      * 사용사례 다이어그램, 액티비티 다이어그램
    * 정적 모델링
      * 시스템의 구조를 클래스 단위로 표현
      * 클래스 다이어그램
    * 동적 다이어그램
      * 시스템의 상화 작용 및 동작을 표현
      * 순서 다이어그램, 상태 다이어그램 커뮤니케이션 다이어 그램
  * 종류
    * 구조적 분석 모델
      * 데이터 흐름도
        * 시스템 내에서 자료가 어떻게 이동하고 처리되는지를 도형으로 나타내는 모델링 도구
        * 처리과정 : 동그라미
        * 자료흐름 : 화살표
        * 자료 저장소 : 평행선
        * 단말 : 사각형
      * 자료 사전
        * 자료 흐름도에 기술한 모든 자료들에 대해 자세한 정의와 설명을 제시하는 중요한도구
        * = : 자료 정의
        * (+) : 자료 연결
        * () : 자료 생략
        * [] : 자료의 선택
        * {} : 자료의 반복
        * (**) : 자료의 설명
      * 소단위 명세서
        * 자료 흐름도에서 각 처리가 수행하는 업무를 상세하게 작성하는 문서
        * 프로세스 명세서 라고 한다.
      * 개채 관계도(Entity Relationship Diagram)
        * 시스템에서 처리되는 구조인 개체와 그 속성, 개체간의 관계를 도식화 하여 모델링하는 도구
        * 개체 : 업무의 중심이 되는 실체 : 네모
        * 속성 : 업무에 속하는 구체적 항목 : 동그리미
        * 관계 : 업무와 업무의 관계 : 마름모
      * 상태 전이도(State Transition Diagram)
        * 시스템의 상태와 상태간의 전이를 모델화하는 도구
    * 객체지향 분석 모델
      * 객체지향 분석 방법론
        * 럼바우(Rumbaugh) 방법론
          * 가장 일반적으로 사용되는 방법으로 분석 활동을 객체, 동적, 기능 모델로 나누어 수행
          * 객체모델링 : 객체 다이어그램을 통해 시스템의 객체 속성, 연산, 관계를 표현, 가장 선행되어야함
          * 동적모델링 : 상태 다이어그램을 사용하여 시간에 따른 객체의 행동과 상화 작용을 표현
          * 기능모델링 : DFD 를 이용해 데이터 흐름과 처리과정 표현
        * 부치(Booch) 방법
          * 미시적 거시적 개발 프로세스를 모두 사용
        * Jacobson 방법
          * Use Case 를 중심으로 시스템의 기능을 분석
        * Coad 와 Yourdon 방법
          * E-R 다이어그램을 사용하여 객체의 행위를 모델링
        * Wirfs-Brock 방법
          * 분석과 설계의 구분없이 연속적으로 작업 수행
    * 정보공학 분석 모델
    * 정형화 분석 모델

-------------------------------

## 소프트웨어 설계

### 소프트웨어 설계

* 소프트웨어 설계의 개념
  * 요구사항 명세서를 바탕으로 소프트웨어의 구체적인 설계서를 작성하는 단계
* 설계의 종류
  * 상위 설계
    * 아키텍처설계 - 데이터설계 - 인터페이스 정의 - 사용자 인터페이스 설계
    * 아키텍쳐 설계 : 시스템의 전체적인 구조를 설계
    * 데이터 설계 : 데이터베이스의 구조를 설계
    * 인터페이스 정의 : 시스템 구조와 서브시스템들 사이의 이터페이스를 명확하게 정의
    * 사용자 인터페이스설계 : 사용자의 편의를 고려하여 인터페이스를 설계
  * 하위 설계
    * 모듈설계 - 자료구조 설계 - 알고리즘 설계
    * 모듈설계 : 각 모듈의 내부를 알고리즘 형태로 표현
    * 자료구조 설계 : 데이터의 저장 구조와 변수등에 대한 상세한 정보를 설계
    * 알고리즘 설계 : 업무의 처리 절차와 알고리즘을 설계
* 소프트웨어 설계의 원리
  * 분할과 정복
    * 큰 소프트웨어를 여러개의 작은 서브 시스템으로 나누어 각각을 완성 하는 방법
  * 추상화
    * 실세계의 복잡한 상황을 간결하고 명확하게 핵심 위주로 단순화 한다.
    * 추상화 기법
      * 과정 추상화 : 상위 수준에서 수행 흐름만 설계
      * 데이터 추상화 : 데이터 구조를 간단한 표현으로 대체
      * 제어 추상화 : 명령들을 간단한 표현으로 대체
  * 단계적 분해
    * 기능을 점차적으로 작은 단위로 나누고 구체화 하는 방법
    * 설계를 단계별로 세분화하여 각 단계의 복잡성을 관리한다
  * 모듈화
    * 시스템을 개별적으로 개발 가능한 작은 모듈로 나눈다.
    * 각 모듈을 독립적으로 개발, 테스트 및 유지보수 할수 있게 한다.
  * 정보은닉
    * 객체가 자신의 정보를 숨기고 외부의 접근을 제한한다.
    * 캡슐화와 밀접하게 연관되어 있으며 데이터와 기능을 안전하게 보호한다.
  * 결합도와 응집도
    * 결합도는 낮추고 응집도는 높인다.

### 설계 모델링

* 설계 모델링의 개념
  * 소프트웨어의 구조와 기능을 그래픽적으로 표현
* 설계 모델링 원칙
  * 변경이 용이하도록 구조화
* 설계 모델링의 유형
  * 구조 모델링
    * 시스템의 구성 요소와 그 사이의 구조적 관계를 모델링한다.
    * UML 정적 다이어 그램
  * 행위 모델링
    * 소프트웨어 구성요소의 기능 수행순서와 방식을 모델링한다.
    * UML 동적 다이어그램
* 소프트웨어 설계 절차 및 유형
  * 아키텍쳐 설계 : 시스템의 전체 구조와 서브 시스템간의 관계를 설계한다.
  * 데이터베이스 설계 : 시스템에서 사용되는 데이터 구조를 설계
  * 서브시스템 설계 : 각 서브시스템의 기능과 제약 사항을 명세한다.
  * 컴포넌트 설계 : 기능을 수행하는 컴포넌트들을 설계하고 그들간의 인터페이스를 명세한다.
  * 자료구조와 알고리즘 설계 : 데이터 저장 방식과 기본 연산 방법을 설계 한다.
* 협약에 의한 설계
  * 클래스에 대한 선행조건, 결과조건, 불변조건을 명세한다.
  * 선행조건 : 컴포넌트 오퍼레이션 사용전에 참이 되어야 할 조건
  * 결과조건 : 사용후 만족되어야 할 결과조건
  * 불변조건 : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

----------------------------

## 소프트웨어 아키텍처

### 소프트웨어 아키텍처

* 소프트웨어 아키텍처의 개념
  * 정의 : 소프트웨어의 기본 구조로, 시스템의 컴포넌트와 이들간의 관계를 기술한다.
  * 목적 : 시스템의 골격을 제공하고, 고수준에서의 설계 지침을 제공한다.
* 소프트웨어 아키텍처의 특징
  * 간략성 : 이해하고 추론할수 있는 수준의 간결함을 유지
  * 추상화 : 시스템의 추상적인 표현을 사용
  * 가시성 : 시스템이 포함해야 하는 요소들을 명확히 표현
  * 관점모형 : 다양한 이해 당사자의 관심사에 따른 모형 제시
  * 의사소통 수단 : 이해 당사자간의 월활한 의사소통 수단으로 활용
* 소프트웨어 아키텍처 프레임워크 구성요소
  * 아키텍처 명세서 : 아기텍처를 기록하기 위한 산출물
  * 이해 관계자 : 소프트웨어 시스템개발에 관련된 모든 사람과 조직
  * 관심사 : 이해관계자들의 다양한 요구사항과 관점을 반영한다
  * 관점 : 서로 다른 역활이나 책임에 따른 시스템에 대한 서로 다른 관점을 제시한다.
  * 뷰 : 이해 관계자들의 견해로부터 전체 시스템을 표현한다.
* 소프트웨어 아키텍처 4+1 뷰
  * 목적 : 고객의 요구사항을 정리한 시나리오를 다양한 관점에서 분석하고 표현한다.
  * 적용 : 복잡한 소프트웨어 아키텍처를 여러 이해 관계자가 이해할수 있도록 한다.
  * 구성
    * 논리적 관점 : 분석사/설계자 클래스나 컴포넌트의 종류와 관계
    * 구현 관점 : 프로그래머 서브시스템의 모듈 구조와 관계
    * 프로세스 관점 : 시스템 통합자 시스템의 성능, 확장성, 효율
    * 배치 관점 : 시스템 엔지니어 시스템의 구성
    * 유스케이스 관점 : 사용자 기능
* 4+1 구성요소
  * 논리뷰
    * 시스템의 기능적 요구사항을 표현
    * 최종 사용자에게 제공되는 기능을 나타냄
  * 구현뷰
    * 소프트웨어 모듈의 구성과 개발 관점을 반영
    * 컴포넌트 다어이그램으로 구현을 표현
  * 프로세스 뷰
    * 프로그램 실행시의 시스템을 표현
    * 동시성, 분산 처리, 시스템 통합등의 동적인 측면을 중점적으로 다룬다
  * 배치 뷰
    * 시스템의 물리적 배치와 네트워크 연결을 표현
  * 유스케이스뷰
    * 아키텍처 설계 및 검즈을 주도한다.
    * 유스케이스 다이어그램을 사용하여 다른 뷰를 검증한다.
* 소프트웨어 아키텍처 품질 속성
  * 정확성 : 사용자가 요구한 기능을 정확히 수행해야 한다.
  * 신뢰성 : 오차나 오류없이 기능이 안정적으로 동작해야 한다.
  * 효율성 : 자원을 적절학게 활요하여 기능을 수행해야 한다.
  * 무결성 : 자료는 인가된 사용자만이 변경 할수 있어야 한다.
  * 사용용이성 : 사용자가 쉽게ㅐ 배우고 사용할수 있어야 한다.
  * 유지 보수성 : 오류 수정및 변경이 용이해야 한다.
  * 시험용이성 : 테스트를 수행하기 용이해야 한다.
  * 유연성 : 새로운 요구사항을 쉽게 적용할수 있어야 한다.
  * 이식성 : 다양한 플랫폼 및 하드웨어 에서 운영이 가능해야 한다.
  * 재사용성 : 다른 목적으로도 사용하기 용이해야 한다.
  * 상호 운용성 : 다른 소프트웨어와 상호 작용이 용이해야 한다.
  * 확장성 : 시스템이 증가하는 부하에 대응할수 있어야 한다.
  * 보안 : 소프트웨어가 데이터 보안 및 개인정보 보호 기준을 충족해야 한다.

### 소프트웨어 아키텍처 패턴

* 소프트웨어 아키텍처 패턴 개념
  * 정의 : 재사용 가능한 소프트웨어 아키텍처의 해결책으로 공통적인 설계 문제에 대한 일반적인 접근 방법 제시
  * 목적 : 소프트웨어 개발 과정에서 발생할수 있는 다양한 문제를 해결한다.
  * 적용분야 
    * 컴퓨터 하드웨어 성능 최적화
    * 비즈니스 위험 최소화
    * 고가용성 및 확장성 확보
* 소프트웨어 아키텍처 패턴의 중요성
  * 재사용성 : 이미 검증된 설계 방식을 재사용함으로써 시간과 비용을 절감
  * 표준화 : 아키텍처 패턴을 사용하면 표준화된 방식으로 소프트웨어를 설계할수 있다.
  * 개발 효율성 : 일반적인 문제에 대한 해결책을 제공하여 개발 과정을 가속화 한다.
  * 문서화 : 아키텍처 패턴은 문서화 되어 있으며, 이를 통해 소프트웨어의 구조를 쉽게 이해할수 있다.
* 소프트웨어 아키텍처 패턴 종류
  * 계층화 패턴
    * 정의 : 소프트웨어를 여러 계층으로 구분하여 각 계층이 하위 계층의 기능을 사용하도록 하는 구조
    * 적용 : OSI 7계층, TCP/IP 4계층 등 네트워크 프로토콜 스택에서 널리 사용
    * 장점 : 계층간의 독립성으로 인해 유지보수와 업그레이드 용이
  * 클라이언트-서버패턴
    * 정의 : 서버가 여러 클라이언트에 서비스를 제공하는 구조
    * 적용 : 대부분의 웹 애플리케이션과 데이터베이스 시스템에서 사용
    * 장점 : 중앙 집중식 데이터 관리와 자원의 효율적 활용이 가능
  * 마스터-슬레이브패턴
    * 정의 : 마스터 컴포넌트가 작업을 여러 슬레이브에 분산시키고, 슬레이브의 처리 결과를 종합하는 구조
    * 적용 : 병렬 컴퓨팅 고성능 컴퓨팅 환경에서 사용
    * 장점 : 복잡한 작업을 여러 컴포넌트가 분담하여 처리 속도 향상이 가능
  * 파이프-필터패턴
    * 정의 : 데이터 스트림 처리 시스템에서 필터 컴포넌트가 각 단계의 처리를 수행하고 파이프를 통해 결과를 전달하는 구조
    * 적용 : Unix 쉘스크립트 및 데이터 스트림 처리 시스템에서 사용
    * 장점 : 각 필터의 독립적인 처리로 시스템의 확장성과 재사용성이 높다
  * 브로커 패턴
    * 적용 : 분산 시스템에서 컴포넌트간의 통신을 중재하는 브로커 컴포넌트를 사용
    * 기능 : 브로커는 서비스 요청을 수신하고 적절한 서비스 제공자에게 전달한다.
    * 장점 : 시스템의 유연성과 확장성을 증진한다.
  * 피어투피어 패턴
    * 정의 : 모든 컴포넌트가 서버와 클라이언트의 역활을 동시에 수행
    * 적용 : 파일 공유 시스템등에서 사용
    * 장점 : 중앙 집중식 서버에 의존하지 않는 분산 네트워크 구조를 가능하게 한다.
  * 이벤트 버스 패턴
    * 적용 : 이벤트 버스를 통해 메시지를 발행하고 리스너가 이를 구독하는 구조
    * 사용예 : 알림시스템, 메시징 시스템등에서 사용
    * 장점 : 이벤트 기반의 비동기 통신을 가능하게 한다.
  * 모델-뷰-컨트롤러 패턴
    * 구성 : 모델, 뷰, 컨트롤러 로 구성
    * 적용 : 웹 애플리케이션, GUI 기반 애플리케이션 등에서 널리 사용
    * 장점 : 각 컴포넌트의 독립성으로 인해 재사용성과 확장성이 높다
  * 블랙보드 패턴
    * 적용 : 복잡하고 명확한 해결 전략이 정의되지 않은 문제에 사용
    * 기능 : 여러 컴포넌트가 공유하는 중앙 정보 저장소(블랙보드)를 통해 협업한다.
  * 인터프리터 패턴
    * 적용 : 특정 프로그래밍 언어의 해석과 실행을 위한 컴포넌트 설계에 사용
    * 목적 : 언어의 문법을 정의하고 이를 해석하여 실행한다.
  
-----------------------------

## UML

### UML(Unified Modeling Language)

* UML 개념
  * 소프트웨어 시스템을 시각화 및 문서화 하고 소프트웨어 시스템의 구조와 동작을 명세하는 표준화된 모델링 언어
* UML 특징
  * 가시화 언어 : 다양한 다이어그램을 통해 시스템의 구조와 동작을 시각적으로 표현하며, 복잡한 시스템을 이해하기 쉽게한다. 
  * 명세화 언어 : 표준화된 언어로 시스템의 요구사항과 기능을 명세하는데 사용된다.
  * 구축 언어 : 설계와 구현에 도움이 되는 도구로, 특히 객체 지향 소프트웨어 개발에서 중요한 역활을 한다.
  * 문서화 언어 : 시스템의 기능, 구조, 동작 등을 표준화된 형태로 문서화 하여 개발 과정에서의 커뮤니케이션을 개선하고 유지보수를 돕는다.
* UML 구성요소
  * 사물
    * 구조사물 : 시스템의 개념적 물리적 요소(클래스, 유스케이스, 컴포넌트)
    * 행동사물 : 시간과 공간에 따른 요소들의 행위(상호작용, 상태머신)
    * 그룹사물 : 요소들을 그룹으로 묶은것(패키지)
    * 주해사물 : 부가적 설명이나 제약조건(주석, 노트)
  * 관계
    * 일반화 관계(상속)
      * 한 클래스가 다른 클래스를 포함하는 상위 개념일때의 개념
      * 객체 지향 개념에서는 일반화 관계를 상속 관계라고 한다.
    * 연관관계
      * 2개이상 사물이 서로 관련된 관계
      * 한 클래스가 다른 클래스에 제공하는 기능을 사용할때 표시
    * 의존관계
      * 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할때 표시
      * 연관관계와 차이점은 두 클래스의 관계가 한 메서드를 실행하는동안과 같이 매우 짧은 시간만 유지
      * 한클래스의 명세가 바뀌면 다른 클래스에 영향을 줌
      * 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용
    * 실체화 관계
      * 인터페이스를 구현받아 추상 메서드를 오버라이딩 하는것을 의미
      * 한객체가 다른 객체에게 오퍼레이션을 수행하도록 지정
    * 집합관계 - 집약관계(Aggregation)
      * 한객체가 다른 객체를 소유하는 'has a' 관계
      * 전체 객체의 라이프타임과 ㅜㅂ분 객체의 라이프 타임은 독립적
      * 전체 객체가 사라진다 해도 부분 객체는 사라지지 않음
    * 집합관계 - 합성관계(Composition)
      * 부분 객체가 전체 객체에 속하는 관계로 긴밀한 필수적 관계 
      * 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 의존적
      * 전체 객체가 없어지면 부분 객체도 없어짐
  * 다이어그램
    * 구조다이어그램
      * 클래스다이어그램
        * 시스템 클래스와 이들간의 관계들 표현
        * 시스템 내의 데이터 구조와 클래스간의 상속, 연관, 의존성등을 나타낸다.
      * 객체 다이어그램
        * 시스템 내의 객체와 이들간의 관계를 표현
        * 특정 시점에서 시스템의 인스턴스를 시각화 한다.
      * 컴포넌트 다이어그램
        * 시스템의 물리적 구조, 즉 컴포넌트와 그 상화작용을 표현
        * 소프트웨어 컴포넌트, 인터페이스, 의존성 등을 나타낸다.
      * 배치 다이어그램
        * 시스템의 물리적 배치와 구성요소들 간의 관계를 표현
        * 하드웨어, 네트워크, 소프트웨어 구성요소의 배치를 시각화한다.
      * 복함체 구조 다이어그램
        * 시스템 내의 복합 구조를 표현
      * 패키지 다이어그램
        * 시스템의 패키지와 이들간의 관계를 패키지 한다.
    * 행위 다이어그램
      * 유스케이스 다이어그램
        * 시스템의 기능과 사용자간의 상화작용을 표현
      * 순차 다이어그램
        * 객체간의 상호작용을 시간 순서에 따라 표현
      * 커뮤니케이션 다이어그램
        * 객체간의 상호작용을 객체들간의 관계와 통신에 중점을 둔다
      * 상태 다이어그램
        * 객체의 생명주기 동안의 상태 변화를 표현, 객체 외부 또는 내부 이벤트에 대한 반응을 나타낸다.
      * 활동 다이어그램
        * 시스템의 프로세스 또는 워크플로 표현
      * 상호작용 다이어그램
        * 시스템의 상호 작용을 하나의 고수준 워크플로우로 표현
      * 타이밍 다이어그램
        * 객체의 행동과 시간에 따른 상호작용을 표현

### 주요 다이어그램

* 클래스 다이어그램
  * 자기만의 속성과 일정한 행동으로 구성
  * 여러개의 클래스들은 서로 연관이나 상속, 의존관계등으로 서로간의 상호작용을 표현
  * 접근제한자
    * (-) : private : 클래스 내부에서만 접근 가능
    * (#) : protected : 상속받은 클래스에서 접근 가능
    * (+) : public : 모든 클래스에서 접근 가능
* 유스케이스 다이어그램
  * 시스템과 사용자의 상호작용을 다이어그램으로 표현
  * 사용자의 관점에서 시스템의 서비스 혹은 기능 및 그와 관련한 외부 요소를 보여준다.
  * 프로젝트에 대한 요구사항을 정의하고 세부 기능을 분석한다.
  * 구성요소
    * 시스템 : 만들고자 하는 프로그램 명칭
    * 액터 : 시스템의 외부에 있고 시스템과 상호작용을 사람, 시스템으로 표현
    * 유스케이스 : 사용자 입장에서 바라본 시스템의 기능
    * 관계 : 액터와 유스케이스 사이의 의미있는 관계
      * 연관관계 : 유스케이스와 액터간 상호작용이 있음을 표현
        * 유스케이스와 액터를 실선으로 표현
      * 포함관계 : 유스케이스를 수행할때 반드시 실행되어야 할 경우
        * Include 로 표현
      * 확장관계 : 유스케이스를 수행할때 특정조건에 따라 확장 기능을 유스케이스를 수행하는 경우
        * Extend 로 표현
      * 일반화관계 : 유스케이스간의 상속관계
* 시퀀스 다이어그램
  * 객체간의 상호작용 메시지 시퀀스를 시간의 흐름에 따라 나타내는 다이어그램
  * 구성요소
    * 객체와 생명선
      * 객체는 직사각형으로 표현
      * 라이프라인은 객체에서 이러지는 점선으로 표현
      * 점선은 위에서 아래로 갈수로 시간경과를 의미
    * 활성박스
      * 생명선상에서 기다란 직사각형으로 표현
      * 현재 객체가 어떤 활동을 하고 있음을 의미
    * 메시지
      * 인스턴스간 주고받은 데이터
      * 동기메시지, 비동기 메시지, 자체메시지, 반환메시지
* 상태 다이어그램
  * 한객체의 상태 변화를 나타내는 다이어그램

-------------------------------------------

## 화면 설계

### UI(User Interface) 개념

* UI 개념
  * 컴퓨터, 웹사이트, 시스템등의 정보기기와 사용자간의 상호작용을 가능하게 하는 매개체
  * UI 의 구성요소에는 디스플레이 화면, 아이콘, 검색창, 키보드, 문자, 색상, 폰트들이 포한된다.
  * UI 의 핵심은 사용자가 쉽고 편리하게 이용할수 있는 직관적이고 보편적인  디자인이다.
  * 좋은 UI 디자인은 사용자가 최소한의 노력으로 최대한의 효율을 얻을수 있도록 한다.
* UX 개념
  * 사용자가 UI 를통해 경험하는 모든것을 포함
  * 사용자의 만족감, 불편함, 그리고 이용과정에서의 감정과 행동을 모두 포함한다.
  * UX 디자인의 목표는 사용자 불만족을 최소화 하고 편리한 사용경험을 제공하는것
  * UX 는 단순히 제품의 기능적인 측면을 넘어서 사용자의 감정, 인식, 반응등 포괄적인 경험을 고려한다.
* UI 유형
  * CLI(Command Line Interface)
    * 텍스트 명령어를 통해 컴퓨터와 상호작용하는 인터페이스
  * GUI(Graphical User Interface)
    * 그래픽, 텍스트 를 사용하여 사용자와 컴퓨터간의 상호작용을 가능하게 하는 인터페이스
  * NUI(Natural User Interface)
    * 사용자의 자연스러운 동작을 인식하여 상호작용하는 인터페이스
  * OUI(Organic User Interface)
    * 현실의 모든것이 입력 및 출력 장치로 사용될수 있는 인터페이스
  * VUI(Voice User Interface)
    * 음성을 통해 사용자와 컴퓨터간의 상호작용을 가능하게 하는 인터페이스
  * ARUI(Augmented Reality User Interface)
    * 증강현실을 통해 사용자와 컴퓨터간의 상호작용을 가능하게 하는 인터페이스
* 요구사항 구분
  * 기능적 요구사항
    * 시스템이 제공해야 하는 기능에대한 요구사항
    * 입력, 출력, 데이터, 연산에 관한 요구사항
  * 비기능적 요구사항
    * 사용성, 효울성, 신뢰성, 유지보수성, 재사용성등 품질에 관한 요구사항
    * 플랫폼, 사용기술 등 시스템 환경에 관한 요구사항
    * 비용, 일정등 프로젝트 계획에 관한 요구사항
* 설계절차
  * UI 개발 목표 및 범위 수립 -> UI 전략 수립 -> 사용자 요구사항 분석 -> UI 상세 설계 -> 구현 -> 테스트
  * 개발 목표 및 범위 수립
    * 프로젝트의 UI 부문에 대한 목표와 범위를 설정
  * 전략 수립
    * 사용자 및 시장 조사를 통해 UI UX 전략을 개
  * 사용자 요구사항 분석
    * 사용자 조사 결과를 바탕으 필요한 요구사항을 파악하고 분석, 프로토 타입
  * UI 상세 설계
    * UI 기능, 화면구조, 상호 작용 흐름 및 예외처리에 대한 상세 설계를 수행
  * 구현
    * HTML, CSS, JavaScript 등을 사용하여 UI 를 구현
  * 테스트
    * UI 의 사용성을 검증
* UI 설계 원칙
  * 직관성 : 누구나 쉽게 이해하고 사용할수 있어야 한다.
  * 유효성 : 사용자의 목적을 정확하게 달성해야 한다.
  * 학습성 : 누구나 쉽게 배우고 익힐수 있어야 한다.
  * 유연성 : 사용자의 요구사항을 최대한 수용하며, 오류를 최소화 한다.
* UI 설계 도구
  * 와이어프레임
    * 웹사이트나 앱의 기본 구조와 레이아웃을 나타내는 초기 설계 도구
  * 스토리 보드
    * 서비스나 제품의 시나리오 흐름을 시각적으 로 나타내는 도구
  * 프로토타입
    * 실제 서비스와 유사하게 동작하는 모델
  * 목업
    * 와이어프레임보다 구체적이며 실제 화면과 유사한 정적 디자인
  * 유스케이스
    * 사용자 관점에서 시스템이 어떻게 동작하는지 나타내는 도구

### 감성 공학

* 감성공학 개념
  * 인간의 감성을 물리적 설계 요소로 번역하고 구현하는 기술
  * 요소화 -> 형상화 -> 구현 -> 생산
* 제품과 관련된 인간의 감성
  * 감각적 감성 : 제품 외관, 색상, 디자인 등 외적 특성에 대한 감성
  * 기능적 감성 : 제품의 기능, 성능, 편의성 등 기능적 특성에 대한 감성
  * 문화적 감성 : 개인이 속한 사회나 문화에 대한 감성
* 감성 공학의 접근 방법
  * 1류 접근 방법 : 의미 미분법을 사용하여 제품에 대한 이미지를 분석하고 이를 디자인 요소와 연결
  * 2류 접근 방법 : 문화적 감성을 반영하되, 평가자들의 생활 식 등을 고려한 방법
  * 3루 접근 방법 : 특정 제품을 사용하여 감성을 정량화 하고 이를 제품 설계에 응용 하는 방법

----------------------------------

## UI 구현

### 화면 레이아웃 구성

* 레이아웃 개념
  * 특정공간에 여러 구성 요소를 보기 좋고 효과적으로 배치하는작업
* 레이아웃 작성 방법
  * div
  * span
  * table
  * 시멘틱 태그
* HTML
  * 월드 오아드웹을 통해 정보를 표현하기 위한 마크업 언어
  * 웹페이지의 기본 구조
  * 특징
    * 멀티미디어 : 플러그인 없이 동영상, 음악, 웹 을 직접 재생항수 있다.
    * 그래픽 : SVG, CANVAS 를 이용하여 다양한 2차원 그래픽을 표현
    * 통신 : 웹 소켓을 통해 실시간 양방향 통신이 가능
    * 지리적 위치 : GPS
    * 오프라인 : 로컬스토리지와 오프라인 캐시를 통해 오프라인에서도 작업이 가능
  * 시멘틱 요소
    * header : 헤더 영역
    * nav : 네비게이션 영역
    * section : 본문 영역
    * article : 본문 내용 영역
    * aside : 본문 외의 영역
    * footer : 푸터 영역
  * input
    * 텍스트 입력
    * 비밀번호 입력
    * 라디오 버튼
    * 체크박스
    * 파일선택
    * 선택입력
    * 버튼
    * 전송
    * 필드셋
* CSS
  * 웹문서의 디자인 요소 즉 색상, 크기, 이미지 크기 및 위치, 배치 방법등을 담당
  * 특징
    * 디자인 분리
    * 재사용성
    * 동적디자인
    * 반응형 웹
* JavaScript
  * 모질라 재단에 의해 개발된 프로토타입 기반의 스크립트 언어
  * 클라이언트 측에서 웹페이지의 동적 동작을 담당
  * 특징
    * 스크립트 언어
    * 이벤트중심
    * 프로토타입기단 객체지향
    * 동적 형변환
    * 다양한 환경에서의 사용
  * 프레임워크
    * 리액트
    * Vue.js
    * 앵귤러
  * Ajax
    * 비동기적인 웹 애플리케이션 제작을 위한 웹개발 기법
    * 웹 페이지의 일부만을 독립적으로 업데이트할수 있어, 페이지 전체를 새로 고칠 필요 없이 웹 애플리케이션의 속도와 사용자 경험을 향상 시킨다.

### UI 관련 용어

* 웹표준
  * 월드 와이드 웹에서 사용되는 공식 표준이나 기술 규격
  * 웹 표준을 따르는 것은 웹페이지의 호환성, 접근성 효율성을 보장하는데 중요
* 웹 호환성
  * 다양한 하드웨어 및 소프트웨어 환경에서도 웹서비스다 동일하게 작동하는 능력
* 웹 접근성
  * 장애인 및 고령자를 포함한 모든 사용자가 웹사이트에 쉽게 접근하고 이용할수 있도록 하는것
* 반응형 웹
  * PC, 모바일 등 다양한 디바이스에서 화면 크기에 맞춰 내용을 적절하게 표시하는 웹 디자인 방식
* 인포그래픽
  * 정보를 시각적으로 표현한 그래픽
* 브랜드 아이덴티티
  * 기업이나 단체의 정체성과 이미지를 나타내는 것
* 내비게이션
  * 웹사이트에서 사용자가 원하는 정보를 찾아가는 과정
* 아코디언
  * 특정 영역을 접었다 펼치는 UI
* 플레이스 홀더
  * 입력 필드에 예사니 안내문구를 제공하는 간단한 텍스트
* 필터링
  * 웹사이트에서 원하지 않는 데이터를 제외하거나 특정 데이터를 선택해서 보여주는것
* 입력 폼
  * 사용자가 정보를 입력하고 웹서버로 전송할수있게 하는 웹페이지의 일부
* 입력 필드
  * 사용자가 데이터를 입력하거나 선택할있는 인터페이스 요소
* 썸네일
  * 큰 이미지를 축소하여 표시한 작은 버전의 이미지
* 레이블
  * 입력 폼의 각 입력 필드를 식별하기 위해 사용되는 텍스트
* 대체 텍스트
  * 이미지나 그래픽 콘텐츠를 대신하여 제공되는 텍스트

-----------------------------

## 서버 프로그램 구현

### 개발 환경 구축

* 웹서버(WEB)
  * 클라이언트에게 정적파일을 제공하는 서버
  * 대표적 서버는 Apache, Nginx, IIS, GWS
* 웹 애플리케이션 서버(WAS)
  * 동적인 웹서비스를 제공하기 위한 서버
  * 대표적 서버는 Tomcat, Jeus, WebLogic, WebSphere
* 데이터베이스(DBMS)
  * 데이터의 저장관리를 위한 서버로 다양한 데이터베이스 소프트웨어가 설치될수있다
  * Oracle, MySQL, MariaDB, PostgreSQL, MongoDB, MS-SQL
* 파일서버
  * 사용자 파일을 저장하고 공유하는데 사용되는 서버
  * 네트워크를 통한 파일의 접근 및 관리를 용이하게 한다.
* Load Balancer
  * 여러대의 서버가 있을 경우 이들 사이에 네트워크 요청을 효율적으로 분배하는 장치
  * 분배방식
    * random : 요청을 랜덤으로 분배한다.
    * least loaded : 가장 적은 부하를 가진 서버에 요청을 분배한다.
    * round robin : 순차적으로 요청을 분배한다.
* CDN(Content Delivery Network)
  * 대용량 콘텐츠를 빠르게 제공하기 위해 사용자에게 물리적으로 가까운 위치에 있는서버 네트워크를 사용
  * 사용자가 원격 웹 서버보다 가까운 CDN 서버로부터 콘텐츠를 빠르게 받을수 있다.
* 시스템아키텍처 고려사항
  * 확장성 : 시스템이 사용자 수의 증가나 데이터양의 증가에 따라 적절하게 확장될수 있는 능력
  * 성능 : 시스템이 사용자의 요청을 정확하고 신속하게 처리하는 능력
  * 응답시간 : 사용자의 요청에 대해 시스템이 응답까지 걸리는 시간
  * 처리량 : 주어진 시간동안 시스템이 처리할수 있는 요청의 양
  * 접근성 : 사용자가 언제 어디서나 시스템에 접근해 요청을 보내고 응답을 받을수 있는 능력
  * 일관성 : 사용자의 요청이 시스템에 정확하게 반영되어 일정한 결과를 반환해야 한다.
  * 보안 : 데이터 암호화, 접근 제어, 보안 프로토콜의 적용등을 고려해야 한다.

### 개발 소트웨어 환경

* 시스템 소프트웨어
  * 운영체제
    * 컴퓨터의 하드웨어 운영을 관리하는 소프트웨어
    * 사용자와 하드 웨어 사이에서 인터페이스 역활들 하며 시스템 자원을 관리한다.
    * 대표적 운영체제 Windows, Linux, Unix, Mac OS
  * JVM(Jave Virtual Machine)
    * 자바 관련 프로그램을 실행하기 위한 환경을 제공
    * JVM 을 통해 자바 애플리케이션은 다양한 운영체제에서 호환 가능하게 실행된다.
    * 모든 개발자가 동일한 버전의 JVM 을 사용하는것이 일관된 개발 및 실행 환경을 보장한다.
  * Web Server
    * 클라이언트에게 정적파일을 제공하는 서버
    * 대표적 서버는 Apache, Nginx, IIS, GWS
  * WAS(Web Application Server)
    * 동적인 웹서비스를 제공하기 위한 미들웨어
    * 대표적 서버는 Tomcat, Jeus, WebLogic, WebSphere
  * DBMS(Database Management System)
    * 데이터의 저장관리를 위한 서버로 다양한 데이터베이스 소프트웨어가 설치될수있다
    * Oracle, MySQL, MariaDB, PostgreSQL, MongoDB, MS-SQL
* 요구사항 관리 도구
  * 고객의 요구사항을 수집, 분석, 추적하는데 사용
  * JFeature, JRequisite, OSRMT, Trello, JIRA
* 설계 모델링 도구
  * 소프트웨어 구조와 기능을 시각적으로 표현하고 설계하는데 사용
  * UML 지원으로 복잡한 시스템을 명확하게 모델링할수 있다
  * ArgoUML, StarUML, DBDesigner
* 구현 도구
  * 소프트웨어 개발 언어를 이용한 구현 및 개발 지원
  * Eclipse, IntelliJ, Visual Studio
* 테스트 도구
  * 소프트웨어의 품질을 검증하고 테스트하는데 사용
  * JUnit, CppUnit, SpringTest, JMeter
* 형상관리 도구
  * 소프트웨어의 변경사항을 관리하고 추적하는데 사용
  * Git, SVN, CVS
* 협업도구
  * 팀원간의 소통과 협업을 용이하게 하는 도구
  * Slack, Microsoft Teams
* 배포도구
  * 소프트웨어의 빌드, 테스트, 배포를 자동화 하는 도구
  * Jenkins, Travis CI

### IDE(Integrated Development Environment)

* 개념
  * 소프트웨어 개발에 필요한 다양한 기능을 하나의 프로그램 내에서 제공하는 소프트웨어
* 기능
  * 텍스트에디터
  * 컴파일러
  * 디버거
  * 배포
  * 플러그인
* 종류
  * Eclipse
  * IntelliJ
  * Visual Studio
  * Xcode
* 도구 선정시 고려사항
  * 적정성
  * 효율성
  * 이식성
  * 친밀성
  * 범용성

### 협업도구

* 개념
  * 여러 사용자가 각자의 작업 환경에서 통합된 프로젝트를 동시에 수행할수 있도록 지원하는 소프트웨어
* 기능
  * 전사관리
  * 프로젝트관리
  * 드라이브 공간
  * 문서공유
  * 커뮤니케이션
  * 다국어 지원
  * 타 협업 툴 연동
* 분류
  * SNS 형
  * 프로젝트 관리형
  * 통합형
* 도입이유
  * 팀간 의사소통의 불편함
  * 프로젝트 관리의 어려움
  * 자료공유와 업무 현황의 불투명성
* 도입 프로세스
  * 문제 정의
  * 솔루션 및 기대효과 정의
  * 협업도구 분석
  * 협업 도구 최종 선정

### 형상관리 도구

* 개념
  * 소프트웨어 개발 과정에서 발생하는 모든 변경 사항을 통제하고 관리하는 방법
* 필요성
  * 소스코드를 이전상태로 되돌리수 있는 능력
  * 각 변경점에 대한 이력을 확인하여 프로젝트 진행 상황 명확히 파악
* 변경 관리
  * 소스코드의 변경 사항을 관리 하며 문서의 변경 이력과 복원 기능 제공
* 버전관리
  * 소프트웨어 변경을 효과적으로 관리하며 체크인/체크아웃, 릴리즈, 퍼블리싱 등을 버전으로 관리
* 형상관리
  * 변경관리와 버전관리를 포함하며 프로젝트 진행 상황, 빌드, 릴리즈 까지 전체적으로 관리하는 통합 시스템이다.
* 관리 대상
  * 소스코드
  * 문서
  * 데이터베이스 스키마
  * 설정파일
  * 이미지
* 절차
  * 식별 -> 통제 -> 감사 -> 기록
  * 식별 : 관리애햐 할 항목을 구분하고, 번호나 태그를 부여
  * 통제 : 형상통제 위원회의 승인을 통한 변경 통제가 이루어져야 한다. 변경 요청을 검토하고 승인하여 현재의 기준선에 반영한다.
  * 감사 : 변경이 계획에 따라 적절하게 이루어졌는지 검토
  * 기록 : 변경사항을 문서화하고, 변경사항에 대한 이력을 기록

### 버전 관리 도구

* 개념
  * 소스코드와 문서등의 디지털 콘텐츠에 대한 여러 버전을 관리
* 관리 유형
  * 공유폴더방식(RCS, SCCS)
    * 파일을 공유 폴더에 저장하고 담당자가 에러 체크와 정상 작동 여부를 확인
  * 클라이언트/서버방식(CVS, SVN)
    * 소스코드 변경시 소스코드를 서버에 업로드하고 다른 개발자가 다운로드하여 작업
  * 분산 저장소 방식(Git)
    * 중앙 저장소와 로컬 저장소가 별도로 존재하며, 로컬에서 작업후 중앙 저장소에 반영하는 방식이다.
    * 개발자는 자신만의 로컬 저장소애서 독립적으로 작업하고 완료후 중앙 저장소에 변경사항을 반영한다.
* CVS
  * 오래 사용된 형상 관리 도구로 다양한 운영체제를 지원
  * 중앙에 위치한 저장소에 파일을 저장하며 인가된 사용자가 파일에 접근할수 있다.
  * 파일의 변경 이력을 보존하여 과거 이력을 확인할수 있다.
  * 커밋중 오류 발생시 롤밸 안됨
  * 느린속도와 파일/디렉터리 변경의 불편함이 단점
* SVN
  * CVS 의 단점을 보완한 버전 관리 도구
  * 최초 1회 파일 원본을 저장 후 변경사항만을 기록
  * Trunk, Branches, Tas 구조로 형상 관리를 수행하며 원하는 시점으로 복구 가능
  * 커밋실패시 롤백이 가능, 형상 관리가 보다 체계적
* Git
  * 리누스 토발즈에 의해 개발된 분산 버전 관리 시스템
  * 로컬에서 빠른 성능과 분산 환경 코딩에 최적화
  * 원격 저장소에 장애가 있어도 로컬에서 버전관리 가능
  * 다양한 브랜치를 생성하고 관리할수 있어 현대적인 개발 환경에 적합
* Clear Case
  * IBM 에서 개발된 유료 버전 관리 도구
* BitKeeper
  * SVN 과 비슷한 중앙 통제 방식을 사용하며 대규모 프로젝트에서 빠른 속도를 낼수 있다
* RCS
  * 소스파일의 수정을 한 사람만 허용하여 다수의 사용자가 동시에 파일을 수전할수 없도록 하는 버전 컨트롤 시스템
* 주요 용어
  * Repository : 저장소
  * checkout : 저장소에서 로컬로 프로젝트 복사
  * commit : 로컬의 변경 내용을 저장소에 저장
  * update : 저장소에 있는 내용을 로컬에 반영
  * add : 로컬에서 새로운 파일이 추가 되었을때 저장소에 등록
  * trunk : 루트 프로젝트
  * Branch : 루트 프로젝트에서 파생된 프로젝트
  * Merge : 브랜치에서 변경된 내용을 루트 프로젝트와 합침
  * Diff : 파일을 비교

### 빌드 도구

* 개념
  * 소스코드 파일들을 컴파일 하고 다른 필요한 과정들을 거쳐 실행 가능한 소프트웨어로 변환하는 일련의 과정
  * 컴파일 링킹 패키징 등이 빌드 과정에 포함된다.
  * 빌드 과정을 자동화 하고 최적화하는 도구를 빌드 도구라고 한다.
* 특징
  * 빌드, 테스트, 배포 등을 자동으로 수행한다.
  * 소스코드를 컴파일 하고 테스트 정적 분석등을 수행하여 실행 가능한 애플리케이션을 자동으로 생성 한다.
  * 계속해서 늘어나는 라이브러리 자동 추가 및 관리
  * 개발 및 배포 과정의 일관성을 보장하며 오류의 가능성을 줄인다.
* 빌드
  * 개발자가 소스코드를 저장소에 커밋하면 변경사항이 통합환경에 자동으로 통합된다.
* 테스트
  * Jenkins, Ansible 등의 도구가 새 코드를 인식하여 자동으로 일련의 테스트를 수행
* 배포
  * 테스트를 통과한 소프트웨어는 운영환경에 자동으로 배포되어 최종 사용자에게 제공
* 종류
  * Make
    * Unix 환경에서 사용되는 빌드 도구
  * Ant
    * 자바 기반 빌드 도구로 XML 기반 빌드 스크립트 사용
  * Maven
    * 의존성 관리와 프로젝트 라이프 사이클 관리에 강점을 가진 Java 기반 빌드 도구
  * Jenkins
    * Java 기반의 오픈소스 지속적 통합 서비스 도구
    * 빌드, 테스트, 배포 과정을 자동화 하며, 다양한 플로그인을 지원
    * 서블릿 컨테이너에서 실행, SVN, Git 등 형상 관리 도구와 연동이 가능
    * 분산 빌드 환경을 지원하여 대규모 프로젝트에 적합
  * Gradle
    * Groovy 기반의 오픈 소스 빌드 자동화 도구
    * 안드로이드 앱 개발 뿐만 아니라 Java, C/C++, Python 등 다양한 프로젝트에 사용

---------------------------------------

## 개발 프레임워크

### 프레임워크

* 개념
  * 소프트웨어 개발에 필요한 공통적인 구성요소와 아키텍처를 일반화 하여 제공하는 반제품 형태의 소프트 웨어
  * 개발자가 소프트웨어를 더 쉽고 빠르게 개발할수 있도록 기본적인 구조와 필수 기능을 제공
  * 클래스와 인터페이스의 집합으로 구성되며 소프트웨어 개발의 템플릿 역활을 한다.
* 특징
  * 모듈화 : 캡슐화를 통해 모듈화를 강화하고 설계와 구현의 변경에 따른 영향을 최소화
  * 재사용성 : 여러 애플리케이션에서 반복적으로 사용할수 있는 일반적인 컴포넌트를 제공함으로써 재사용성을 높인다.
  * 확장성 : 다형성을 활용하여 애플리케이션의 프레임워크 인터페이스를 확장할수 있다.
  * 제어의 역흐름 : 프레임워크가 애플리케이션의 흐름을 제어하며 애플리케이션이 수행해야할 메서드를결정한다.
* Java
  * 전자정부 표쥰 프레임워크
  * 스트럿츠
  * 스프링
* ORM 프레임워크
  * 아이바티스
  * 마이바티스
  * 하이버네이트
* 자바스크립트
  * Angular JS
  * ReactJS
  * ExtJs
* 프론트엔드
  * Bootstrap
  * Foundation
  * MDL
* 라이브러리
  * 컴퓨터 프로그램에서 자주 사용되는 루틴이나 리소스 등을 모아 놓은것
  * 재사용이 필요한 기능을 제공ㅎ기 위해 클래스나 함수의 형태로 구성됨
  * 라입러리는 애플리케이션의 특정 기능을지원하는 반면 프레임 워크는 전체적인 애플리케이션 구조를 제공
* API
  * 소프트웨어간의 인터페이스로 다른 소프트웨어 또는 서비스와 상호작용 하는데 사용된다
  * 운영체제나 프로그래밍 언어가 제공하는 기능을 응용 프로그램에서 사용할수 있도록 만든 인터페이스
  * 특징
    * 개발비용 감축
    * 반복작업 줄이기
    * 쉬운 유지 관리
    * 새로운 수익 채널 확대
    * 비즈니스 파이 확장

---------------------------------------

## 모듈 구현

### 단위 모듈 구현

* 개념
  * 소프트웨어를 기능 단위로 분해하여 개별적으로 구현하는 기법
  * 서브시스템, 서브루틴, 작업 단위 등으로 나누어 각 모듈이 독립적으로 활용될수 있게 한다.
  * 모듈은 작은 크기를 가지며 하나의 기능만 수행하는것이 이상적
  * 모듈의 크기가 작을수록 이해, 구현 밑 테으스가 용이
* 장점
  * 소프트웨어의 효율적인 관리및 성능 향상에 기여
* 효과적 모듈화
  * 결합도를 낮추고 응집도를 높여 모듈의 독립성 강화
* 원리
  * 단계적 분해
  * 추상화
  * 독립성
  * 정보은닉
  * 분할과 정보

### 결합도

* 개념
  * 모듈과 모듈간의 관련성/의존성 정도
  * 관련이 적을수록 모듈의 독립성이 높아 모듈간 영향이 적어진다.
  * 결합도가 낮을수록 잘 설계된 모듈
* 유형
  * 자료 결합도 : 모듈간의 인터페이소 값이 전달되는 경우
  * 스탬프 결합도 : 모듈간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우
  * 제어 결합도 : 단순 처리할 대상인 값만 전달디는게 아니라 어떻게 처리해야 한다는 제어 요소가 전달되는 경우
  * 외부 결합도 : 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조하는 경우
  * 공통 결합도 : 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우
  * 내용 결합도 : 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우

### 응집도

* 개념
  * 모듈 내부에서 구성 요소 간에 밀접한 관계를 맺고있는 정도
  * 응집도가 높을수록 필요한 요소들로 구성되어 있고 낮을 수록 관련이 적은 요소들로 구성
  * 응집도가 높을수록 잘 설계된 모듈
* 유형
  * 기능적 응집도 : 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우
  * 순차적 응집도 : 모듈 내에서 한 활동으로 부터 나온 출력 값을 다른 활동이 사용할 경우
  * 통신적 응집도 : 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우
  * 절차적 응집도 : 모듈이 다수의 관련 기능을 가질때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우
  * 시간적 응집도 : 연관된 기능이라기 보다는 특정 시간에 처리되어야 하는 활동 들을 한 모듈에서 처리 해야할 경우
  * 논리적 응집도 : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
  * 우연적 응집도 : 모듈 내부의 각 구성 요소들이 연관이 없을 경우

### 팬인(Fan-in)과 팬아웃(Fan-out)

* 개념
  * 모듈의 복잡도와 상호작용을 분석하는데 사용되는 지표
  * 시스템의 복잡도를 측정하고 이를 최적화 할수 있다.
  * 시스템 복잡도를 최적화 하기 위해서는 팬인은 높게 팬 아웃은 낮게 설정
* 팬인
  * 특정 모듈을 호출하거나 참조하는 상위 모듈의 수
  * 높은 팬인 값은 해당 모듈의 중요성이 나 재 사용성이 높음을 나타낸다
  * 설계시 팬인 값을 높게 유지하는것이 좋다
* 팬아웃
  * 특정 모듈이 호출하거나 참조하는 하위 모듈수
  * 높은 팬아웃 값은 해당 모듈이 여러 다른 모듈 들과의 상호 작용이 많음을 의미한다(복잡도 높음)
  * 설계시 팬아웃 값을 낮게 유지하는 것이 좋다

### 공통모듈 구현 순서

* 공토 모듈 구현
  * DTO/VO 구현 -> SQL 구현 -> DAO 구현 -> Service 구현 -> Controller 구현 -> View 구현
* DTO : 프로세스 사이에서 데이터를 전송하는 객체
* VO : 도메인에서 속성들을 묶어서 특정 값을 나타내는 객체
* DAO : 데이터베이스에 접근하는 객체
* Service : 비즈니스 로직을 처리하는 객체
* Controller : 사용자의 요청을 처리하고 응답을 제공하는 객체
* Anootation
  * 개념
    * 사전적으로 주석의 의미를 갖고있음
    * 자바코드에 주석처럼 달아 특수한 의미 부여
    * 컴파일 또는 런타임에 해석
  * 종류
    * @Controller : 컨트롤러 클래스에 사용되며 사용자의 요청을 처리하고 응답을 제공
    * @RequestMapping : 요청 URL과 매핑되는 메서드를 지정
    * @RequestParam : 요청 파라미터를 메서드의 파라미터로 전달
    * @RequestHeader : 요청 헤더를 메서드의 파라미터로 전달
    * @PathVariable : URL 경로의 일부를 메서드의 파라미터로 전달
    * @CookieValue : 쿠키 값을 메서드의 파라미터로 전달
    * @ModelAttribute : 모델 객체를 뷰에 전달
    * @ResponseBody : 메서드의 반환값을 응답 본문으로 전달
    * @RequestBody : 요청 본문을 메서드의 파라미터로 전달
    * @Repository : DAO 클래스에 사용되며 데이터베이스에 접근
    * @Service : 서비스 클래스에 사용되며 비즈니스 로직을 처리
    * @Scheduled : 주기적으로 메서드를 실행

---------------------------------------

## 서버 프로그램 구현

### 업무 프로세스

* 개념
  * 개인이나 조직이 자원을 입력하여 가치있는 산출물을 제공하는 일련의 활동
* 구성요소
  * 프로세스 책입자
  * 프로세스 맵
  * 프로세스 Task 정의서
  * 프로세스 성과지표
  * 프로세스 조직
  * 경영자의 리더십

### MVC 모델의 계층

* 프레젠테이션 계층
  * 사용자 인터페이스와 관련된 부분을 담당
  * 사용자가 시스템과 상호작용할수 있는 기능 및 부가 정보를 제공
* 제어 계층
  * 프레젠테이션 계층과 비즈니스 로직 계층간의 중간자 역활
  * 사용자 요청 분석, 적절한 비즈니스 로직 호출
* 비즈니스로직 계층
  * 애플리케이션의 핵심 업무 로직을 처리
  * 데이터의 적합성 검증, 트랜잭션 처리등을 포함
* 퍼시스턴스 계층
  * 데이터 관리와 관련된 모든 CRUD 작업을 처리
* 도메인 모델 계층
  * 실질적인 비즈니스 객체
  * DTO 를 사용하여 계층간 데이터 전달

### DBMS 접속 기술

* 개념
  * 프로그램에서 DVB 에 접근하여 DML 을 사용할수 있는 기술
  * 프로그램과 DB 간 연결을 가능하게 하는 인터페이스 제공
* 종류
  * 소켓통신
    * 응용 프로그램관 DBMS 간에 네트워크를 통해 데이터를 주고 받는 방식
    * DBMS 제공 업체가 통신 프로토콜을 공개하지 않는 경우가 많아 개발이 어렵다.
  * VenDer API
    * 각 DBMS 제공 업체에서 공개한 API 를 이용해 DBMS 와 통신하는 방식
  * JDBC(Java Database Connectivity)
    * 자바에서 DBMS 와 통신하기 위한 API
  * ODBC(Open Database Connectivity)
    * MS 에서 제공하는 DBMS 와 통신하기 위한 API

### ORM 프레임 워크

* 개념
  * 객체지향 프로그래밍과 관계형 데이터 베이스 간의 호환성 격차를 해결하기 위한 프로그래밍 기법
* 장점
  * 개발자가 비즈니스 로직에 더 집중할수 있도록 해준다
* 단점
  * 복잡한 쿼리나 특화된 데이터 베이스 기능을 사용하는 경우 ORM 제한때문에 구현이 어렵다
* 매핑기술
  * SQL Mapper
    * SQL 과 객체를 매핑하여 데이터 베이스에 접근하는 기술
    * MyBatis, iBatis, JDBC Templates
  * OR Mapper
    * 객체와 데이터 베이스를 매핑하여 데이터 베이스에 접근하는 기술
    * Hibernate, JPA

### 시큐어 코딩

* OWASP(The Open Web Application Security Project)
  * 오픈소스 웹 애플리케이션 보안 프로젝트
  * 웹 애플리케이션 보안 취약점 연구, 정보 노출및 악성 파일/스크립트 보안 취약점 해결
  * OWASP TOp 10 : 빈번하고 영향력 있는 웹 어플리케이션 취약점 상위 10가지 발표
* 시큐어 코딩 가이드
  * 개념
    * 패킹등 사이버 공격의 원인인 보안 취약점을 제거해 안전한 소프트웨어를개발하는 SW 개발 기법
    * 개발자의 실수나 논리적 오류로 인해 발생할수있는 문제점을 사전에 차단하여 대응하고자 하는것
  * 항목
    * 입력 데이터 검증 및 표현
      * 프로그램 입력 값에 대한 검증 누락이나 부적절한 검증, 데이터 형식 지정 오류 등으로 인한 보안 약점
    * 종류
      * SQL Injection : SQL 쿼리 삽입을 통한 데이터 베이스 정보를 열람 및 조작
      * XSS(Cross Site Scripting) : 사용자 측에서 실행되는 악의적 스크립트 삽입
      * 자원 삽입 : 외부 입력 값이 시스템 자원 접근 경로 또는 자원 경로 또는 자원 제어에 사용
      * 위험한 형식 파일 업로드 : 서버특에서 실행 가능한 스크립트 파일 업로드
      * 명령 삽입 : 운영체제 명령어 삽입(XQuery, XPath, LDAP 삽입)
      * 메모리 버퍼 오버프로 : 입력 값으로 인해 버퍼가 다른 메모리 공간 침범
  * 보안기능
    * 보안기능을 부적절하게 구현하는 경우 발생할수 있는 보안 약점
    * 종류
      * 적절한 인증 없이 중여 기능 허용 : 중요 정보 에 대한 접근데 적절한 인증 과정이 없을때
      * 부적절한 인가 : 중요 자원에 대한 외부 입력값을 포함한 문자열로 접근 가능할때 발생
      * 취약한 암호화 알고리즘 사용 : 안전하지 않은 알고리즘 사용
      * 하드코딩된 패스워드 : 소스코드 내에 비밀번호가 하드코딩되어 소스코드 유출시 노출될수 있음
      * 패스워드 평문 저장 : 계정 정보 탈취시 패스워드가 쉽게 노출될수 있음
      * 취약한 패스워드 허용 : 비밀번호 조합 규칙이 미흡하거나 길이가 충분하지 않을때 발생
  * 시간 및 상태
    * 동시 수행을 지원하는 병렬 시스템이나 하나 이상의 프로세스가 동작하는 환경에서 시간 및 상태를 부적절 하게 관리하여 발생할수 있는 보안 약점
    * 종류
      * 경쟁 조건
      * 종료되지 않는 반복문 또는 재귀함수
  * 에러 처리
    * 에러를 처리하지 않거나 불충분 하게 처리하여 에러 정보에 중요 정보가 포함될때 발생할수 있는 보안 약점
    * 종류
      * 오류 메시지 정보 노출
      * 오류 상황 대응 부재
      * 부적절한 예외 처리
  * 코드 오류
    * 개발자가 범할수 있는 코딩 오류로 인해 유발되는 보안 약점
    * 종류
      * 널 포언터 역참조
      * 부적절한 자원 해제
      * 해제된 자원 사용
      * 초기화 되지 않은 변수 사용
  * 캡슐화
    * 중요한 데이터 또는 기능성을 불충분하게 캡슐화 하거나 잘못 사용해 발생하는 보안 약점
    * 종류
      * 잘못된 세션에 의한 정보 노출
      * 제거 되지 않은 디버그 코드
      * 시스템 정보 노출
      * 잘못된 접근 지정자
  * API 오용
    * 의도된 사용에 반하는 방법으로 API 를 사용하거나 보안에 취약한 API 를 사용하여 발생할수 있는 보안 약점
    * 종류
      * DNS 에 의존한 보안 결정
      * 취약한 API 사용

---------------------------------------

## 배치 프로그램 구현

### 배치 프로그램

* 개념
  * 데이터를 일괄적으로 모아서 처리하는 대량의 작업 처리
  * 컴퓨터 흐름에 따라 순차적으로 자료를 처리하는 방식
  * 배치 프로그램 이란 대량의 데이터를 모아 정기적으로 반복 처리하는 프로그램
* 필수 요소
  * 대용량 데이터 : 대용량의 데이터 처리
  * 자동화 : 심각한 오류 상황 외에는 사용자의 개입없이 동작
  * 견고함 : 비정상적인 동작 중단이 발생하지 않야 한다. 
  * 안정성 : 어떤 문제 발생시 해당 문제 추적하고 복구 할수 있어야 함
  * 성능 : 주어진 시간에 작업을 완ㄹ해야 하고 다른 애플리케이션 방해하지 않음
* 관리 종류
  * 크론탭
    * UNIX, Linux 에서 사용되는 스케줄러
    * 시간을 지정해 특정 명령을 자동 실행
    * 크론탭 형식
      * 분 시 일 월 요일 명령어
    * 항목 범위
      * 분 : 0 ~ 59
      * 시 : 0 ~ 23
      * 일 : 1 ~ 31
      * 월 : 1 ~ 12
      * 요일 : 0 ~ 6
      * 명령어 : 실행할 명령어
    * 특수 문자
      * (*) : 모든값
      * (-) : 범위
      * (,) : 여러 값
      * (/) : 매 n분마다
      * (?) : 어떤값이든 상관 없음
    * 예시
      * 0 0 * * * /home/user/backup.sh : 매일 0시 0분에 /home/user/backup.sh 실행
      * 0 0 * * 0 /home/user/backup.sh : 매주 일요일 0시 0분에 /home/user/backup.sh 실행
      * 0 0 1 * * /home/user/backup.sh : 매월 1일 0시 0분에 /home/user/backup.sh 실행
      * 0,30 9-18 * * * /home/user/backup.sh : 매일 9시부터 18시까지 0분과 30분에 /home/user/backup.sh 실행
      * */10 * * * * /home/user/backup.sh : 매 10분마다 /home/user/backup.sh 실행
  * 스프링 배치
    * 백엔드 배치 처리를 위한 프레임 워크
    * 대용량 고성능 배치 작업 지원
    * 실패지점부터 재시작 기능
    * BatchJob 을 실행시키기 위해서 Quartz, Scheduler, Jenkins 등 전용 스케줄러가 필요
    * 구성요소
      * Job, Job Launcher, Job Repository, Step
  * Quartz Job Scheduler
    * Java 기반 작업 스케줄러
    * 특정 시간 도는 주기적인 작업 실행
    * 주요 인터페이스
      * Trigger, Job, JobDetail, Scheduler
    * 형식
      * 초 분 시 일 월 요일 년(생략 가능)
* 배치 스케줄러 클래스 작성
  * 배치 설계서 확인
  * DTO/VO 구현
  * SQL 문 구현
  * DAO 구현

---------------------------------------

## 인터페이스 개요 및 설계서 확인

### 인터페이스 시스템

* 개념
  * 서로다른 시스템이나 장치간에 정보나 신호를 주고 받을수 있게 도와주는 시스템
  * 다양한 시스템과 장치의 호환성을 보장, 효율적인 데이터 교환
* 구성
  * 송신시스템, 중계시스템, 수신시스템
  * 송신 시스템
    * 연계할 데이터를 생성하고 이를 인터페이스 테이블 또는 파일 형태로 송신하는 시스템
  * 중계 시스템
    * 송신 시스템과 수신 시스템 사이에서 데이터를 변환하거나 중계하는 시스템
    * 연계 데이터의 보안 강화와 다중 플랫폼 지원 가능
  * 수신 시스템
    * 송신 시스템으로부터 받은 데이터를 수신하고 이를 처리하는 시스템

* 연계 시스템 분류와 데이터 식별
  * 시스템 분류 체계
    * 기업 내부에서 사용하는 시스템을 분류하여 대내외 인터페이스 시스템을 식별하는 체계
  * 식별 정보
    * 대내외 구분 정보
    * 기관명
    * 시스템 ID
    * 한글명
    * 영문명
    * 시스템 설명
    * 시스템 위치
    * 네트워크 특성
    * 전용회선 정보
    * IP/URL
    * Port
    * Login 정보
    * DB 정보
    * 담당자 정보
  * 송수신 데이터 식별
    * 송수신 시스템 사이에서 교환되는 데이터는 규격화된 표준 형식에 따라 전송
    * 전문 구성
      * 전문 공통부 : 인터페이스 표준 항목 포함
      * 전문 개별부 : 업무처리에 필요한 데이터 포함
      * 전문 종료부 : 전송 데이터의 끝을 표시하는 문자 포함

### 인터페이스 설계서 확인

* 인터페이스 목록
  * 연계 업무와 연계에 참여하는 송수신 시스템의 정보, 연계 방식과 통신 유형등에 대한 정보
* 주요항목
  * 인터페이스 ID
  * 인터페이스 명
  * 송신 시스템
  * 주기
  * 데이터 형식
  * 관련 요구사항 ID
* 인터페이스 정의서
  * 데이터 송신 시스템과 수신 시스템간의 속성과 제약 조건등을 상세힝 포함
* 주요항목
  * 인터페이스 ID
  * 최대 처리 횟수
  * 데이터 크기
  * 시스템 정보
  * 데이터 정보
* 인터페이스 설계서 명세화
  * 인터페이스 설계 가이드와 인터페이스 설계서 작성 양식을 준비
* 인터페이스 데이터 표준 개념
  * 인터페이스를 위해 인터페이스가 되어야 할 범위의 데이터들의 형식과 표준을 정의하는것
* 데이터 표준 확인
  * 데이터 포맷은 JSON, DB, XML, YAML 등 다양한 형태로 표현가능
* 확인절차
  * 식별된 데이터 인터페이스를 통해 인터페이스 데이터 표준을 확인

## 인터페이스 기능 구현 및 구현 검증

### 내 외부 모듈 연계 방식

* EAI(Enterprise Application Integration)
  * 개념
    * 기업 내의 다른 플랫폼 및 애플리케이션들을 연결, 통합 하는 솔루션
  * 목적
    * 비즈니스 통합 미 연계성 증대, 시스템 확장성 향상
  * 구축 유형
    * Point to Point
      * 미들웨어 없이 직접 애플리케이션 끼리 연결
      * 솔루션 구매 없이 직접 통합 가능
    * Hub & Spoke
      * 중앙 허브를 통한 중앙 집중적 연결 방식
      * 모든 데이터 전송 보장, 확장 및 유지보수 용이
      * 단점은 허브에 문제가 생길 경우 전체 시스템에 영향
    * Message Bus(ESB방식)
      * 미들웨어를 사용하여 애플리케이션 사이에서 메시지 전달
      * 뛰어난 확장성, 대용량 처리 가능
    * Hybrid
      * 내부적으로 Hub & Spoke, 외부적으로 ESB 를 사용하는 방식
      * 표준 통합 기술 사용 데이터 병목 현상 최소화
* ESB(Enterprise Service Bus)
  * 개념
    * 웹 서비스 중심의 표준화된 데이터 버스를 이용하여 다양한 애플리케이션을 유연하게 통합하는 플랫폼
  * 구축 유형
    * 관리 및 보안 용이, 높은 품직 지원
    * EAI 와 유사 하지만 서비스 중심 통합을 지향
    * 단점 : 표준화 필요, 벤더 종속성, 일부 성능 문제

### 인터페이스 연계 기술

* DB Link
  * 데이터 베이스에 제공하는 DB Link 객체를 이용
  * 수신 시스템에서 DB Link 를 통해 송신 시스템의 데이터를 조회
* DB Connection
  * 수신 시스템의 WAS 에서 송신 시스템 DB 로 연결하는 DB Connection Pool 을 생성 하고 연계 프로그램에서 해당 DB Connection Pool 이용
* JDBC
  * 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템 DB 와 연결
* API/OpenAPI
  * 송신 시스템의 애플리케이션 프로그래밍 인터페이스 프로그램
  * API 명, 입출력 파라미터 정보가 필요함
* Web Service
  * WSDL(Web Service Description Language), UDDI(Universal Description, Discovery and Integration), SOAP(Simple Object Access Protocol) 프로토콜을 이용하여 연계
* Hyper Link
  * 웹 페이지에서 다른 웹 페이지로 이동하는 링크를 이용하여 연계
* Socket
  * 통신을 위한 소켓을 생성하여 포트를 할당하고 클라이언트의 통신 요청시 클라이언트와 연결하고 통신하는 네트워크 기술

### 인터페이스 전송 데이터

* JSON(JavaScript Object Notation)
  * JavaScript 객체 문법을 기반으로 데이터를 표현하는 문자 기반의 표준 포맷
  * 웹 애플리케이션에서 주로 사용
  * JSON 데이터는 이름과 값의 쌍으로 이루어진다.
* XML(Extensible Markup Language)
  * 웹에서 구조화한 문서를 표현하고 전송하도록 설계한 마크업 언어
  * XML 문서 내용에 대한 구조와 의미를 기술하기 위한 언어
  * 특수한 목적을 갖는 마크업 언어를 만드는데 사용하도록 권장하는 다목적 마크업 언어
  * 다양한 표현이 가능하고 확장성이 뒤어나며 간단
  * HTML 처럼 데이터를 보여주는 목적이 아닌 데이터를 저장하고 전달할 목적으로 만들어짐
  * HTML 처럼 태그가 정해져 있지 않고 사용자가 정의가능
* YAML(YAML Ain't Markup Language)
  * 구성 파일 작성에 자주 사용되는 데이터 직렬화 언어
  * JSON 과 비슷하게 사람이 읽기 쉬운 형태의 데이터 표현 형식
    * YAML 은 XML 과 문법적으로 유사 하지만 태그를 사용하지 않고 공백 위주로 데이터를 구분
* CSV(Comma Separated Values)
  * 몇가지 필드를 쉼표로 구분한 텍스트 데이터 및 텍스트 파일
  * 표형태의 데이터를 저장하는 파일 형식
* AJAX(Asynchronous JavaScript and XML)
  * 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할수 있는 통신 기능
  * 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용
  * 전체 페이지를 새로고침 하지 않고 페이지의 일부만을 변경할수 있는 기법
  * 비동기 방식
    * 웹페이지를 리로드 하지 않고 데이터를 불러오는 방식
    * 페이지 리로드시 전체 리소스를 다시 불러와야 하지만 비동기 방식을 이용할 경우 필요한 부분만을 불러와 사용하므로 불필요한 리소스가 발생하지 않는다.
  * 장점
    * 웹페이지 속도 향상
    * 서버의 처리가 완료될때 까지 기다리지 않고 처리가 가능
  * 단점
    * 히스토리 관리가 되지 않는다
    * 사용자에게 아무런 진행 정보가 주어지지 않는다
    * AJAX 를 쓸수 없는 브라우저에 대한 문제 이슈가 있다.
    * 다른 도메인과는 통신이 불가능 하다.
    * 페이지 이동이 없는 통신으로 인한 보안상의 문제가 있다.
* SOAP(Simple Object Access Protocol)
  * Http, Https, SMTP 등을 이용하여 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜
  * RPC 패턴 사용, 클라이언트와 서버간 요청 및 응답 처리
  * SOA 개념을 실현하는 기술
  * 구성
    * SOAP : Http, Https, SMTP 등을 이용하여 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜
    * UDDI : 비즈니스 업체 목록 등록을 위한 XML 규격
    * WSDL : 웹 서비스 기술언어, 서비스의 기술적 세부사항 기술
  * 보안 프로토콜
    * SAML : 인증/권한 관리
    * XKMS : 키관리
    * XACML : 접근제어
  * 장점
    * 프록시와 방화벽에 구애받지 않는 통신
    * HTTP 이외 다른 전송 프로토콜 사용
    * 플랫폼 독립적
  * 단점
    * XML 포맷의 사용으로 인해 상대적으로 느림
* REST
  * HTTP URI 를 통한 자원 명시와 HTTP 메소드를 통한 CRUD Operation 적용
  * 자원 기반 구조(ROA) 구현
  * 구성요소
    * 자원(Resource) : URI 를 통해 식별되는 서버의 데이터
    * 행위(Method) : GET, POST, PUT, DELETE 등의 HTTP 메소드 사용
    * 표현(Representation) : JSON, XML, TEXT 등 다양한 형태로 표현 가능
  * CRUD Operation
    * Create : POST
    * Read : GET
    * Update : PUT
    * Delete : DELETE
  * 특징
    * 유니폼 인터페이스 : HTTP 표준만 따르면 어떤 언어나 플랫폼에서 사용해도 사용이 가능한 인터페이스 스타일
    * stateless(상태 정보 유지 안함) : REST 는 상태 정보를 유지하지 않는다
    * Cacheable(캐시 가능) : HTTP 표준을 그대로 사용하므로 HTTP 프로토콜의 캐싱 기능 사용 가능
    * self-descriptiveness(자체 표현 구조) : REST API 메시지만 보고도 이해가 가능한 자체 표현 구조
  * 장점
    * 별도인프라 필요없음
  * 단점
    * 표준 부재

### 인터페이스 보안

* 보안 취약점 분석
  * 패킷 공격 기법
    * 스니핑 : 네트워크 상에서 전송되는 패킷을 가로채는 행위로, 주로 비밀 정보를 탈취하는데 사용
    * 스푸핑 : 일반적으로 IP 주소나 다른 식별자를 위장하여 다른 사용자나 시스템으로 속이는 행위
* 보안 기능 적용
  * 네트워크 영역
    * 인터페이스 송/수신 간 스니핑 등을 이용한 데이터 탈취 및 변조 위협 방지 위해 네트워크 트래픽에 대한 암호화 설정
    * IPSec, SSL, S-HTTP 등 다양한 방식 적용
* 애플리케이션 영역
  * 시큐어 코딩 가이드를 참조하여 애플리케이션 코드상 보안 취약점을 보완하는 방향으로 보안 기능적용
* DB 영역
  * DB, 스키마, 엔티티의 접근 권한과 프로시저, 트리거등 DB 동작 객체의 보안 취약점에 보안 기능 적용
  * 민감 데이터를 암호화, 익명화 등을 통해 데이터 자체 보안 방안도 고려

### 인터페이스 구현 검증

* 검증도구
  * XUnit : 다양한 언어를 지원하는 단위 테스트 프레임워크
  * STAF : 서비스 호출 및 컴포넌트 재사용등 다양한 환경을 지원하는 테스트 프레임 워크
  * FitNesse : 웹 기반의 테스트 프레임 워크
  * NTAF : FitNesse 와 STAF 장정을 통합한 NAVER 테스트 자동화
  * Selenoum : 다양한 브라우저 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임 워크
  * watir : Ruby 를 사용하는 애플리케이션 테스트 프레임 워크
* 감시도구
  * APM(Application Performance Management) : 애플리케이션 성능 모니터링 도구
  * 데이터베이스, 웹 애플리케이션의 다양한 정보를 조회하고 분석하여 시각화
  * 종류
    * 스카우터
    * 제니퍼
* 오류발생 알림
  * 화면을 통해 오류메시지 표시
  * SMS 발송
  * 이메일 발송
* 오류발생 확인
  * 로그 확인
  * 테이블 확인
  * 감시도구 확인

---------------------------------------

## 객체지향 설계

### 객체지향

* 개념
  * 현실 세계의 유형, 무형 모든 대상을 객체로 나누고, 객체의 행동과 교유한 값을 정의해 설계하는 방법
  * 객체를 만들고 조작하며 객체 끼리 관계를 맺음으로써 다수의 객체가 함께 수행될수 있게 한다.
* 구성요소
  * 클래스
    * 유사항 종류의 유형/무형의 존재를 속성과 연산을 정의해서 만든틀
    * 다른 클래스와 독립적으로 디자인 한다.
    * 데이터를 추상화 하는단위
  * 객체
    * 클래스의 인스턴스
    * 객체는 자신 고유의 속성을 가지며 클래스에서 정의한 연산을 수행
    * 객체의 연산은 클래스에 정의된 연산에 대한 정의를 공유함으로써 메모리를 경제적으로 사용
  * 속성
    * 객체들이 가지고 있는 고유한 데이터를 단위별로 정의한것
    * 성질, 분류, 수량, 현재 상태등에 대해서 표현한 값
  * 메서드
    * 어떤 특정한 작업을 수행하기 위한 명령문의 집합
  * 메시지
    * 객체에게 어떤 행위를 하도록지시
    * 객체의 메서드를 호출함으로써 객체간의 상호 작용을 할수 있도록 한다.
* 특징
  * 캡슐화
    * 속성과 속성을 조작하는 메서드를 하나로 묶은것
    * 캡슐화된 객체의 세부 내용은 외부에 은폐되어 오류의 파급효과가 적다
    * 캡슐화된 객체들은 재사용이 용이
    * 객체들간의 메시지를 주고 받을때 해당 객체의 세부 내용을 알필요가 없으므로 인터페이스가 단순해지고 결합도가 낮아짐
  * 정보은닉
    * 캡슐화의 가장 중요한 개념
    * 다른 객체들이 객체의 내부 데이터에 직접 접근할수 없도록 제한하며 오직 공개된 메서드를 통해서만 내부 상태에 접근할수 있다.
  * 상속
    * 상위클래스의 모든 속성과 메서드를 하위 클래스가 물려받는것
    * 상속을 이용하면 하위 클래스는 상위 클래스의 속성과 메서드를 자신의 클래스에 다시 정의하지 않아도 된다.
  * 다형성
    * 하나의 메시지에 대해 각 객체가 가지고 있는 여러 가지 방법으로 응답할수 있는 개념
    * 객체에서 동일한 메서드명을 인자값의 유형이나 개수만 틀리게 하는 오버로딩이 존재
    * 객체에서 상속받은 메서드를 재정의하는 오버라이딩이 존재
  * 추상화
    * 실체의 핵심적인 개념만을 추출하여 간결한 형태로 표현
    * 하위 클래스들에 존재하는 공통적인 메서드를 상위 클래스 혹은 인터페이스로 정의하고 하위 클래스가 해당 메서드를 재정의할수 있도록 하는것
* 설계원칙(SOLID)
  * 단일 책임 원칙
    * 한 클래스는 하나의 책임만을 가져야 한다.
  * 개방 폐쇄 원칙
    * 소프트웨어 엔티티는 확장에는 열려있어야 하지만 수정에 대해서는 닫혀있어야 한다.
    * 기존의 코드를 변경하지 않으면서 기능을 추가할수 있도록 설계
  * 리스코프치환원칙
    * 자식클래스는 언제나 자신의 부모 클래스를 대체할수 있어야한다.
  * 인터페이스 분리 원칙
    * 자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다.
  * 의존성 역전 원칙
    * 의존관계를 맺을때 자주 변화하는 것보다 변화가 거의 없는것에 의존해야 한다.

### 디자인 패턴

* 개념
  * 객체지향 프로그래밍 설계를 할때 자주 발생하는 문제들에 대해 재사용 할수 있도록 만들어놓은 패턴
  * 이미 만들어져 잘되는 것으르 활용하여 재사용 함으로 써 프로그램 최적화에 도움을 준다
* 구조
  * 패턴의 이름과 유형
  * 문제 및 배경
  * 솔루션
  * 사례
  * 결과
  * 샘플코드
* GOF 디자인 패턴
  * 에리히 감마, 리차드 헬름, 랄프존슨, 존블리시디스에 의해 개발영역에서 디자인 패턴을 구체화 하고 체계화 시킴
  * 23가지 디자인 패턴을 정리
  * 각각의 디자인 패턴을 생성, 구조, 행위 3가지로 분류
  * 분류
    * 생성 패턴
      * 객체 생성과 관련한 패턴
      * 객체 생성에 있어서 프로그램 주고에 영향을 크게 주지않는 유연성 제공
    * 구조 패턴
      * 클래스나 객체를 조합해서 더 큰 구조를 만드는 패턴
    * 행위패턴
      * 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
  * 생성 패턴
    * 객체 생성에 관련된 패턴
    * 객체의 인스턴스 생성을 추상화하는 방법
    * 객체의 생성 과정과 클래스의 인스턴스 화를 캡슐화 하여 특정 상황에서 어떤 객체를 생성할지 결정할수 있게 도와줌
    * 추상팩토리
      * 구체적인 클래스에 의존하지 않고서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
    * 빌더
      * 복합객체의 생성과 표현을 분리하여 동일한 생성절차에서도 다른 표현 결과를 만들어 낼수 있음
    * 팩토리 메서드
      * 객체 생성을 서브 클래스로 위임하여 캡슐화함
    * 프로토타입
      * 원본 객체를 복사함으로 객체를 생성함
    * 싱글톤
      * 어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조 할수 있도록 함
  * 구조패턴
    * 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
    * 상속을 통해 클래스나 인터페이스를 합성하는 방법을 정의
    * 어댑터
      * 클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할수 있도록 함
    * 브릿지
      * 구현부에 추상층을 분리하여 각자 독립적으로 확장할수 있게함
    * 컴포지트
      * 객체들의 관계를트리 구조로 구성하여 복합객체와 단일 객체를 구분없이 다룸
    * 데코레이터
      * 주어진 상황 및 용도에 따라 어떤 객체에 다른 객체를 덧 붙이는 방식
    * 퍼샤드
      * 서브 시스템에 있는 인터페이스 집합에 대해 하나의 통합된 인터페이스를 제공
    * 플라이 웨이트
      * 크기가 작은 여러개의 객체를 매번 생성 하지 않고 가능한 한 공유할수 있도록 하여 메모리를 절약함
    * 프록지
      * 접근이 어려운 객체로의 접근을 제어하기 위해 객체의 대리나 대체글을 제공
  * 행위패턴
    * 객체나 클래스들이 상호 작용하는 방법 및 책임을 정의 하는 패턴
    * 객체 사이의 효율적인 커뮤니 케이션과 책임 할당을 돕는다.
    * 책임 연쇄
      * 한 객체가 처리할수 없는 요청을 다음 객체로 전달
    * 커맨드
      * 실행될 기능을 캡슐화 함으로써 주어진 조건을 만족하는 기능을 실행할수 있는 유연성 제공
    * 인터프리터
      * 주어진 언어에 대해 그 언어의 문법에 대한 표현을 정의하고 해당 언어를 해석하는 해석자를 위한 패턴
    * 반복자
      * 컬렉션 객체의 내부 구조를 노출시키지 않고도 그 원소들에 접근할수 있는 방법을 제공
    * 중재자
      * 객체간의 복잡한상호 작용을 캡슐화 하고 객체들이 서로 직접 참조하지 않도록 중재자 객체를 통해 통신하도록 만든다.
    * 메멘토
      * 객체의 상태 정보를 저장하고 필요애 따라 이전 상태로 복원할수 있는 기능을 제공
    * 옵저버
      * 객체의 상태 변화를 관할하는 관찰자들의 목록을 객체에 등록하여 상태 변화가 있을때마다 메서드를 통해 객체가 직접 목록의 각 관찰자에게 통지하도록 한다.
    * 상태
      * 객체의 내부에 상태에 따라 동일한 작업이 상태에 따라 다르게 작동하도록 상태를 객체로 표현한다.
    * 전략
      * 알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 만든다.
    * 템플릿 메소드
      * 상위클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브 클래스로 위임함
    * 방문자
      * 객체 구조를 이루는 원소에 대한 연산을 정의하는데 사용되는 패턴

---------------------------------------

## 애플리케이션 테스트 관리

### 소프트웨어 테스트

* 개념
  * 구현된 소프트웨어가 사용자의 요구사항을 만족하는지 확인하며 결함을 찾는 행동
  * 결함을 발견하기 위한 절차와 행위
* 필요성
  * 발견 관점 : 테스트를 통해 결함을 찾아 수정
  * 예방 관점 : 미래의 결함 발생을 방지
  * 품질 향상 관점 : 소프트웨어의 전반적인 품질을 향상
* 기본원칙
  * 테스팅은 결함을 찾아내는 활동
  * 완벽한 테스팅은 불가능
  * 개발초기에 시작
  * 결함 집중
    * 애플리케이션 결함의 대부분은 소수의 특정함 모듈에 집중
    * 파레토 법칙 : 전체 결과의 80%가 전체원인의 20%에서 일어나는 현상
  * 살충제 패러독스
    * 반복적인 테스트로는 새로운 결함을 찾기 어렵다.
    * 테스팅 방법은 특정 상황에 의존적
  * 오류-부재의 궤변
    * 오류가 없다고 해도 사용자의 요구사항을 충족하지 않으면 품질이 좋다고 할수 없음
* 테스트 프로세스
  * 계획
  * 분석 및 디자인
  * 케이스 및 시나리오 작성
  * 수행
  * 결과 평가 및 리포팅
* 테스트 산출물
  * 테스트 계획서 : 테스트의 전반적인 계획 및 목적, 범위, 절차, 일정, 역활 및 책임등을 정의한 문서
  * 테스트 케이스 : 테스트 항목의 입력, 실행 조건 및 기대 결과를 포함한 명세서
  * 테스트 시나리오 : 테스트 케이스의 동작 순서를 기술한 문서
  * 테스트 결과서 : 테스트의 결과와 평가를 정리한 문서
* 테스트 오라클
  * 개념
    * 테스트의 결과가 참인지 거짓인지를 판단하기 위해 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동
  * 유형
    * 참 오라클
      * 모든 입력 값에 대해 정확한 결과를 생성하는 오라클
      * 오류를 완벽하게 검출할수 있으며 크리티컬한 시스템(임베디드, 시스템, 발전소 소프트웨어 등)에서 사용
    * 샘플링 오라클
      * 제한된 입력 값들에 대해서만 예상되는 결과를 제공하는 오라클
      * 대부분의 일반적인 소프트웨어(업무용, 게임, 오락 등)에서 사용
    * 휴리스틱 오라클
      * 특정 입력 값들에 대해서는 정확한 결과를 제공하나, 그 외의 값들에 대해서는 근사적인 추정 결과를 제공하는 오라클
    * 일관성 검사 오라클
      * 소프트웨어의 변경 전후로 테스트 결과의 일관성 검증하는 오라클
      * 소프트웨어 변경이 있을때 변경 전후의 결과가 동일한지를 확인
* 테스트 레벨
  * 
  ```
                            인수테스트
  요구분석      ->          시스템테스트
    아키텍처 설계  ->      통합테스트
      모듈 설계    ->   단위테스트
                 구현  
  ```
  * 단위테스트
    * 개별 소프트웨어 모듈 또는 구성 요소의 기능적, 비기능적 측면을 검증하는 테스트 프로세스의 첫 단계
    * 테스트 케이스는 주로 모듈 설계 단계에서 준비하며 코드를 작성한 개발자에 의해 실행된
    * 주요 목적 : 코드 효율성, 코딩 표준 준수, 기능 정확성 등을 검증
  * 통합테스트
    * 여러 모듈 또는 서브 시스템을 통합하고 그사이의 인터페이스 및 상호작용을 검증하는 테스트
    * 주요목적 : 인터페이스 오류 및 모듈 간 상호작용중 발생할수 있는 문제점 검출
  * 시스템 테스트
    * 완전히 통합된 소프트웨어를 대상으로한 테스트로 소프트웨어와 시스템 사양간의 일치성 검증
    * 기능적 요구사항 뿐만 아니라 비기능적 요구사항에 대한검증도 포함
    * 유형
      * 기능 테스트
        * 고객의 기능적 요구사항을 줌정적으로 테스트
      * 비기능 테스트
        * 고객의 성능 요구사항을 중점적으로 테스트
        * 성능, 신뢰성, 안정성, 유효성, 적함성을 확인하고자 환경과 도구가 필요
  * 인수테스트
    * 시스템을 배포하거나실제 사용할만한 준비가 되었는지에 대해 평가
    * 유형
      * 알파테스트
        * 개발자와 사용가자 같이하는 테스트
      * 베타테스트
        * 개발된 소프트웨어를 사용자가 실제 운영환경에서 수행하는 테스트
      * 사용자 인수 테스트
        * 사용자가 시스템 사용의 적절성 테스트
      * 운영상 인수 테스트
        * 시스템 관리자에 의한 시스템 인수시 수행
      * 계약 인수 테스트
        * 계약상의 인수 조건을 준수하는 지 확인
      * 규정인수 테스트
        * 정부의 지침 법률 또는 안전 규정 드을 준수하는지 확인

### 소프트웨어 테스트 기법

* 실행여부
  * 정적 테스트
    * 소프트웨어의 실행없이 소스코드나 설계 문서등을 분석하여 문제점을 찾는 테스트 방식
    * 종류
      * 코드검사 : 소스코드의 오류 검사
      * 워크스루 : 개발자가 작성한 코드를 팀원에게 설명하며 오류를 찾는 회의 형태
      * 인스펙션 : 검토 전문가들이 소스코드를 분석하여 결함을 발견하는 공식적인 검토
  * 동적 테스트
    * 실제로 소프트웨어를 실행하며 문제점을 찾느 테스트 방식
* 기법
  * 화이트 박스
    * 소프트웨어 내부 구조와 동작을 중점으로 검사하는 테스트
    * 개발자 관점의 단위 테스트
    * 기법
      * 문장검증 : 프로그램의 모든 문장을 한번 수행하여 검증
      * 선택검증 : 선택하는 부분만 검증
      * 경로 검증 : 수행가는한 모든 경로 검사
      * 조건 검증 : 조건이나 반복문 내 조건식을 검사
  * 기초 경로 검사
    * McCabe 가 제안한 것으로 대표적인 화이트박스 테스트 기법
* 블랙박스 테스트
  * 프로그램의 사용자 요구사항 명세를 보면서 테스트
  * 주로 구현된 기능을 테스트
  * 기법
    * 동등 분할 기법
      * 입력 자료에 초점을 맞춰 테스트 케이스를 만들어 검사하는 방법
    * 경계값 분석
      * 입력값의 중간값보다 경계값에서 오류가 발생할 확률이 높다는 점을 이용해 입력 조건의 경계값을 테스트
    * 원인 효과 그래프 검사
      * 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스 선정
    * 오류 예측 검사
      * 과거의 경험이나 테스터의 감각으로 테스트
    * 비교검사
      * 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법
    * 상태전이 검사
      * 시스템에 반영되는 이전의 상태가 무엇인지, 상태 간전이 상태를 변화하는 이벤트와 입력값을 파악
* 시각
  * 검증
    * 소프트웨어 개발 과정 테스트
  * 확인
    * 완성된 소프트웨어의 결과를 테스트
* 목적
  * 회복 : 시스템에 고의로 실패를 유도 정상적으로 복귀하는지 확인
  * 안전 : 불법적인 소프트웨어가 접근하지 못하도록 코드내 보안결함 미리 점검
  * 강도 : 시스템에 과다 정보량을 부과하여 과부하시 시스템이 정상적으로 작동되는지 검증하는 테스트
  * 성능 : 시스템의 성능을 검증하는 테스트
  * 구조 : 시스템의 내부 논리 경로, 소스코드의 복잡도를 평가하는 테스트
  * 회귀 : 변경 또는 수정된 코드에 대하여 새로운 결함 발견 여부를 평가하는테스트
  * 병행 : 변경된 시스템과 기존 시스템에 동일한 데이터를 입력후 결과를 비교
  * A/B 테스트 : 기존 서비스 A와 새로 적용하고 싶은 B를 통계적인 방법으로 비교 새로운 서비스가 효과가 있는지 확인
  * 스모크 테스트 : 본격적 테스트에 앞서 테스트 환경이 가능한지 테스트
* 테스트 종류
  * 명세 기반 테스트
    * 주어진 명세를 빠짐없이 테스트 케이스로 구현하고 있는지 확인
  * 구조기반 테스트
    * 소프트웨어 내부 논리 흐름에 따라 세트스 케이스 작성 확인
  * 경험 기반 테스트
    * 경험 많은 테스터의 직관과 기술 능력을 기반으로 테스트

### 테스트 커버리지

* 개념
  * 주어진 테스트 케이스에 의해 수행되는 소프트웨어의 테스트 범위를 측정하는 품질 측정 기준
  * 테스트를 얼마나 수행했는지 축정하는 기준
* 유형
  * 기능 기반 커버리지
    * 테스트 대상 애플리케이션의 전체 기능을 모수로 설정하고 실제 테스트가 수행된 기능의 수를 측정
    * 100% 달성 목표
  * 라인 커버리지
    * 전체 소스코드의 Line 수를 모수로 테스트시나리오가 수행된 소스코드의 Line 수를 측정
  * 코드 커버리지
    * 소스코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트 되었는지 측정
    * 구문 커리지
      * 코드 전체의 모든 구문에 대해 한번 이상 실행
    * 조건 커버리지
      * 결정 포인트 내의 모든 개별 조건식에 대해 수행
    * 결정 커버리지
      * 결정 포인트 내의 모든 분기문에 대해 수행
    * 조건/결정 커버리지
      * 결정 포인트, 개별 조건식 대해 수행
    * 변경 조건/결정 커버리지
      * 모든 결정 포인트내의 개별 조건식은 적어도 한번 T/F 가져야한다
      * 이론적으로 가장 안정한 조합
    * 다중 조건 커버리지
      * 결정 포인트 내 모든 개별 조건식의 가능한 조합을 100% 보장

---------------------------------------

## 애플리케이션 통합 테스트

### 결함관리 도구

* 개념
  * 테스트후 발생한 결함을 추적하고 관리하는 도구
* 프로세스
  * 에러발견
  * 에러등록
  * 에러분석
  * 결함확정
  * 결함할당
  * 결함조치
  * 결함조치 검토 및 승인
* 결함 추이 분석
  * 테스트 완료후 향후 애플ㄹ케이션의 어떤 결함이 발생할지 추정하는 작업
* 결함 관리 측정 지표
  * 결함 분포 : 특정 속성에 해당하는 결함의 수 측정하여 결함 분포 분석
  * 결함 추세 : 테스트 진행 시간의 흐름에 따른 결함의 수를 측정하여 추세 분석
  * 결함 에이징 : 등록된 결함에 대해 특정한 결함 상태의 지속 시간을 측정하여 분석
* 결함 식별
  * 단계별 결함 유입 분류
    * 기획시 유입되는 결함
    * 설계시 유입되는 결함
    * 코딩시 유입되는 결함
    * 테스트 부족으로 유입되는 결함
  * 결함 심각도별 분류
    * 치명적 결함
    * 주요 결함
    * 보통 결함
    * 낮은 결함
  * 결함 우선순위
    * 결정적 : 24시간 안에 즉시 수정
    * 높음 : 일반적 결함
    * 보통 : 기대치 못미침
    * 낮음 : 수정하지 않아도 되는 경우
* 결함 관리 항목
  * 결함 내용, 결함 ID 결함 유형, 발견일, 심각도, 우선순위, 시정 조치 예정일, 수정 담당자, 재테스트 결과, 종료일

### 테스트 자동화 도구 

* 개념
  * 테스트를 효과적으로 수행하기 위해 스크립트나 도구를 활용하는 반복적인 테스트 작업 자동화 방법
* 장점
  * 반복테스트 효율화
  * 테스트의 일관성 및 정확성 확보
  * 즉각적 피드백 제공
  * 다양한 테스트 결과 분석과 시각화
* 단점
  * 초기 도입 비용 및 시간
  * 도구의 사용방법 교육 필요
* 유형
  * 정적 분석 도구
    * 애플리케이션을 실행하지 않고 분석하는 방법
    * 종류 : pmd, sonarQube, cppCheck, checkStyle
  * 테스트 실행도구
    * 사전에 작성된 테스트 스크립트나 시나리오를 실행하는 도구
    * 종류 : selenium, junit, testNg
  * 성능 테스트 도구
    * 시스템의 성능, 부하, 안정성을 테스트하는 도구
    * 종류 : Jmeter, LoadRunner
  * 통제 도구
    * 테스트 전체 프로세스를 관리하는 도구
  * 테스트 장치
    * 애플리케이션의 단위 또는 모듈 테스트에 사용하는 환경 및 도구
    * 구성요소
      * 테스트 드라이버 : 테스트 하위 모듈을 호출하고 파라미터를 전달하고 모듈테스트 수행후 결과를 도출하는 상향식 테스트에 필요
      * 테스트 스텁 : 제어모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 하향식 테스트에 필요
      * 테스트 슈트 :  테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
      * 테스트 케이스 : 입력값, 실행조건 기대 결과 등의 집합을 말한다.
      * 테스트 스크립트 : 자동화된 테스트 실행절차 명세서
        * 목 오브젝트 : 사용자의 행위를 조건부로 사전에 입력해두면 그 상황에 예정된 행위를 수행하는 객체를 말한다.

### 통합 테스트

* 개념
  * 소프트웨어 각 모듈간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 테스트 기법
  * 수행방법으론 점증적 방식, 상향식, 하향식 테스트가 있고 비 점증적 방식 빅뱅 테스트가 있다.
* 하향식 통합 테스트
  * 메인제어 모듈로부터 아해 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트 진행
  * 아직 개발되지 않은 하위모듈은 더미 모듈인 스텁을 개발하여 테스트 진행
  * 장점
    * 장애 위치 파악이 쉬움
    * 중요 모듈은 먼저 테스트 실행
  * 단점
    * 많은 스텁이 필요
    * 하위 모듈의 불충분한 테스트
* 상향식 통합 테스트
  * 최하위 레벨의 모듈부터 위쪽 방향으로 제어의 경로를 따라 통합 하면서 테스트 진행
  * 하위 모듈을 클러스터로 결합하면서 위쪽 방향으로 진행
  * 아직 개발되지 않은 상위 모듈은 더미 모듈인 드라이버를 개발하여 테스트 진행
  * 장점
    * 장애 위치 파악 쉬움
    * 모둔 모듈 개발을 위한 시간 낭비가 불필요
  * 단점
    * 중요 모듈들이 마지막에 테스트될 가능성이 높음
* 빅뱅 테스트
  * 모든 구성요소들을 한꺼번에 통합하여 테스트
  * 소규모 시스템에 편리한 테스트 방식
  * 장점
    * 단시간에 테스트 할수 있다
  * 단점
    * 장애가 일어난 위치를 파악하기 어렵다
    * 모든 모듈들이 설계된 후에 시작할 수 있기 때문에 테스트 시간이 적어진다.
* 백본 테스트
  * 샌드위치 테스트
  * 상향식 하향식의 장점을 이용
  * 드라이버/스텁을 필요에 따라 만들어 사용
  * 대규모 프로젝트에 사용
  * 비용 많이들어감
* 통합 테스트 수행 순서 
  1. 테스트 계획서 검토
  2. 테스트 환경 준비
  3. 테스트 케이스 및 시나리오 검토
  4. 통합 모듈 및 인터페이스가 요구사항을 충족하는지 테스트 수행
  5. 테스트 결과 기록

---------------------------------------

## 애플리케이션 성능 개선

### 애플리케이션 성능 저하 원인

* 데이터 베이스 관련 성능 저하
  * 데이터베이스 락
    * 대량의 데이터 조회나 과도한 업데이트시 발생
    * Lock 이 해제될때 까지 다른 트랜잭션 들이 대기하게 되며 이로 인해 타입아웃 발생
  * 불필요한 패치
    * 결과 세트에서 커서를 자주 옮기는 경우 발생
    * 네트워크 리소스에 불필요한 부담을 주며 전체 시스템의 성능 저하를 초래할수 있다.
  * 연결 누수
    * 데이터베이스 연결후, 이를 제대로 반환하지 않을때 발생
    * 사용가능한 데이터 베이스 연결이 부족해져 시스템 성능 저하
* 내부 로직으로 인한 성능 저하 원인
  * 파일 관련 오류
    * 대량의 파일을 업로드 하거나 다운로드 하는 과정에서 발생
    * 시스템의 응답 시간이 증가하고 서버의 부하가 커질수 있다
  * 코드오류 
    * 잘못된 코드 로직, 예를 들어 무한 반복등의 문제로 발생
    * 시스템의 리소스가 과도하게 사용되거나 전체적인 성능 저하
* 외부 호출로 인한 성능 저하
  * 외부 서버와의 인터페이스가 장시간 수행되거나 타임아웃 발생
  * 시스템의 응답시간이 늘어나고 전체 성능에 영향 줄수 있음

### 애플리케이션 성능 분석 지표

* 종류
  * 처리량
    * 애플리케이션이 일정시간내에 처리하는 작업량
  * 응답시간
    * 사용자가 요청을 전송한 시점부터 애플리케이션이 첫 응답을 보내기 까지 시간
  * 경과시간
    * 요청이 전달된 시점부터 처리가 완료되기 까지 총시간
  * 자원 사용률
    * 애플리케이션이 작업을 처리하는 동안 CPU, 메모리, 네트워크 등의 자원 사용량
* 분석 도구
  * JMeter
    * 다양한 프로토콜 지원
    * 애플리케이션의 성능과 스트레스 테스트에 적합
  * LoadUI
    * 웹서비스의 로드 테스트에 사용되며 테스트 형태에 따라 분산된 UI 제공
  * OpenSTA
    * HTTP, HTTPS 에 대한 부하 성능 모니터링 도구
* 모니터링 도구
  * Scouter
    * 단일 뷰를 통한 통합 및 실시간 모니터링 기능 제공
  * NMon
    * 리눅스 서버 자원에 대한 모니터링 도구
  * Zabbix
    * 웹기반 서버, 서비스 애플리케이션 도구
  * Jeniffer
    * 애플리케이션에서 서버로 유입되는 트랜잭션의 양, 처리 시간, 응답 시간 자원 활용률 등 모니터링

### 정형 기술 검토 회의(FTR, Formal Technical Review)

* 개념
  * 소프트웨어 엔지니어링의 일부로 소프트웨어 품질 보증 활동
* 목적
  * 산출물이 요구사항에 부합하는지 검토
* 검토 지침
  * 제작자가 아닌 제품의 검토에만 집중

### 소스코드 품질 분석

* 동료 검토
  * 2~3명의 개발자가 참여하는 리뷰 프로세스
  * 코드 작성자코드를 설명하고 이해 관계자들이 그 설명을 들으며 결함을 발견
* 워크스루
  * 계획된 개발자 검토 회의
  * 검토자료 회의 전에 배포하여 사전 검토 후 짧은 시간 동안 리뷰 회의 진행
* 인스펙션
  * 공식적 검사회의
  * 작업자가 아닌 다른 전문가나 팀이 검사하여 오류를 찾아내고 소스 코드의 품직을 높이는 기법

### 소스코드 품질 분석 도구

* 개념
  * 코딩중 발생할수 있는 다양한 문제를 해결하기 위해 사용하는 도구
* 정적 분석 도구
  * 프로그램 실행없이 소프트웨어 코드를 분석
* 동적 분석 도구
  * 프로그램 실행시간에 소프트웨어 코드를 분석
* 소스코드 품질 분석 도구 종류
  * 정적 분석 도구
    * PMD
    * checkStyle
    * sonarQube
    * cppCheck
    * ccm
    * cobertura
  * 동적 분석 도구
    * Avalanche
    * Valgrind

### 애플리케이션 성능 개선하기

* 코드 최적화
  * 알고리즘 개선 병목현상 제거, 실행시간 단축, 메모리 사용최소화
  * 계산 횟수 감소, 실행 시간과 기억 용량 최적화, 소스코드 가독성 향상
  * 리팩 토링으로 코드 스멜 제거
* 코드 스맬
  * 소스코드에서 발견할수 있는 잠재적인 문제점
  * 코드스멜 용어
    * 스파게티 코드 : 복잡하게 얽힌 소스코드 구조
    * 외계인 코드 : 오래되어 유지보수가 어려운 코드
  * 리팩토링
    * 외부 동작 변경 없이 내부 구조를 개선하는 방법
    * 기능변경 없이 소스코드의 가독성과 유지 보수성을 높이기 위해 내부 구조 변경
  * 클린코드
    * 의존성 최소화, 명확한 가독성과 목적성을 가진 코드
    * 의존성 최소화, 단일 책임, 원칙 준수, 버그 최소화, 가독성 향상, 중복 최소화, 변경 용이성, 간결함
    * 클래스명, 메서드명, 변수명에 의미있는 명사 사용
    * 불필요한 주석 제거, 의도를 명확히 기술한 주석 작성
    * 리팩토링 통해 복잡도 낮춤
    * 작성원칙
      * 가독성
      * 단순성
      * 의존성 배제
      * 중복성 최소화
      * 추상화

---------------------------------------

## 소프트웨어 유지보수

### 소프트웨어 유지보수

* 개념
  * 개발 완료 이후부터 폐기 될떄 까지 지속적을 ㅗ수행되는 작업
  * 소프트웨어의 수명연장, 기능개선, 하자보수
  * 소프트웨어 생명 주기 동안 가장 많은 비용이 소요되는 단계
* 중요성
  * 유지보수비용이 점차 증가
* 어려운 이유
  * 업무 프로세스와 구축된 시스템에 대한 이해가 필요
  * 유지보수 업체와 개발 업체가 다른 경우 소프트웨어 구조 파악과 가동성이 어려워진다.
* 유지보수 구분
  * 수정보수
    * 소프트웨어의 잠재적 오류 수정
  * 적응 보수
    * 운영체제, 하드 웨어 등 환경 변화에 맞추어 소프트웨어 수정
  * 향상 보수
    * 기존 기능 개선 및 새로운 기능 추가
  * 예방 보수
    * 장래의 유지보수성과 신뢰성을 보장하기 위한 선제적 조치
* 관련 용어
  * 레거시
    * 오래된 기술, 방법론, 컴퓨터 시스템, 소프트웨어
  * 외계인 코드
    * 오래되었거나 참고문서, 개발자거ㅏ 없어 유지보수가 어려운 코드
  * 스파게티 코드
    * 복잡하게 얽힌 프로그래밍 소스코드
  * 코드 스멜
    * 소스코드내에 존재하는 잠재적인 문제를 나타내는 용어

---------------------------------------

## 국제 표준 제품 품질 특성

### 제품 품질 국제 표준

* 개념
  * 소프트웨어 개발 공정 각 단계에서 산출 되는 제품이 사용자 요구를 만족하는지 검증하기 위한 국제 표준
* 표준
  * ISO/IEC
    * 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성 
    * 9126-1 : 소프트웨어 품질 모델
    * 9126-2 : 외부 품질 특성
    * 9126-3 : 내부 품질 특성
    * 9126-4 : 사용 품질 특성
  * ISO/IEC
    * 반복성, 재현성, 공정성, 객관성
    * 14598-1 : 개요
    * 14598-2 : 계획 및 관리
    * 14598-3 : 개발자용 프로세스
    * 14598-4 : 구매자용 프로세스
    * 14598-5 : 평가자용 프로세스
    * 14598-6 : 평가 모듈
  * ISO/IEC
    * 제품설명서, 사용자 문서, 실행 프로그램
    * 12119 : 패키지 소프트웨어 품질 요구사항 및 테스트
  * ISO/IEC
    * 2500n : 2500 안내서
    * 2501n : 2501 품질 모델
    * 2502n : 품질 특정 부분
    * 2503n : 품질 요구사항
    * 2504n : 품질 평가

### 프로세스 품질 국제 표준

* 개념
  * 소프트웨어 개발 프로세스 및 관련 업체의 프로세스 관리 능력을 평가하고 개선하는데 사용
* 국제 프로세스 품질 표준
  * ISO/IEC 9001 : 조직 품질 경영 및 품질 보증
  * ISO/IEC 12207 : 소프트웨어 생명 주기 프로세스
  * ISO/IEC 15504 : 프로세스 평가
  * CMM : 전체 프로세스 평가
  * CMMI : 프로세스 개선 모델 통합

### 서비스 국제 표준

* 개념
  * 고객에게 IT 서비스를 제공하고 관리하기 위한 통합된 관리 체계를 적용하여 고객에게 적절한 통제, 개선된 효과성 및 개선의 기회를 제공
* ISO/IEC 20000
  * 고객에 제공하는 IT 서비스 수준을 객관적으로 평가

---------------------------------------

