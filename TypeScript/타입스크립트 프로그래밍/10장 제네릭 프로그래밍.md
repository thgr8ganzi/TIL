
## 제네릭 프로그래밍

------------

### 제네릭 타입 이해하기

* 제네릭 타입은 인터페이스, 클래스, 함수, 타입별칭 등에 사용할수 있는 기능으로 해당 타입을 미리 지정하지 않고 다양한 타입에 대응할수 있다.
```
interface IValuable<T>{
    value: T
}
function identity<T>(arg:T):T{return arg}
type IValuable<T> = {
    value:T
}
class Valuable<T>{
    constructor(private value:T) {}
}
```
* 제네릭 클래스가 제네릭 인터페이스를 구현하는 방식으로 만들수 있다.
* 타입변수를 생략해도 타입추론이 가능하다
```
interface IValuable<T>{
    value:T
}
class Valuable<T> implements IValuable<T>{
    constructor(public value:T) {}
}
const printValue = <T>(o: IValuable<T>):void => console.log(o.value)
printValue(new Valuable<number>(1))         // 1
printValue(new Valuable<boolean>(true))     // true
printValue(new Valuable<string>('hello'))   // hello
printValue(new Valuable<number[]>([1, 2, 3])) // [1, 2, 3]
printValue(new Valuable(1))                 // 1
printValue(new Valuable(true))              // true
printValue(new Valuable('hello'))           // hello
printValue(new Valuable([1, 2, 3]))         // [1, 2, 3]
```

### 제네릭 타입 제약

* 제네릭 타입 제약은 타입변수에 적용할수 있는 타입 범위를 한정하는 기능을 제공한다.
```
const printValueT = <Q, T extends IValuable<Q>>(o: T) => console.log(o.value)
printValueT(new Valuable(1))                                 // 1
printValueT<boolean, IValuable<boolean>>({value:true})       // true
```
* 팩토리함수는 new 연산자를 사용해 객체를 생성하는 기능을 하는 함수를 의미한다.
* 보통 팩토리 함수는 객체를 생성하는 방법이 지나치게 복잡할때 이를 단순화 하려는 목적으로 구현한다.
* 타입스크립트는 타입의 타입을 허용하지 않는다.
```
const create1 = <T>(type:T):T => new type() // err
```
* 타입스크립트 언어 창시자인 아네르스 하일스베르는 C# 언어의 창시자이다.
* {new():T} 구문은 C# 에서 따왔다.
* 타입제약구문은 중괄호로 new 키워드를 감싸 메서드 형태로 표현했다.
* `{new():T}` 와 `new() => T` 는 같은 의미이다
* new 연산자를 type 에 적용하면서 type 의 생성자 쪽으로 매개변수를 전달할땐 new(...args) 를 사용한다.
```
const create2 = <T extends {new(): T}>(type:T):T =>new type();
const create3 = <T>(type: new() => T):T => new type();
const create4 = <T>(type: {new(...args):T}, ...args):T => new type(...args)
class Point{constructor(public x:number, public y:number) {}}
[
    create4(Date),              // 2023-08-18T02:21:18.976Z
    create4(Point, 0, 0),  // Point { x: 0, y: 0 }
].forEach(s => console.log(s))
```
* 객체의 일정 속성들만 추려서 좀더 단순한 객체를 만들때 사용하는 pick 함수 구현
* keyof 함수로 인덱스 타입제약을 걸수있다.
* 인덱스 타입제약으로 코드 작성시 오타를 줄여준다.
```
const obj = {name:'Jane', age:22, city:'Seoul', country:'Korea'}
const pick = (obj, keys) => keys.map(key => ({[key]: obj[key]})).reduce((result, value) => ({...result, ...value}), {})
console.log(
    pick(obj, ['name','age']), // { name: 'Jane', age: 22 }
    pick(obj, ['nam','age'])   // { nam: undefined, age: 22 }
)
const pick2 = <T, K extends keyof T>(obj:T, keys:K[]) => 
    keys.map(key => ({[key]:obj[key]}))
    .reduce((result, value) => ({...result, ...value}), {})
```

### 대수 데이터 타입

* 객체지향 프로그래밍 언어에서 ADT 는 추상데이터타입(abstract data type)을 의미하지만 함수형 언어에서는 대수 데이터타입(algebraic data type)을 의미한다.
* 타입스크립트에선 합집합타입과 교집합 타입 두가지 종류가 있다.
* 객체지향언어는 상속에 기반을 두고 타입을 분류하는 경향이 있지만 상속에만 의존하면 true, false 두가지 값만 가지는 bool 타입은 만들기 어려워서 함수형 언어에서는 대수 데이터타입을 선호한다.
* 합집합은 '|' 기호로 다양한 타입을 연결해서 만든 타입이다.
* 교집합은 '&'기호를 사용하고 구개의 객체를 통합해서 새로운 객체를 만드는것이다.
```
type NumberOrString = number | string
let ns: NumberOrString = 1
ns = 'hello'

const mergeObject = <T, U>(a:T, b:U): T & U => ({...a, ...b})
type INameble = {name:string}
type IAgeable = {age:number}

const nameAndAge: INameble & IAgeable = mergeObject({name:'Jack'}, {age: 32})
console.log(nameAndAge) // { name: 'Jack', age: 32 }
```
* 