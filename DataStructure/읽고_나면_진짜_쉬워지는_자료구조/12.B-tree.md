## B-Tree
<hr/>

### B-Tree 구조
<hr/>

* 컴퓨터 과학에서는 같은 블록 내부에 있는 데이터 접근은 저렴하지만 새블록을 가져오는 비용이 상대적으로 비싸다
* B-Tree 는 루돌프 바이어(Rudolf Bayer)와 에드워드 맥키스티(McCreight)가 제안한 자료구조로 한노드에 려어 데이터 조각을 저장해 비싼 탐색 비용을 한번만 지불한다.
* 대용량 데이터집합에 인덱싱을 시도할때 B-Tree 는 인덱싱과 키를 결합하여 탐샘 비용 최소화
* 데이터가 치우치는 경우가 생기지 않도록 노드를 분할하고 병합하는 과정을 통해 균형을 유지한다.
* B-Tree 는 내부 노드에 2개보다 훨씬더 많은 가지를 가질 수 있다.
* B-Tree 노드의 크기를 매개변수 k
* 루트가 아닌 모든 노드는 k ~ 2k 개의 카를 가질 수 있다.
* 루트가 아닌 모든 노드는 k+1 ~ 2k+1 개의 자식을 허용한다
* 루트 노드는 0 ~ 2k 개의 키를 가질 수 있다.
* 루트 노드는 0 ~ 2k+1 개의 자식을 허용한다.
* B-Tree 내부 노드에는 원소 포인터가 있고 바인더 포인터가 있는데 바인더 포인터는 현재 바인더의 마지막키 이후 오는 키만 포함해 다른 바인더를 가르킨다.
* B-Tree 가 복잡한 이유는 키와 자식을 저장하는 배열의 크기가 다르기 때문 인데스 i 에 있는 키를 인접한 자식 포인터들과 어떻게 매핑할지 정의해야 한다.

### B-Tree 탐색
<hr/>

* B-Tree 는 이진트리와 비슷하게 탐색을 수행하지만 노드가 여러개의 키를 가지고 있어 하나 이상의 키를 확인할수도 있다

### 키 삽입
<hr/>

* B-Tree 에 키를 삽입할때는 구조의 균형을 유지하기 위해 각 노드에 저장된 키의 수를 (k 와 2k 사이)로 유지해야 한다.
* 노드가 꽉 찻을 경우
  * 트리를 따라 진행 하면서 노드를 분할 해서 꽉찬노드에 대해 삽입을 호출하지 않도록 보장
  * 가득찬 노드에 임시로 키를 삽입하고 트리를 루트로 올라가면서 노드를 재 분할
    트리를 따라 내려가며 새키를 삽입할 위치 탐색
  * 트리를 거슬러 올라가면서 과포화된 노드를 분할 각 분할은 노드의 분기 정도를 증가 시키지만 높이를 증가시키지 안흔ㄴ다
  * 루트 노드를 분할할때만 높이가 증가한다(모든 리프의 깊이가 동시에 1 늘어남)

### 키 제거
<hr/>

* 트리 구조를 균형잡힌 상태로 유지하고 각 노드에 저장된 키 개수 제한(k 와 2k 사이)을 유지해야 한다.
* 키 탐색을 위해 트리 아래로 내려가면서 키를 찾아내 제거
* 키를 올라가면서 키가 너무 적게 들어있는 노드 확인하고 복구
* 키가 너무 적게들어있을때
  * 인접한 형제 노드의 키를 합치는데 의존
    * 두개의 작은 형제 노드를 하나의 노드로 직접병합
    * 더 키가 많이 들어있는 형제 노드의 키를 키가 부족한 노드로 전달