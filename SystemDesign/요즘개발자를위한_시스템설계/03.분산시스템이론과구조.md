## 분산시스템 이론과 구조
<hr/>

### CAP(브루어의 정리)
<hr/>

* 일관성, 가용성, 파티션 허용성 간 상충관계를 설명
* 일반적인 상황에서 파티션허용성(분할내성)은 포기할수 없으므로 CP, AP 중 하나를 선택해야함

#### 파티션 허용성(P)

* 시스템의 노드 간 통신 중단이 아무리 많아도 클러스터가 계속 작동해야 함

#### 일관성(C)

* 어떤 노드에 연결하든 모든 클라이언트가 동시에 동일한 데이터를 볼 수 있음

#### 가용성(A)

* 데이터를 요청하는 모든 클라이언트가 하나 이상의 노드가 다운된 경우에도 응답을 받는다는 것

### PACELC
<hr/>

* CAP 의 연장성
* P: 파티션 허용성
* A: 가용성
* C: 일관성
* E: else
  * 네트워크 파티션이 발생하지 않는 정상적 작동상태
  * L, C 둘증에 하나를 선택해야 한다
* L: 지연시간
* C: 일관성 수준

### 팩소스, 래프트
<hr/>

* 네트워크 분할이나 정상적으로 동작하지 않는상태에서 여러노드간 합의를 이끌어내는 알고리즘
* 합의란 서로다른 서버가 동일한 상태나 결정을 유지하도록 하는 과정

#### 팩소스

* 시스템 내 모든 노드가 동의해 시스템 일관성을 유지하고 서로다른 값을 업데이트함
* 여러 단계의 통신을 거쳐 각 노드가 하나의 값으로 일치할수 있도록 하여 안정적 운영
* 핵심 포인트
  * 제안자: 합의 프로세스를 시작하는 역활, 값을 제안받고 다른 노드에 전파
  * 수용자: 제안제에게 제안을 받고 제안이 수용되었는지 다른 노드에 알림
  * 학습자: 합의된 값을 최종적으로 받아서 후속작업을 수행
* 프로토콜 과정
  * 준비단계: 제안자는 고유 제안번호를 선택하여 많은 최대한 만든 수용자에게 준비 요청을 보내고 수용자는 제안받은 가장 높은 번호의 제안을 응답으로 반환
  * 수용단계: 제안자가 수용자에게 응답을 받으면 수용단계로 넘어감, 제안자는 자신의 제안 번호와 값을 담아 수용자에게 수용 요청을 보낸다
  * 합의점 도달: 여러 수용자가 제안을 수용하면 합의가 되어 해당 값이 선택됨, 이후 학습자에게 선택한 값 전달
* 고려 사항
  * 장애 허용성: 장애가 발생해도 원활하게 작동해야함
  * 확장성: 노드의 개수에 영향을 받음으로 고려 해야함
  * 복잡성: 팩소스 알고리즘은 복잡 하므로 모든 참여자가 프로토콜을 따를수 있게 해야함
* 최적화 기법
  * 멀티팩소스
    * 값 여러개에 대해 지속적 합의 할수 있음
    * 준비단계와 수용단계의 반복을 피할수 있다
  * 패스트 팩소스
    * 합의헤 필요한 메시지수를 줄인다
    * 제안자가 일반적인 준비단계를 건너뛰고 수용자에게 값 제안할수 있음
  * 심플 팩소스
    * 준비와수용을 하나의 라운드로 통합
* 사례
  * 분산 데이터베이스
  * 분산 파일 시스템
  * 상태기계복제

#### 래프트

* 팩소스와 달리 지정된리더가 있고 상대적으로 구현이 쉬움
* 핵심 포인트
  * 리더: 합의 과정을 관리하고 로그 항목을 다른 노드에 복제하도록 지시, 리더가 새로운 정보를 만들면 다른 노드에 전달하여 모든 노드가 동일한 정도보를 갖도록 함
  * 추종자: 리더의 로그를 복제하고 들어오는 요청에 응답하는 수동적인 혈활을함, 합의과정에서 리더의 지침을 따름
  * 후보자: 리더가 실패하거나 새로운 리더를 선출할때 후보 상태로 바뀜, 후보노드는 다른 노드에게 투표요청하여 리더 선출함
* 프로토콜 과정
  * 리더선출: 리더가 없을때 후보상태로 전환되고 요청투표 메시지를 보냄, 과반수 투표받으면 리더 선출
  * 로그복제: 리더는 클라이언트 요청을 받아 로그에 추가하고 추종자에게 복제함, 추종자는 자신의 상태 기계에 적용하여 시스템 일관성 유지
  * 안정선과 일관성: 로그추가, 투표 적용하여 안정성과 일관성 유지
* 고려사항
  * 리더 가용성: 리더는 항상 활성화 되어 있어야함
  * 확장성: 노드가 늘어나면 오버헤드가 커지므로 적절하게 설정을 조정해야함
  * 장애허용성: 리더가 동작하지 않을때 새로운 리더를 선출하여 지속적 운영
* 사례
  * 분산 데이터베이스(DynamoDB)
  * 분산파일 시스템
  * 클러스터 관리 및 디스커버리(아파치 주키퍼)
  * 합의 기반 알고리즘
  * 클라우드 인프라관리

### 비잔티움 장군문제
<hr/>

* 분산시스템에서 악의적인 행위자가 일으킬수 있는 문제를 해결
* 전체 장군수 N, 배신자수 F `F < (N - 1) / 2`
* 문제 해결방식
  * 투표 알고리즘: 특정 기준이 충족되면 계획 실행
  * 반복서명방식: 장군들이 계획을 제안하고 서명으로 찬성 표시
  * 쿼럼 방식: 과반수 찬성 얻은 이후 계획 실행
  * 타임아웃과 확인: 일정시간이 지나 투표하지 않은 장군은 배제
  * 무작위 선택: 임의의 난수를 포함한 계획 제안하고 난수를 맞추지 못한 장군은 배제
* 비잔티움 장애
  * 시스템내 일부 노드가 장애를 일으켜도 식별하고 관리가 어려움
* 비잔티움 장애 허용성
  * 각노드가 자신의 값을 다른 모든 노드애 튶ㅅ 형식으로 전송하여 최종값을 다수결로 정함
* 최신 비잔티움 장애 허용성
  * PBFT

### FLP 불가능성 정리
<hr/>

* 단하나의 장애가 있는 비동기 시스템에서 합의를 이루는것은 근본적인 한계가 있음을 정리하는것
* 불가능이 성립하는 전제조건
  * 비동기성: 항성 서로 같은 시간 값을 갖지 않는다
  * 프로세스 장애: 전체 프로세스수가 n일때 최대 f 개 고장날수 있다(0 < f < n)
  * 유한한 단계: 각 프로세스는 정해진 단계만 수행하고 메시지 크기도 제한
* 해당 전제에서 비동기 시스템은 느리게 응답하는 프로세스와 실제로 고장난 프로세스를 구별할수 없음을 증명

### 일관된 해싱
<hr/>

* 데이터를 여러 노드에 분산하면서 확장성과 부하 균형을 유지하는 기법
* 모듈로 해싱
  * 데이터 키를 해시값으로 변환 후 노드 개수로 나눈 나머지를 사용해 데이터를 특정 노드에 할당
* CDN이나 분산 데이터베이스처럼 노드 추가와 제거가 빈번한 대규모 시스템에서 특히 유용
* 해시 링(Hash Ring)
  * 해시 공간을 링 형태로 간주하여 서버와 데이터를 배치하는 방식
  * 해시 공간의 크기(예: 0 ~ 2^32-1)를 링으로 구부려 끝과 처음을 연결
  * 서버 배치: 서버의 IP나 이름을 해싱하여 링 위의 특정 위치에 배치
  * 데이터 배치: 데이터 키를 해싱하여 링 위의 특정 위치에 배치
  * 서버 조회: 데이터 위치에서 링을 시계 방향으로 탐색하여 처음 만나는 서버에 데이터 저장
  * 서버 추가/제거 시: 링의 일부 영역만 영향을 받아 재배치되는 데이터 최소화
* 가상 노드(Virtual Nodes)
  * 일관된 해싱의 기본 구현에서 발생할 수 있는 데이터 편향(Data Skew) 문제를 해결하기 위한 기법
  * 하나의 실제 노드를 여러 개의 가상 노드로 매핑하여 해시 링(Hash Ring) 위에 배치
  * 노드 개수가 적을 때 데이터가 특정 노드에 쏠리는 현상을 방지하고 부하를 균등하게 분산
  * 노드가 추가되거나 제거될 때 재배치되는 데이터의 양을 최소화하여 시스템 안정성을 높임

### 블룸필터
<hr/>

* 원소가 집합에 속하는지 여부를 검사하는데 사용되는 확률적 자료 구조
* 특징
  * 공간 효율성: 매우 적은 메모리를 사용하여 대량의 데이터를 처리할 수 있음
  * 확률적 결과: "집합에 없다"는 확실하지만, "집합에 있다"는 확률적임 (False Positive 가능성 존재)
  * 삭제 불가능: 기본 블룸필터에서는 원소 삭제가 불가능 (Counting Bloom Filter 등으로 해결 가능)
* 동작 원리
  * 비트 배열(Bit Array)과 여러 개의 해시 함수를 사용
  * 데이터 추가 시: 데이터를 여러 해시 함수에 통과시켜 나온 인덱스에 해당하는 비트를 1로 설정
  * 데이터 조회 시: 데이터를 동일한 해시 함수들에 통과시켜 나온 인덱스의 비트가 모두 1인지 확인
    * 하나라도 0이면 -> 집합에 없음 (확실)
    * 모두 1이면 -> 집합에 있을 수 있음 (확률적)
* 사용 사례
  * 데이터베이스: 디스크 접근 전 데이터 존재 여부 확인 (불필요한 디스크 I/O 감소)
  * CDN: 캐시된 데이터가 있는지 빠르게 확인
  * 웹 크롤러: 이미 방문한 URL인지 확인
  * 암호화폐: 지갑 주소 유효성 검사

### 카운트-민 스케치 (Count-Min Sketch)
<hr/>

* 데이터 스트림에서 요소의 빈도수를 근사적으로 계산하는 확률적 자료 구조
* 특징
  * 공간 효율성: 매우 적은 메모리로 대규모 데이터의 빈도를 추적 가능
  * 과대평가 가능성: 실제 빈도보다 높게 측정될 수 있지만, 낮게 측정되지는 않음
* 동작 원리
  * 2차원 배열(d x w)과 d개의 해시 함수를 사용
  * 데이터 추가 시:
    * 데이터를 d개의 해시 함수에 통과시켜 각 행(row)의 인덱스(column)를 구함
    * 해당 위치의 카운터 값을 1 증가시킴
  * 빈도 조회 시:
    * 데이터를 d개의 해시 함수에 통과시켜 각 행의 카운터 값을 확인
    * 확인된 값들 중 **최솟값(Minimum)**을 해당 데이터의 빈도로 반환 (충돌로 인해 값이 커질 수 있으므로 최솟값이 가장 근사치)
* 예시
  * 배열 크기: 3 x 5 (3개의 해시 함수, 너비 5)
  * 데이터 "A" 추가: 해시 결과가 [0, 2, 4]라면 (0,0), (1,2), (2,4) 위치의 값을 1 증가
  * 데이터 "B" 추가: 해시 결과가 [0, 3, 1]라면 (0,0), (1,3), (2,1) 위치의 값을 1 증가
    * (0,0) 위치는 "A"와 "B"가 충돌하여 값이 2가 됨
  * "A" 조회: (0,0)=2, (1,2)=1, (2,4)=1 중 최솟값인 1을 반환 (정확)
* 사용 사례
  * 네트워크 트래픽 분석: 가장 많이 방문한 IP 주소 식별 (Heavy Hitters)
  * 검색어 트렌드: 인기 검색어 순위 추적
  * 자연어 처리: 단어 빈도수 계산

### 하이퍼 로그로그 (HyperLogLog)
<hr/>

* 대규모 데이터 집합에서 고유 원소의 개수(Cardinality)를 추정하는 확률적 자료 구조
* 특징
  * 극도의 메모리 효율성: 수십억 개의 고유 값을 추적하는 데 1.5KB 미만의 메모리만 필요
  * 오차율: 표준 오차는 약 0.81%로 매우 낮음
* 동작 원리
  * 확률적 관찰: 무작위 데이터 스트림에서 이진수 표현의 선행 0(Leading Zeros)의 개수를 관찰하여 전체 개수를 추정
    * 예: 선행 0이 3개인 경우(0001...)는 약 2^4 = 16번의 시도 중 한 번 발생할 확률
  * 버킷팅(Bucketing): 데이터를 여러 버킷으로 나누고 각 버킷에서 최대 선행 0의 개수를 기록하여 평균을 냄 (조화 평균 사용)
* 예시
  * 데이터 "user1" 해시 -> 00101... (선행 0: 2개) -> 버킷 기록: 2
  * 데이터 "user2" 해시 -> 00001... (선행 0: 4개) -> 버킷 기록: 4
  * 데이터 "user3" 해시 -> 01101... (선행 0: 1개) -> 버킷 기록: 1
  * 추정: 각 버킷의 값을 조화 평균하여 전체 고유 사용자 수 계산
* 사용 사례
  * 웹사이트 방문자 수(UV) 집계: 하루 수억 명의 방문자 중 고유 방문자 수 계산
  * 데이터베이스 쿼리 최적화: 테이블의 카디널리티를 추정하여 실행 계획 수립
  * 네트워크 모니터링: 고유 IP 주소 개수 파악