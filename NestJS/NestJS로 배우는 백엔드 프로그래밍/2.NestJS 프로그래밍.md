
## Nest.JS

----------------------------

### Decorator

* Nest 는 데커레이터(decorator)를 적극 활용한다.
* 데커레이터는 횡단 관심사를 분리하여 관점지향 프로그래밍을 적용한 코드를 작성할수 있다.
```
class CreateUserDto{
    @IsEmail()
    @MaxLength(60)
    readonly email:string;

    @IsString()
    @Matches(/^[A-Za-z\d!@#$%^&*()]{8,30}$/)
    readonly password:string;
}
```
* 데코레이터는 아직 실험적인 기능이다
* tsconfig.json
```
{
  "compilerOptions": {
    ...
    "experimentalDecorators": true,
    ...
  }
}
```
* experimentalDecorators 옵션을 true 로 설정해야 사용할수 있다.
* 실험적이지만 매우 안정적인 기능이다.
* `@expression`과 같은 형식으로 사용하는데 런타임에 호출되는 함수여야 한다.
* 데커레이터를 여러개 사용하는것은 수학의 함수 합성과 같이 진행된다.
* 각 데커레이터는 위애서 아래로 평가(evaluate)되고 아래에서 위로 호출(call)된다.
```
function first(){
    console.log('first : factory evaluated')
    return function (target:any, propertyKey:string, descriptor:PropertyDescriptor){
        console.log('first: called')
    }
}
function second(){
    console.log('second : factory evaluated')
    return function (target:any, propertyKey:string, descriptor:PropertyDescriptor){
        console.log('second : called')
    }
}
class ExampleClass{
    @first()
    @second()
    method(){
        console.log('method called')
    }
}
// first : factory evaluated
// second : factory evaluated
// second : called
// first : called
// method called
```
* 클래스 데커레이터는 클래스 바로 앞에 선언된다.
* 클래스 데커레이터는 클래스 생성자와 적용되어 클래스 정의를 읽거나 수정할수 있다.
* 선언 파일과 선언 클래스 내에서 사용할수 없다.
```
function reportableClassDecorator<T extends {new(...args:any[]):{}}>(constructor:T){ // 1
    return class extends constructor{ // 2
        reprotingURL = 'http://www.example.com' // 3
    }
}
@reportableClassDecorator
class BugReport{
    type='report'
    title:string
    constructor(t:string) {
        this.title = t
    }
}
const bug = new BugReport('Needs dark mode')
console.log(bug)
// {type:'report, title:'Needs dark mode', reprotingURL = 'http://www.example.com'}
```
1. 클래스 데커레이터 펙토리 생성자. new 키워드와 함께 어떤 형식의 인수도 받을수 있는 타입을 상속받는 제네릭 타입T 를 가지는 생성자를 팩터리 메서드의 인수로 전달
2. 클래스 데커레이터는 생성자를 리턴하는 함수여야 한다.
3. 클래스 데커레이터가 적용되는 클래스에 새로운 reportingURL 이라는 새로운 속성을 추가한다.

* 메서드 데커레이터는 메서드 바로 앞에 선언된다.
* 메서드의 속성 설명자(property descriptor)에 적용되고 메서드의정의를 읽거나 수정할수 있다.
* 선언파일, 오버로드 메서드, 선언 클래스에 사용할수 없다.
* 메서드 데커리이터는 3개의 인수를 가진다.
  * 정적 멤버가 속한 클래스의 생성자 함수이거나 인스턴스 멤버에 대한 클래스의 프로토 타입
  * 멤버의 이름
  * 멤버의 속성 설명자 PropertyDescriptor
* 만약 메서드 데커레이터가 값을 반환한다면 이는 해당 메서드의 속성 설명자가 된다.
```
function HandleError(){
    return function (tartget:any, propertyKey:string, descriptor:PropertyDescriptor){ // 1
        console.log(tartget)        // 2
        console.log(propertyKey)    // 3
        console.log(descriptor)     // 4
        
        const method = descriptor.value // 5
        descriptor.value = function (){
            try {
                method()
            }catch (e){
            //     에러 핸들링 로직 구현 // 7
                console.log(e)       // 8
            }
        }
    }
}
class Greeter{
    @HandleError()
    hello(){
        throw new Error('테스트에러')
    }
}
const t = new Greeter();
t.hello();
```
1. 메서드 데커이터가 가져야하는 3개의 인수 이중 PropertyDescriptor 는 객체 속성의 특성을 기술하는 객체로 enumerable 외에도 여려속성이 있다. enumerable 이 true 면 열거형이라는 뜻이다.
```
interface PropertyDescriptor{
    configurable?:boolean   // 속성의 정의를 수정할수 있는지 여부
    enumerable?:boolean     // 열거형인지 여부
    value?:any              // 속성값
    writable?:boolean       // 수정가능 여부
    get?():any              // getter
    set?(v:any):void        // setter 
}
```
2. 출력 결과는 `{constructor:f, hello:f}`이다. 데커레이터가 선언된 메서드 hello 가 속해있는 클래스의 생성자와 프로토타입을 가지는 객체임을 알수있다.
3. 함수 hello 가 출력된다.
4. hello 함수가 처음 가지고있던 설명자가 출력된다. 출력결과는 `{value:f, writable:true, enumerable:false, configurable:true}`이다.
5. 설명자의 value 속성으로 원래 정의된 메서드를 저장한다.
6. 원래 메서드를 호출한다.
7. 원래 메서드를 수행하는 과정에서 발생한 에러를 핸들링하는 로직을 이곳에 구현한다.
8. Error: 테스트 에러가 출력된다.

* 접근자 데커레이터
* 접근자 바로앞에 선언한다.
* 접근자의 속성 설명자에 적용되고 접근자의 정의를 읽거나 수정할수 있다.
* 선언파일과 선언 클래스에는 사용할수 없다.
* 접근자 데커레이터가 반환하는 값은 해당 멤버의 속성 설명자가 된다.
```
function Enumerable(enumberable:boolean){
    return function (tartget:any, propertyKey:string, descriptor:PropertyDescriptor){
        descriptor.enumerable = enumberable; // 1
    }
}
class Person{
    constructor(private name:string) {} // 2
    
    @Enumerable(true)       // 3
    get getNAme(){
        return this.name
    }
    @Enumerable(false)      // 4
    set setName(name:string){
        this.name = name;
    }
}
const person = new Person('Dexter');
for (const key in person) {
    console.log(`${key} : ${person[key]}`)  // 5 
}
```
1. 설명자의 enumerable 속성을 데커레이터의 인수로 결정한다.
2. name 은 외부에서 접근하지 못하는 private 멤버이다.
3. getter getName 함수는 열거가 가능하도록 한다.
4. setter setName 함수는 열거가 불가능하도록 한다.
5. 결과를 출력하면 getName 은 출력 되지만 setName 은 열거하지 못하게 되었기 때문에 for 문에서 key 로 받을수 없다.
```
name: Dexter
getName: Dexter
```

* 속성 데커레이터
* 클래스의 속성 바로 앞에 선언된다.
* 선언파일, 선언클래스 에서는 사용하지 못한다.
* 속성 데커레이터는 두개의 인수를 가지는 함수이다.
  * 정적 멤버가 속한 클래스의 생성자 함수이거나 인스턴스 멤버에 대한 클래스의 프로토타입
  * 멤버의 이름
* 메서드 데커레이터나 접근자 데커레이터와 비교해보면