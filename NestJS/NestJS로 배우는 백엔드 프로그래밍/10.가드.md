
## 권한 확인을 위한 가드: JWT 인증/인가

---------------------

### 가드

* 인증을 미들웨어로 구현하는것은 좋은 사례이다.
* 헤더에 JWT 토큰을 실어 보내고 이 토큰을 통해 요청자가 라우터에 접근 가능한지 확인하는 방식이 많이 사용된다.
* 인가 는 인증을 통과한 유저가 요청한 기능에 대해 사용권한이 있는지 판별하는것을 말한다.
* 인가는 가드를 이용하여 구현하는것이 좋은 사례이다.
* 인증과 인가가 실패할 경우 HTTP 상태 코드는 각각 401 Unauthorized 와 403 Forbidden 이다.
* 미들웨어는 실행 콘텍스트에 접급하지 못하고 단순히 자신의 일을 한후 next() 를 호출한다.
* 즉 다음 어떤 핸들러가 실행될지 알수 없다
* 이에 비해 가드는 실행 콘텍스트 인스턴스에 접근할수 있어 다음 실행 작업을 정확히 할고 있다.

### 가드를 이용한 인가

```
@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    return this.validateRequest(request)
  }
  private validateRequest(request:any){
    return true;
  }
}
```

### 실행 컨텍스트

* canActivate 함수는 ExecutionContext 인스턴스를 인수로 받는다.
* ExecutionContext 는 ArgumentsHost 를 상속 받는데 요청과 응답에 대한 정보를 가지고 있다.
* switchToHttp() 함수를 사용하여 필요한 정보를 가져올수 있다.
```
export interface ExecutionContext extends ArgumentsHost {
    getClass<T = any>(): Type<T>;
    getHandler(): Function;
}
export interface ArgumentsHost {
    getArgs<T extends Array<any> = any[]>(): T;
    getArgByIndex<T = any>(index: number): T;
    switchToRpc(): RpcArgumentsHost;
    switchToHttp(): HttpArgumentsHost;
    switchToWs(): WsArgumentsHost;
    getType<TContext extends string = ContextType>(): TContext;
}
export interface HttpArgumentsHost {
    getRequest<T = any>(): T;
    getResponse<T = any>(): T;
    getNext<T = any>(): T;
}
```
* 얻은 정보는 내부 규칙을 평가하는 validateRequest 함수를 통해 인가를 진행한다.
* false 를 리턴할 경우 403 Forbidden 에러가 발생한다.
* 다른 에러를 리턴하고 싶을경우 직접 다른 예외를 생성해서 던져야 한다.

### 가드 적용

* 가드를 적용하는 방법은 예외 필터를 적용하는것과 유사하다.
* 컨트롤러 범위 또는 메서드 범위로 적용하고자 한다면 @UserGuards(AuthGuard)같이 사용한다.
* AuthGuard 인스턴스 생성은 Nest 가 맡아서 하고 여러 종류 가드를 적용하고 싶으면 쉼표로 이어선언한다.
```
@UseGuards(AuthGuard)
@Controller()
export class AppController {
  ....
  @UseGuards(AuthGuard)
  @Get()
  getHello():string{
    return 'hello';
  }
  ....
}
```
* 전역으로 가드를 적용하고 싶다면 부트스트랩 과정을 수정해야 한다.
```
async function bootstrap() {
  ....
  app.useGlobalGuards(new AuthGuard()) // 1
  ....
}
bootstrap();
```
1. useGlobalGuards 함수를 사용하여 전역 가드를 설정한다.
* 가드에 종속성 주입을 해서 다른 프로바이더를 주입해서 사용하고 싶다면 커스텀 프로바이더로 선언해야 한다.
```
@Module({
  ....
  providers: [{
      provide: APP_GUARD,
      useClass: AuthGuard,
  }],
  ....
})
```

### 인증

* 사용자 리소스를 보호하기 위해서는 서버에 접속하는 클라이언트가 리소스의 주인인지 확인하는 인증 절차를 걸쳐야 한다.
* 사용자가 아이디와 비밀번호로 로그이니 하면 로그아웃 할때까지는 사용자가 가진 권한 내에서 서비스를 이용할수 있다.
* 주로 세션이나 토큰을 이용한 방식을 사용한다.

### 세션 기반 인증

* 세션은 로그인에 성공한 유저가 서비스를 사용하는 동안 저장하고 있는 유저 정보이다.
* 서버는 세션을 생성하고 나서 세션을 데이터베이스에 저장하고 이후 사용자의 요청에 포함된 세션 정보가 세션 DB 에 저장되어 있는지 확인한다.
* 브라우저에는 데이터를 저장할수 있는 공간이 있다.
  * 새로운 탭을 열거나 창을 열면 데이터가 삭제되는 세션 저장소
  * 창을 닫아도 데이터가 남아있는 로컬 저장소
  * 간단한 데이터를 저장할수 있는 쿠키
* 세션 방식의 단점은 악의적인 공격자가 브라우저에 저장된 데이터를 탈취할수 있다는 것이다.
* 이를 방지하기 위해 HTTPS 로 암호화된 통신을 하고 세션에 유효기간을 정해둔다.
* 유효기간이 만료된 세션인 경우 다시 로그인을 유도하게 한다.
* 세션은 서버의 저장소에 저장되고 빠른 응답을 위해 메모리에 상주시키는 경우가 많다.
* 이로인해 서비스에 사용자가 몰렸을 경우 요청다마 세션을 확인해야 하므로 DB 에 많은 부하를 일으킨다.
* 클라우드를 이용해서 서버와 DB 를 유연하게 증설할수 있다.
* Redis 같은 인프라를 이용하여 메모리에 상주하는 세션을 좀더 빠르게 처리하도록 하는 방법도 있다.
* 서비스가 여러 도메인으로 나누어져 있는 경우 CORS 문제로 인해 도메인간 세션 공유하도록 하기 위한 처리가 번거롭다.

### 토큰 기반 인증

* 토큰은 사용자가 로그인 했을때 서버에서 토큰을 생성하고 전달하고 따로 저장소에 저장하지 않는 방식이다.
* 로그인 이후 요청에대해 클라이언트가 전달한 토큰 검증만 수행한다.