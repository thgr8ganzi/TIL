
## Nest.JS 로 배우는 백엔드 프로그래밍

--------------------------------

## Nest 의 장점

* Node.js 에 기반을 둔 웹 API 프레임 워크로 Express 또는 Fastify 프레임워크를 래핑하여 동작한다.
* Fastyfy 사 Express 보다 2배정도 빠르다. 그러나 Express 가 가장 대중적이다.
* Nest.js 는 앵귤러의 영향을 받아 모듈/컴포넌트 기반으로 재사용성을 높인다.
* IOC, DI, AOP 같은 객체지향 개념도 도입하였다.
* 그 외에도 최신 ECMA 스크립트 지원, 타입스크립트 CQRS, HTTP 헤더 보안, 인터셉터, 편리한 설정, 다양한미들웨어, 스케줄링, 로깅, 테스팅, 스웨거, ORM 을 지원한다.
* SvelteKit 은 사용자의 브라우저에서 프레임워크 소스를 다운로드 하지 않는 방식으로 빠른 실행능력을 보여준다.
* Remix 는 Next.js 와 유사한 SSR 프레임워크이다.
* Astro 는 자바스크립트를 걷어내 정적사이트로 변환후 사용자의 상호작용이 필요할때만 다운로드 한다.
* Next.js, Nuxt 는 리액트와 vue.js 로 만든 SSR 프레임워크이다.
* Gatsby 는 정적페이지 생성기이다. 블로그같이 내용이 사용자 반응에 바뀌지 않는 웹사이트를 쉽게 생성해준다.
* Next.js, Gatsby, Nuxt 는 프론트 프레임워크다
* Nest.js 는 Express 에 비해 생산성이 좋고 모듈화가 편하다.

### 프로젝트 생성

* Node.js 를 설치하면 npm 이 설치가 되는데 `npm i -g @nestjs/cli`커맨드를 사용하여 프로젝트 생성이 가능하다.
  * i 는 install 의 약자 -g 는 컴퓨터 글로벌 환경에 설치한다는것으로 모든 디렉터리에서 해당패키지를 실행할수 있다. `npm root -g`로 확인할수 있다.
* `nest new project-name`으로 프로젝트 이름을 설정해줄수 있다.
* `npm run start` 나 `npm run start:dev`로 실행할수 있다.
  * 개발단계에선 dev 옵션을 주는게 좋은데 `nest start --watch`옵션으로 실행되어 소스코드 변경을 감지하고 코드 저장시마다 서버를 다시 구동해준다.
* main.ts 안에 포트 번호가 설정되어 있다.
```
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();

```

### 해야할것

* 환경 변수 설정
  * 서버는 다양한 환경(로컬, 테스트 서버(stage), 운영서버(production))에서 구동되는데 각각 환경변수를 다르게 구성할수 있다.
* 요청 유효성 검사
  * 프론트에서 들어오는 요청은 잘못된 값을 가질수가 있는데 핵심 로직전 값이 올바른지 판단.
* 인증
  * 사용자가 리소스에 접근하기위해 권한이 필요한데 인증과정을 거친후 토큰을 발급해주는 방식으로 권한을 부여
* 로깅
  * 서버 운용시 로그는 이슈가 발생했을때 원인을 파악하는데 유욕하게 사용된다. 사내 사용자가 무슨동작을 수행했는지 감사로그를 남겨서 외부에 제출해야 할수도 있다.
* 헬스 체크
  * 서버가 잘 실행중인지, 상태가 양호 한지 주기적으로 검사한다.
* CQRS
  * 복잡한 소프트웨어는 유지보수가 어려운데 DB에 변형을 가하는 명령과, 조회하는 명력을 분리함으로 성능, 확장, 보안을 강화할수 있다.
* 클린 아키텍처
  * 어니억 아키텍처, 헥사고날 아키텍처에서 발전한 클린 아키텍처는 소프트웨어의 계층을 분리하고 저수준이 고수준을 의존하도록 한다.
  * 의존방향이 바뀌는 경우 의존관계 역전원칙(DIP)를 활용하여 작성할수 있어야 한다.
* 단위테스트
  * 단위테스트는 개발자가 수행하는 최소 단위 테스트로 코드가 동작이 원하는 결과가 나오는지 체크한다.

### 기초지식

|  프레임워크   |     개발언어      |                                                      설명                                                      |
|:--------:|:-------------:|:------------------------------------------------------------------------------------------------------------:|
|   리액트    | 자바스크립트/타입스크립트 |         1.싱글페이지 어플리케이션이나 모바일 웹개발 2.가장 인기있는 프론트 프레임워크<br/>3.virtual DOM 사용<br/>4.메타가 만들었고 커뮤니티에서 유지보수         |
|  Vue.js  | 자바스크립트/타입스크립트 |              1.리액트와 함께 인기있는 프론트프레임워크 SPA 구성가능<br/>2.MVVM 패턴에서 VM 레이어에 해당하는 라이브러리<br/>3.속도가 빠르다.              |
|   앵귤러    |    타입스크립트     |              1.SPA 를 위한 프레임워크면서 SSR 지원.<br/>2.모듈/컴포넌트 기반으로 작성하며 재사용성 높다.<br/>3.21년 말 LTS 지원 중단               |
|   스벨트    | 자바스크립트/타입스크립트 |                  1.리액트 뷰를 제치고 최근 인기 급부상 프론트 프레임워크<br/>2.가상 DOM 을 사용하지 않음.<br/>3.적은코드로 구현 가능                  |
| Express  | 자바스크립트/타입스크립트 |             1.가장 많은 사용자를 가진 Node 기반 프레임워크<br/>2.가볍게 서버 구동 가능<br/>3.Nest와 같이 Ecpress 기반 프레임워크 존재              |
|   스프링    |    자바/코틀린     | 1.국내에서 가장 인기가 높은 자바 프레임워크<br/>2.전자정부 표준프레임워크를 이용하는 프로젝트를 이용하려면 필수<br/>3.IOC,DI,AOP 같은 객체지향 프로그래밍 기법을 쉽게 적용가능 |
| 아파치 스트러처 |      자바       |                          1.Jsp 에 사용되는 프레임워크<br/>2.MVC 패턴 기반의 웹 애플리케이션 작성<br/>3.레거시                           |
|    장고    |      파이썬      |                                     1.파이썬 기반 웹 프레임워크 표준.<br/>2.MVC 패턴 사용                                     |
|   Gin    |      Go       |                                               1.Go 언어 기반 프레임워크                                               |
| 루비 온 레일즈 |      루비       |                        1.간결한 문법 뛰어난 생산성으로 인기.<br/>2.ActiveRecord 를 이용해 쿼리를 쉽게 다룰수 있다.                        |

* SPA 는 SSR 과 다르게 서버로부터 매 요청에 최소한의 데이터만 응답을 받고 화면 구성 로직을 프런트에서 처리 화면 깜박거림이 줄어듬
* 반면 첫화면 진입시 프런트 애플리케이션을 다운로드 해야 하므로 로딩이 김

### 프레임 워크 선택시 고려 사항

* 개발문서
  * 쉽게 이해 가능한 개발문서는 사용자의 생산성을 올려준다.
* 사용자 수
  * 사용자 수가 많으면 안정적으로 운용되고 커뮤니티를 통해 답을 얻을수 있음
* 활성 커뮤니티
  * 커뮤니티로 사용자수를 가늠해볼수 있음
* 깃허브 스타수, 이슈대응
  * 대부분 프레임워크는 오픈소스로 깃허브에 있는데 스타수는 인정도와 비례한다. 또 레포트로 최신 트렌드를 대응하고 있는지 확인가능

### Node.js

* Node 는 브라우저 내에서 작동하던 JS 를 서버를 구동할수 있게 해준다.
* 2008년 구글은 크롬 브라우저를 출시하였는데 자체 개발한 V8 엔진을 내장했고 속도가 개선되었다.
* NPM 이라는 패키지 관리 시스템으로 누구나 사용가능하고 자신이 만든 라이브러리를 등록하여 공개할수 있다.
* 사내 패키지로 관리하고자 하면 유료로 비공개 등록도 가능하다.
* 2020년 깃허브는 NPM 을 인수하고 MS 가 깃허브를 인수했다.

### 단일 스레드 논블로킹 I/O 기반 비동기 방식

* 멀티스레딩은 각 작업을 처리하기 위해 스레드를 만들고 빠르다는 장점이 있지만 공유 자원을 관리하는 노력이 들고 동기화를 잘못 작성하면 락에 걸리고 스레드가 늘어날때마다 메모리를 소모하게 된다.
* Node 는 애플리케이션에선 단일 스레드 이지만 백그라운드에서는 스레드 풀을 구성해 개발자 대신 플랫폼을 관리 해준다.
* 웹서버를 운용할땐 CPU 코어를 분산해서 관리하므로 실제 작업은 여러개의 코어에서 별개로 처리된다.

### 장단점

* 단일 스레드 이벤트 기반  비동기 방식은 서버의 자원에 크게 부하를 가하지 않는다. 이는 대규모 네트워크 애플리케이션을 개발하기에 적합하다. 그러나 스레드에 문제가 생기면 애플리케이션 전체가 오류를 일으킬 위험이 있다.
* 멀티스레딩시 교착 상태에 빠질수 있다.
* Node 는 컴파일 언어의 처리속도에 비해 성능이 떨어진단 점인데 계속 발전중이다.
* 여러 이벤트를 동시에 처리하면 콜백 지옥에 빠질수도 있다.

### 이벤트 루프

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```
* 이벤트 루프는 시스템 커널에서 가능한 작업이 있다면 그 작업을 커널에 이관한다.
* 각 단계에는 해단 단계에서 실행되는 작업을 저장하는 큐가 있다.
* 이벤트 루프의 구성요소는 아니지만 nextTickQueue 와 microTaskQueue 가 존재한다.
* nextTickQueue 와 microTaskQueue 에 들어 있는 작업은 이벤트 루프가 어느 단계에 있든지 실행될수 있다.
* 자바스크립트는 유휴 상태, 준비 단계를 제외한 어느 단계에서나 실행될수 있다.
* `node main.js` 명령어로 Node.js 앱을 콘솔에서 실행하면 이벤트 루프를 생성한 다음 메인 모듈인 main.js 를 실행한다.
* 이 과정에서 생성된 콜백들이 각 단계에 존재하는 큐에 들어가게 되는데 메인 모듈의 실행을 완료한후 이벤트 루프를 계속 실행할지 결정한다.
* 큐가 모두 비었다면 루프를 빠져나가고 종료한다.

### 타이머 단계

* 이벤트 루프는 타이머  단계에서 시작한다.
* setTimeout 이나 setInterval 같은 함수를 통해 만들어진 타이머들을 큐에 넣고 실행한다.
* 타이머들은 최소힙(main heap) 으로 관리 된다.
* 힙을 구성할때 기준으로 실행할 시각이 가장 적게 남은 타이머가 힙의 루트가 된다.
* 최소 힙의 들어있는 타이머들을 순차적으로 찾아 실행한 후 힙을 재구성한다.

### 대기 콜백 단계

* 대기 단계(pending callbacks phase)큐에 들어있는 콜백들은 현재 돌고있는 루프 이전 작업에서 큐에 들어온 콜백이다.
* TCP 핸들러 내에서 비동기의 쓰기 작업을 한다면 TCP 통신과 쓰기 작업이 끝난후 해당 작업의 콜백이 큐에 들어온다. 에러핸들러도 들어온다.
* 타이머 단계를 거쳐 들어오면 이전 작업들이 pendin_queue 에 대기중인지 검사하고 실행 대기중이라면 시스템 실행 한도에 도달할때 까지 꺼내 실행한다.

### 유휴, 준비 단뎨

* 유휴(idel phase)는 틱마다 실행된다.
* 준비(prepare pahas)는 매 폴링 직전에 실행된다.
* node 내부 동작을 위한것이다.

### 폴 단계

* 가장 중요한 폴(poll)단계 이다.
* 새로운 I/O 이벤트를 가져와 관련 콜백들 수행한다.
* 새로운 커넥션을 맺거나 데이터 처리를 받아들인다(소켓, 파일읽기).
* 이 단계가 가지고 있는 큐는 watch_queue 이다.
* 폴 단계에 진입 후 watch_queue가 비어있지 않다면 큐가 비거나 실행 한도에 다다를때까지 동기적으로 모든 콜백을 실행한다.
* 큐가 비면 곧바로 다음 단계로 이동하지 않고 check_queue, pending_queue, closing_callback_queue  에 남은 작업이 있는지 검사한후 다음 단계로 이동한다.
* 모든 큐가 비어있다면 잠시 대기하게 된다(타이머 최소 힙의 첫번째 타이머를 꺼내어 지금 실행할수 있는 상태라면 그 시간만큼 대기후 다음단계로 이동)
* 이렇게 동작하는 이유는 바로 타이머로 넘어가도 어자피 타이버를 수행할 시간이 되지 않기 때문에 한번 더 도는건 비효율적이라서

### 체크단계

* setImmediate 의 콜백만들 위한 단계
* 큐가 비거나 시스템 실행 한도에 도달할때 까지 콜백을 수행한다.

### 종료 콜백

* 종료콜백(close callbacks phase)단계 에선 close 나 destroy 이벤트 타입의 콜백이 처리된다.
* 이벤트 루프는 종료 콜백 단계를 마치고 나면 다음 루프에서 처리해야할 작업이 남아 있는지 검사한다.
* 작업이 남아 있다면 타이머 단계부터 한번더 루프를 돌고 아니면 루프를 종료한다.

### nextTickQueue, microTaskQueue

* nextTickQueue 는 `process.nextTick()` API 콜백들을 가지고 있다.
* microTaskQueue 는 resolve 된 Promise 의 콜백들 가지고 있다.
* 이 두가지는 이벤트 루프의 일부가 아닌 libuv 라이브러리에 포함된것이 아니라 Node.js 에 포함된 기술이다.
* 이 두 큐에 들어있는 콜백은 단계를 넘어가는 과정에서 먼저 실행된다.
* nextTickQueue 는 microTaskQueue 보다 높은 우선 순위를 가지고 있다.

### 패키지 의존성 관리

* package.json 역활
  * 애플리케이션이 필요로 하는 패키지 목록을 나열한다.
  * 다른 개발자와 같은 빌드 환경을 구성할수 있다.
  * 각 패키지는 시맨틱 버저닝 규칙으로 필요한 버전을 기술한다.
    * (패키지 버전명을 숫자로 관리하는 방법으로 많이 사용된다.)
    * `[Major].[Minor].[Patch]-[Label]`
    * Major : 이전 버전과 호환이 불가능할때 숫자를 하나 증가시킨버전 major 버전을 바꿀시 반드시 하우호환성이 깨진 기능(breakig change)목록을 확인하고 코드를 수정한다.
    * Minor : 기능이 추가되는 경우 숫자를 증가시킴. 이전버전과 하위호환 가능
    * Patch : 버그 수정 패치를 적용한 버전
    * Label : 선택사항으로 pre, alpha, beta 같이 버전에 대한 부가 설명을 붙이고자할때 문자열로 작성
    * ver : 완전히 일치하는버전
    * =ver : 완전히 일치하는버전
    * \>ver : 큰버전 
    * \>=ver : 크거나 같은 버전
    * \<ver : 작은버전
    * \<=ver : 작거나 같은버전
    * ~ver : 버전 범위
    * ^ver : SemVer 규약을 따른다는 가정에서 동작하는 규칙
    * ~1.0, 1.0.x  : 1.0.0 이상 1.0.0 미만 버전
    * ^1.0.2 : 1.0.2 이상 2.0 미만 버전
* package-lock.json 
  * 프로젝트 루트 디렉터리에서 npm install 명령이 수행하면 node_module 디렉터리와 package-lock.json 파일이 생성된다.
  * package-lock.jsin 파일은 node_modules 나 package.json 파일의 내용이 바뀌면 npm i 명령을 수행할때 자동 수정된다.
  * node_modules 는 프로젝트가 필요로하는 패키지들이 실제로 설치되어있다.
  * 애플리케이션은 런타입시 node_moduels 를 참조한다.

### package.json 파일 분석

```
{
  "name": "book-nestjs-backend",                         // 1
  "private": true,                                       // 2
  "version": "2.0.0",                                    // 3
  "description": "Examples for book-nestjs-backend",     // 4
  "license": "MIT",                                      // 5
  "scripts": {                                           // 6
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {                                     // 7
    "@nestjs/common": "^9.0.0",
    "@nestjs/core": "^9.0.0",
    "@nestjs/mapped-types": "^1.1.0",
    "@nestjs/platform-express": "^9.0.0",
    "reflect-metadata": "^0.1.13",
    "rimraf": "^3.0.2",
    "rxjs": "^7.3.0"
  },
  "devDependencies": {                                  // 8
    "@nestjs/cli": "^9.0.0",
    "@nestjs/schematics": "^9.0.0",
    "@nestjs/testing": "^9.0.0",
    "@types/express": "^4.17.13",
    "@types/jest": "^27.0.1",
    "@types/node": "^16.7.1",
    "@types/supertest": "^2.0.11",
    "@typescript-eslint/eslint-plugin": "^4.29.2",
    "@typescript-eslint/parser": "^4.29.2",
    "eslint": "^7.32.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^3.4.1",
    "jest": "^27.0.6",
    "prettier": "^2.3.2",
    "supertest": "^6.1.6",
    "ts-jest": "^27.0.5",
    "ts-loader": "^9.2.5",
    "ts-node": "^10.2.1",
    "tsconfig-paths": "^3.10.1",
    "typescript": "^4.3.5"
  },
  "jest": {                                             // 9
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
```
* name : 패키지의 이름. version 과 함께 고유한 식별자가 된다. 패키지를 npm 에 공개하지 않는다면 선택사항이다.
* private : true 로 설정할경우 공개되지 않는다.
* version : 패키지의 버전. 공개할 패키지를 만들고 있다면 버전명에 신경을 써야 한다.
* description : 패키지에 대한 설명을 기술한다.
* license : 패키지의 라이선스를 기술한다. 공개된 패키지를 사용할때 참고해야한다.
* script : npm run 명령과 함께 수행할수 있는 스크립트이다.
* dependencies : 패키지가 의존하는 다른 패키지를 기술한다. 프로더션 환경에 필요한 패키지를 선언한다.
* devDependencies : 개발환경, 테스트 환경에만 필요한 패키지를 선언한다.
* jest : 테스팅 라이브러리 jest 를 위한 옵션 Nest 는 기본으로 jest 를 이용한 테스트를 제공한다.


