
## 인터셉터로 요청과 응답을 입맛에 맞게 바꾸기

-----------------------

### 인터셉터

* 인터셉터는 요청과 응답을 가로채서 변형을 가할수 있는 컴포넌트 이다.
* 인터셉터는 관점지향프로그래밍 에서 영향을 받았다.
  * 메서드 실행 전/후 추가 로직을 바인딩
  * 함수에서 반환된 결과를 변환
  * 함수에서 던져진 예외를 변환
  * 기본기능의 동작을 확장
  * 특정 조건에 따라 긴능ㄹ 완전히 재정의(캐싱)
* 인터셉터는 미들웨어와 수행하는 일이 비슷하지만 수행 시점의 차이가 있다
* 미들웨어는 요청이 라우트 핸들러로 전달되기 전에 동작하며 인터셉터는 요청에 대한 라우트 핸들러의 처리 전/후 호출되어 요청과 응답을 다룰수 있다.
* 미들웨어는 여러개의 조합이 가능해 각기 다른 목적을 가진 미들웨어 로직을 수행할수 있다.
* 다른 미들웨어가 다음 미들웨어에 제어권을 넘기지 않고 요청/응답 주기를 끝내는 일도 가능하다.
* 라우트 핸들러가 요청을 처리하기 전후에 어떤 로그를 남기고 싶다는 요구사항이 있다 가정하는 LoggingInterceptor 를 만든다.
```
@Injectable()
export class LoggingInterceptor implements NestInterceptor{ // 1
    intercept(context: ExecutionContext, next: CallHandler<any>): Observable<any> | Promise<Observable<any>> { // 2
        console.log('....Before') // 3
        const now = Date.now();
        return next
            .handle()
            .pipe(
                tap(() => console.log(`After...${Date.now() - now}ms`)) // 4
            )
    }
}
```
1. 인터셉터는 @nestjs/common 패키지에서 제공하는 NestInterceptor 인터페이스를 구현한 클래스이다.
2. nestIntercerptor 인터페이스의 intercept 함수를 구현해야 한다.
3. 요청이 전달되기 전 로그를 출력한다.
4. 요청을 처리한후 로그를 출력한다.
* 인터셉터를 적용하기 위한 특정 컨트롤러나 메서드에 @UseInterceptors() 를 이용한다
* 전역으로도 사용가능하다
```
async function bootstrap() {
    ....
    app.useGlobalInterceptors(new LoggingInterceptor())
    ....
}
bootstrap();

....Before
After...0ms
```
* NestInterceptor 의 정의
```
export interface NestInterceptor<T = any, R = any> {
    intercept(context: ExecutionContext, next: CallHandler<T>): Observable<R> | Promise<Observable<R>>;
}
```
* 인수로는 2개가 전달된다.
* 두번째 인수 CallHandler 인데 이 인테페이스는 handle() 메서드를 구현해야 한다.
* handle() 메서드는 라우트 핸들러에서 전달된 응답 스트림을 돌려주고 RxJS 의 Observable 로 구현되어 있다.
* 만약 handle() 메서드를 호출하지 않으면 라우터 핸들러가 동작하지 않는다.
* handle()을 호출하고 Observable 을 수신한 후 응답 스트림에 추가 작업을 수행할수 있다.

### 응답과 예외 매핑

* 