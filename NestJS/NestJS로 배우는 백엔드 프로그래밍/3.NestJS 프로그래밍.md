
## 애플리케이션의 관문: 인터페이스

------------

### 컨트롤러

* Nest 의 컴트롤러는 MVC 패턴이다.
* 컨트롤러는 들어오는 요청(request)을 받고 처리된 결과는 응답(response)하는 인터페이스 역활을 한다.
* 컨트롤러는 엔드포인트 라우팅 메커니즘을 통해 각 컨트롤러가 받을수 있는 요청을 분류한다.
* `nest g controller User`로 컨트롤러를 생성하고 `nest -h`로 구성요소를 확인할수 있다.
* `nest g resource Users`로 Users 리소스를 생성하면 module, controller, service, entity, dto, 테스트코드를 자동생성해준다.

### 라우팅

```
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(+id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id);
  }
}
```
* 데커레이터를 기술하여 애플리케이션의 핵심 로직에 집중할수 있게 해준다.
* @Controller 데커레이터를 클래스에 선언하는것으로 해당 클래스는 컨트롤러의 역활을 하게 된다.
* 라우팅 경로는 데커레이터의 인수로 관리할수 있다.
* @Controller 의 인수로도 라우팅 경로를 지정하면 해당 라우팅 경로의 접두어로 들어간다.

### 와일드 카드 사용
```
@Get('he*lo')
getHello():string{
    return this.appService.getHello();
}
```
* 라우팅 패스에 별표(*)를 사용하면 문자열 가운데 어떤 문자가 와도 상관없이 라우팅 패스를 구성하겠다는 뜻이다.
* 그 외에도 ?, +, () 문자 역시 정규표현식에서의 와일드 카드와 동일하게 동작한다. 단 하이픈(-), 점(.) 등은 예외다.

### 요청객체

```
import { Request } from 'express';
import { Controller, Get, Query, Redirect, Req } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) { }

  @Get()
  getHello(@Req() req: Request): string {
    console.log(req);
    return this.appService.getHello();
  }
}
```
* 요청객체(req)는 HTTP 요청을 나타낸다.
* 요청 객체 안에는 쿼리스트링, 매개변수, 헤더와 본문 외 많은 정보가 있다.
* Nest는 @Query(), @PAram(key?:string), @Body() 데커레이터를 이용해서 요청에 포함된 쿼리 매개변수, 패스, 본문을 받을수 있다.

### 응답

* 각 요청의 성공 응답 코드는 POST 일 경우 201 이고 나머지는 200이다.
* 또한 응답 본문은 스트링 값을 가지는데 Controller 의 각 메서드가 리턴하는 값이다.
* Nest 는 string, number, boolean 과 같은 자바스크립트 원시타입은 직렬화 없이 바로 보내지만 객체를 리턴한다면 JSON 으로 직렬화를 자동해준다.
* Express 는 @Res 데커레이터를 이용해 응답 코드를 객체로 다룰수 있고 Nest 는 @HttpCode 를 이용하여 응답코드를 바꿀수 있다.
```
@Get()
findAll(@Res() res, @Query() dto: GetUsersDto) {
  console.log(dto);
  const users = this.usersService.findAll()
  return res.status(200).send(users);
}
@HttpCode(202)
@Patch(':id')
update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
  return this.usersService.update(+id, updateUserDto);
}
```
* 400 에러를 보내고 싶을땐 BadRequestException 에러를 활용한다.
```
@Get(':id')
findOne(@Param('id') id: string) {
  if (+id < 1) {
    throw new BadRequestException('id는 0보다 큰 값이어야 합니다.');
  }
  return this.usersService.findOne(+id);
}
```

### 헤더

* Nest 는 응답 헤더 를 자동구성해준다.
* 만약 커스텀 헤더를 추가하고 싶다면 @Header 데커레이터를 사용한다.
* @Header 데커레이터는 인수로 헤더의 이름과 값을 받는다.
* 응답객체(res)를 사용해서 res.header() 메서드로 사용도 가능하다.
```
@Header('Custom', 'Test Header')
@Get(':id')
findOneWithHeader(@Param('id') id: string) {
  return this.usersService.findOne(+id);
}
```

### 리디렉션

* @Redirect 데커레이터를 사용하여 구현가능하다.
* 데커레이터 구번째 인수로 상태 코드를 보낸다.
* 301 Moved Permanently 는 요청한 리소스가 헤더에 주어진 리소스로 완전히 이동 돘다는 뜻이다.
* 301, 307, 308 과 같이 Redirect 로 정해진 응답 코드가 아닐경우 브라우저가 제대로 반응하지 않을수도 있다.
```
@Redirect('https://nestjs.com', 301)
@Get(':id')
findOneRedirection(@Param('id') id: string) {
  return this.usersService.findOne(+id);
}
```
* 요청 처리결과에 따라 동적으로 리디렉션 하고자 한다면 응답으로 객체를 리턴할수 있다.
```
@Get('redirect/docs')
@Redirect('https://docs.nestjs.com', 302)
getDocs(@Query('version')version){
  if(version && version === '5')
    return {url: 'https://docs.nestjs.com/v5/'}
}
```

### 라우트 매개변수(패스 매개변수)

* 