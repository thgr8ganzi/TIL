## 프로듀서

### 프로듀서 소개

* 카프카에서 데이터의 시작점은 프로듀서이다.
* 프로듀서 애플리케이션은 카프카에 필요한 데이터를 선언하고 브로커의 특정 토픽의 파티션에 전송한다.
* 카프카는 자바 라이브러리만 공식적으로 지원한다.
* 카프카 브로커로 데이터를 전송할때 내부적으로 파티셔너, 배치 생성 단계를 거친다.

### 프로듀서 내부 구조

* ProducerRecord: 프로듀서가 전송할 데이터를 담는 객체, 오프셋은 미포함
* send() : 레코드를 전송 요청 메소드
* Partitioner : 어느 파티션을 전송할지 지정하는 파티셔너, 기본값으로 DefaultPartitioner 사용
* Accumulator : 배치로 묶어 전송할 데이터르 모으는 버퍼

### 프로듀서의 기본 파티셔너

* UniformStickyPartitioner: 2.5.0 버전부터 추가된 파티셔너, 
  * 메시지 키가 있을때 : 메시지 키의 해시값과 파티션을 매칭하여 레코드 전송, 동일한 메시지 키는 동일한 파티션에 전달
  * 파티션 개수가 변경될 경우 메시지 키와 파티션 번호 매칭이 깨짐
  * 메시지 키가 없을때 : 파티션에 최대한 동일하게 분배하는 로직, 효율을 극대화
  * 어뮤큐레이터에서 레코드들이 배치로 묶일때까지 기다렸다가 전송
* RoundRobinPartitioner: 파티션을 라운드로빈 방식으로 선택

### 프로듀서의 커스텀 파티셔너

* Partitioner 인터페이스를 상속받아 파티션을 지정할수 있다.

### 프로듀서 옵션

* bootstrap.servers: 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커의 호스트 이름: 포트를 1개이상 작성
* ket.serializer: 레코드의 메시지키를 직렬화 하는 클래스 
* value.serializer: 메시지 값의 직렬화 방법

### 프로듀서 선택 옵션

* acks : 프로듀서가 전송할 데이터가 브로커들에 정상적으로 저장되어있는지 전송 여부 확인
* linger.ms : 배치를 전송하기 전까지 기다리는 최소 시간 기본값 0 
* retries : 브로커로부터 에러를 받고 난 뒤 재전송을 시도하는 횟수를 지정
* max.in.flight.requests.per.connection : 한번에 요청하느 최대 커넥션 개수
* partitioner.class : 레코드를 파티션에 전송할때 적용하는 파티셔너 클래스 지정
* enable.idempotence : 멱등성 프로듀서로 동작할지 여부를설정
* transactional.id : 프로듀서가 레코드를 전송할때 레코드를 트랜잭션 단위로 묶을지 여부 설정

### ISR(In-Sync-Replicas)

* 리더 파티션과 팔로워 파티션의 싱크가 된 상태
* 프로듀서는 리더 파티션과 통신하고
* 컨슈머는 리더 파티션에서 정보를 가져온다
* ISR은 리더 파티션과 팔로워 파티션의 동기화 상태를 나타낸다.
* 팔로워 파티션이 복제하는 시간차 때문에 리더 파티션과 팔로워 파티션 간에 오프셋 차이가 발생한다.

### acks

* acks 옵션은 0, 1, all 값을 가질수 있다.
* 이 옵션을 통해 프로듀서가 전송한 데이터가 카프카 클러스터에 얼마나 신뢰성 높게 저장할지 지정할수 있다.
* acks 옵션에 따라 성능이 달라질수 있으므로 acks 옵션에 따라 카프카 동작 방식을 알아야 한다.
* acks=0 : 프로듀서가 리더 파티션으로 데이터를 전송했을때 리더 파티션으로 데이터가 저장되었는지 확인하지 않는다는뜻, 속도는 빠르고 신뢰도는 낮다
* acks=1 : 프로듀서가 보낸 데이터가 리더파티션에만 정상적으로 적재 되었는지 확인, 리더파티션에 적재 되지 않으면 재시도 할수있다.
* acks=-1(all) : 프로듀서가 보낸 데이터가 리더, 팔로워 모두 정상적으로 적재되었는지 확인, 속도가 느리다.