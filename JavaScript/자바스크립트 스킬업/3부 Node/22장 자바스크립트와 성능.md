
## 자바스크립트와 성능

--------------------

### 단계적 컴파일

* 자바스크립트 컴파일러는 프로그램을 한번에 컴파일 하지 않는다.
* 프로그램이 실행되는 동안 필요에 따라 다시 컴파일 된다.
* 다중 컴파일 전략이 존재한다. 모든 함수는 처음 호출될때 까지 컴파일 되지 않는다.
* 대부분의 코드는 몇번만 실행되거나 실행되지 않아서 저비용 컴파일 전략으로 충분하다.
* 자주 실행되는 핫코드는 더나은 기능의 컴파일러로 다시 컴파일 한다.
* 코드의 실행과 컴파일을 병행 한다는것은 컴파일러가 코드를 사용해 컴파일을 시작할 시점에 이미 여러번 코드가 실행되었음을 의미한다.

### 그래프 레이아웃

* 각 노드는 인접한 모든 노드와 연결되지만 혼잡하지 않은 방식으로 각 노드를 배치한다.
* 너무 얽혀있지 않는 소규모그래프를 배치하기 위해 힘지향 그래프 레이아웃 방식을 적용한다.
* 보기좋은 레이아웃이 될때까지 많이 반복해야하고 각반복마다 힘을 여러번 계상해야 하므로 성능이 중요하다
* Chrome 에서는 for/of 반복문을 일반적인 for 문으로 대체하면 속도의 영향이 크게 나타나지 않지만 다른 브라우저는 차이가 있을수 있다.

### 프로파일링

* 최신 브라우저의 개발자 도구에서는 프로그램의 속도를 측정할수있는 프로파일러를 제공한다.
* 자바스크립트엔진은 매우 효율적인 가비지콜렉터가 포함돼 있다.

### 함수 인라인

* 함수 인라인을 사용해 코드를 빠르게 하는 여러가지 방법이 존재한다.
* 함수가 실행되는 동안 항상 동일한 함수를 처리했다면 인라인으로 처리하는것이 합리적이다.
* 그런 함수는 낙관적 컴파일된다.

### 가비지콜렉션

* 프로그램의 메모리 공간은 여유공간과 사용중인 객체가 뒤섞여 있다.
* 원칙적으로 어떤 객체가 아직 사용중인지 파악하려면 전역 범위에서 부터 현재  활성화된 로컬 범위까지 접근할수 있는 모든 객체를 추적해야한다.
* 이런 범위에서 직.간접적으로 첨조하고 이는 객체는 아직 사용중인 객체다.
* 세대별 가비지 콜렌셕이라는 기법으로 이러한 비용을 줄일수 있다.
* 자바스크립트 프로그램에서 사용할수 있는 메모리를 2세대 이상의 세대로 분할해 yong 영역용으로 예약된 공간에 새로운 객체각 만들어지고 이 공간이 가득차면 엔진에서는 어떤 객체가 아직 살아 있는지  파악하고 다음영역으로 해당객체를 옮긴다.
* 이런 상황이 발생했을때 yong 영역의 객체중 일부만 살아있다면 객체를 옮기는데 적은양의 작업이 수행된다.
* 물론 어떤 객체가 살아있는지 파악하려면 살아있는 영역에 객체에 대한 모든 참고를 알고있어야 한다.
* 하지만 가비지 콜렉터에서는 yong 영역이 수집될때 old 영역의 모든 개체를 확인하지 않는다.
* 따라서 모든 오래된 객체와 새로운 객체가 참조될때 마다 이를 기록해 다음 가비지 콜렌션에서 사용할수 있도록 처리한다.

### 동적유형

* 객체 속성을 조회하는 표현식은 컴파일이 단순하지 않다.
* 자바스크립트에서는 값에만 유형이 존재하며 바인딩은 다양한 유형의 값을 가질수 있다.
* 컴파일된 코드에서 가정(assumptions)이 계속 유지되는지 여부를 확인하고 그렇지 않으면 적절한 조치를 취해아한다.
* 엔진이 최적화 되지 않은 버전의 함수로 되돌려 완전 최적화를 해제하거나 새롭게 발견된 유형을 처리하는 샐운 버전의 함수를 컴파일하게 된다.
* 자바스크립트를 프로토타입 체인에 의해 속성을 뱉어내야하므로 속성을 가정하여 정해주면 프로토타입 체이닝이 발생하지 않아 속도가 향상된다.