
## 비동기 프로그래밍

--------------------------------

### 비동기성

* 동기식 프로그래밍 모델에서는 한번에 하나씩 작업이 처리된다.
* 비동기 모델을 사용하면 여러 작업을 동시에 처리할 수 있다.
* 동기 시스템에서는 추가적인 제어 스레드를 시작해서 여러 작업을 동시에 처리할 수 있다.
* 동기식 모델에서는 암시적으로 동작 완료를 기다리는 반면 비동기식 모델에서는 명시적으로 제어한다는 것이다.

### 콜백

* 비동기 프로그래밍의 한가지 방식은 추가적인 콜백 함수를 인수로 사용해서 느린 동작을 처리하는 함수를 만드는 것이다.
* 콜백을 호출하는것은 단순한 값을 반환하는것보다 다소 복잡하고 오류가 발생하기 쉽다. 대부분을 콜백 호출로 구성하는것은 권장하지 않는다.

### 프로미스

* 비동기 작업의 경우는 나중에 어느 시점에 함수가 호출되도록 하는 대신 미래 이벤트를 나타내는 객체인 Promise 를 반환할수 있다.
* 프로미스는 특정 시점에 완료돼 값을 생성하는 비동기 작업이다. 이 값을 사용할수 있는 시점에 관심을 가지고 있는 특정 대상에게 알려줄수 있다.
* 프로미스를 생성하는 가장 쉬운 방법은 Promis.resolce 를 호출하는 것이다.
* 위 함수는 사용자가 전달한 값을 프로미스로 래핑한다.
* 전달한 값이 이미 프로미스라면 단순히 반환 하며 그렇지 않다면 전달한 값을 사용해 즉시 완료되는 새로운 프로미스를 결과로 얻게 된다.
* 프로미스는 then 사용하면 resolve 되고 값이 생성되는 시점에 호출될 콜백 함수를 등록한ㄷ.
* 하나의 Promise 에 여러개의 콜백을 추가할수 있으며 프로미스가 이미 리졸브 된 다음에 추가하더라도 호출된다.
* 프로미스를 만들기 위해 Promise 생성자를 사용할수도 있다. 이생성자의 인수는 함수이고 즉시 호출해서 프로미스를 리졸브 하는데 사용할 함수를 전달한다. 해당 프로미스를 생성한 코드에서만 리졸브 할수있다.
* 프로미스 기반함수는 콜백을 전달하지 않으며 인수를 입력받고 출력을 반환하는 일반 함수와 비슷해 보인다.
* 일반 함수와 유일하게 다른부분은 출력을 즉시 사용하지 못할수도 있다는 점이다.
```
let fifteen = Promise.resolve(15);
fifteen.then(value => console.log(`Got ${value}`)); // Got 15

function storage(nest, name) {
    return new Promise(resolve => {
        nest.readStorage(name, result => resolve(result));
    });
}
stroage(bigOak, "enemies").then(value => console.log("Got", value));
```